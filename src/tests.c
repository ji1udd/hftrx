//
// Проект HF Dream Receiver (КВ приёмник мечты)
// автор Гена Завидовский mgs2001@mail.ru
// UA1ARN
//

#include "hardware.h"
#include "synthcalcs.h"
#include "board.h"
#include "audio.h"
#include "keyboard.h"
#include "encoder.h"

#include <math.h>
#include "src/gui/gui.h"
#include <stdio.h>

#include "display/display.h"
#include "formats.h"

#include "codecs/tlv320aic23.h"	// константы управления усилением кодека
#include "codecs/nau8822.h"
#include "spi.h"
#include "gpio.h"

#if WITHUSEAUDIOREC
	#include "fatfs/ff.h"
	#include "sdcard.h"
#endif /* WITHUSEAUDIOREC */

#include <string.h>
#include <ctype.h>
#include <math.h>
#include <stdbool.h>


#if 0
// Печать параметров на экране
static void showpos(uint_fast8_t pos)
{
	//static unsigned  count;
	//count ++;
	char buff [22];

	local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
		PSTR("POS %2u"), (unsigned) pos
		 );
	display_gotoxy(0, 0);
	display_at(buff, 0);
}

#endif

#if ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED

// e-inc support functions
static uint_fast8_t eink_lcd_busy(void)
{
	enum { WORKMASK = 1U << 1 };	/* PB1 */
	arm_hardware_piob_inputs(WORKMASK);
	return (GPIOB->IDR & WORKMASK) != 0;
}
static void eink_lcd_discharge(uint_fast8_t state)
{
	enum { WORKMASK = 1U << 3 };	/* PB3 */
	arm_hardware_piob_outputs(WORKMASK, WORKMASK * (state != 0));

}
static void eink_lcd_backlight(uint_fast8_t state)
{
	enum { WORKMASK = 1U << 4 };	/* PB4 */
	arm_hardware_piob_outputs(WORKMASK, WORKMASK * (state != 0));

}
static void eink_lcd_on_border(uint_fast8_t state)
{
	enum { WORKMASK = 1U << 4 };	/* PB4 */
	arm_hardware_piob_outputs(WORKMASK, WORKMASK * (state != 0));

}
static void eink_lcd_toggle_border(void)
{
	enum { WORKMASK = 1U << 4 };	/* PB4 */
	GPIOB->ODR ^= WORKMASK;			// border bit
}
static void eink_lcd_pwron(uint_fast8_t state)
{
	enum { WORKMASK = 1U << 5 };	/* PB5 */
	arm_hardware_piob_outputs(WORKMASK, WORKMASK * (state != 0));

}

static void test_cpu_pwron(uint_fast8_t state)
{
	enum { WORKMASK = 1U << 11 };	/* PA11 */
	arm_hardware_pioa_outputs(WORKMASK, WORKMASK * (state != 0));

}


static void check_poweroff(void)
{
	uint_fast8_t kbch, repeat;

	if ((repeat = kbd_scan(& kbch)) != 0)
	{
		switch (kbch)
		{
		case KBD_CODE_0:
			test_cpu_pwron(1);
			eink_lcd_backlight(1);	// backlight ON
			break;

		case KBD_CODE_1:
			eink_lcd_backlight(0);	// backlight off
			test_cpu_pwron(0);
			break;

		}
		return;
	}

}


static void local_delay_ms_spool(int ms)
{
	int v = ms / 5;
	while (v --)
	{
		local_delay_ms(5);
		check_poweroff();
	}
}

enum { EINC_SPIMODE = SPIC_MODE0 };

static void
eink_reset(void)
{
	local_delay_ms(25);		// delay after power-up
	board_lcd_reset(0); 	// Pull RST pin down
	board_update();
	local_delay_ms(25);		// local_delay_ms 5 mS (minimum by documentation - 1 mS).
	board_lcd_reset(1); 	// Pull RST pin up
	board_update();
	local_delay_ms(25);		// local_delay_ms 5 mS (minimum by documentation - 1 mS).
}

static uint_fast8_t eink_read(uint_fast8_t addr)
{
	uint_fast8_t v;
	const spitarget_t target = targetlcd;
	//
	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x70);
	spi_progval8_p2(target, addr);
	spi_complete(target);
	spi_unselect(target);

	local_delay_us(10);

	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x73);
	spi_complete(target);
	v =  spi_read_byte(target, 0x00);

	spi_unselect(target);
	return v;
}

static uint_fast8_t eink_read_id(void)
{
	uint_fast8_t v;
	const spitarget_t target = targetlcd;
	//
	local_delay_us(15);
	spi_select(target, EINC_SPIMODE);
	spi_progval8_p1(target, 0x71);
	spi_complete(target);

	v =  spi_read_byte(target, 0x00);

	spi_unselect(target);
	return v;
}

static void eink_write(uint_fast8_t addr, uint_fast8_t v)
{
	const spitarget_t target = targetlcd;
	//
	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x70);
	spi_progval8_p2(target, addr);
	spi_complete(target);

	spi_unselect(target);

	local_delay_us(10);

	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x72);
	spi_progval8_p2(target, v);

	spi_complete(target);

	spi_unselect(target);
}

void epd_spi_send (unsigned char register_index, const unsigned char *register_data,
               unsigned length) {
	const spitarget_t target = targetlcd;
	//
	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x70);
	spi_progval8_p2(target, register_index);
	spi_complete(target);

	spi_unselect(target);

	local_delay_us(10);

	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x72);
	while (length --)
		spi_progval8_p2(target, * register_data ++);
	spi_complete(target);

	spi_unselect(target);
}

uint8_t SPI_R(uint8_t Register, uint8_t Data) 
{
	uint_fast8_t v;
	const spitarget_t target = targetlcd;
	//
	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x70);
	spi_progval8_p2(target, Register);
	spi_complete(target);
	spi_unselect(target);

	local_delay_us(10);

	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x73);
	spi_complete(target);
	v =  spi_read_byte(target, Data);

	spi_unselect(target);
	return v;
}

static void eink_write8bytes(uint_fast8_t addr, 
	uint_fast16_t v1, 
	uint_fast16_t v2, 
	uint_fast16_t v3, 
	uint_fast16_t v4)
{
	const spitarget_t target = targetlcd;
	//
	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x70);
	spi_progval8_p2(target, addr);
	spi_complete(target);

	spi_unselect(target);

	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x72);
	spi_progval8_p2(target, v1 >> 8);
	spi_progval8_p2(target, v1 >> 0);
	spi_progval8_p2(target, v2 >> 8);
	spi_progval8_p2(target, v2 >> 0);
	spi_progval8_p2(target, v3 >> 8);
	spi_progval8_p2(target, v3 >> 0);
	spi_progval8_p2(target, v4 >> 8);
	spi_progval8_p2(target, v4 >> 0);
	spi_complete(target);

	spi_unselect(target);
}

// return: 3: scan on, 0: scan off
static uint_fast8_t getscan4bytes(uint_fast8_t row, uint_fast8_t line, uint_fast8_t stage)
{
	switch (stage)
	{
	case 0: return 0xff;
	case 1: return 0xff;
	}
	uint_fast8_t r = 0;
	r = (r << 2) | ((row == line) ? 0x03 : 0x00); -- row;
	r = (r << 2) | ((row == line) ? 0x03 : 0x00); -- row;
	r = (r << 2) | ((row == line) ? 0x03 : 0x00); -- row;
	r = (r << 2) | ((row == line) ? 0x03 : 0x00);
	return r;
}

#include "./display/fonts/ls020_font_small.h"

static const char eitext [] = "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890";
//static const char eitext [] = "#######################################################################################-------------------------------------";

static uint_fast8_t
ascii_decode(uint_fast8_t c)
{
	return c - ' ';
}

// Выборка значений из буфера изображения
// значения:
// 3 - black
// 2 - while
// 0 - nothing (не модифицируется) - если вне окна, разрешённого к обновлению.
// col: 0..199. row: 0..95
static uint_fast8_t getbufferbit(uint_fast8_t col, uint_fast8_t row, uint_fast8_t stage)
{
	static const uint_fast8_t pattern [16] =
	{
		0xc0, 0x60, 0x30, 0x18, 0x06, 0x06, 0x03, 0x01,
		0xc0, 0x60, 0x30, 0x18, 0x06, 0x06, 0x03, 0x01,
	};

	switch (stage)
	{
	case 0: return 3;
	case 1: return 2;
	}

	//debug_printf_P(PSTR("getbufferbit: col=%d, row=%d\n"), col, row);

	uint_fast8_t charrow = row % SMALLCHARH;
	uint_fast8_t charcol = col % 8;
	uint_fast8_t textcol = col / 8;
	//if (textcol >= strlen(eitext))
	//	return 0;

#if 0
	const uint_fast8_t c = ascii_decode((unsigned char) eitext [textcol]);
	enum { NBYTES = (sizeof ls020_smallfont [0] / sizeof ls020_smallfont [0][0]) };
	const FLASHMEM uint8_t * p = & ls020_smallfont [c][0];
	return (p [SMALLCHARH - 1 - charrow] & (128U >> charcol)) ? 3 : 2;
#else
	const uint_fast8_t * p = pattern;
	return (p [charrow] & (1U << charcol)) ? 3 : 2;
#endif
}

// формирование байтов для передачи в дисплей
	// col code 198, 196..0
static uint_fast8_t getrow4byteseven(uint_fast8_t col, uint_fast8_t row, uint_fast8_t stage)
{
	uint_fast8_t r = 0;
	// row/col - координаты пикселя
	r = (r << 2) | getbufferbit(col, row, stage); col -= 2;
	r = (r << 2) | getbufferbit(col, row, stage); col -= 2;
	r = (r << 2) | getbufferbit(col, row, stage); col -= 2;
	r = (r << 2) | getbufferbit(col, row, stage);;
	return r;
}

// формирование байтов для передачи в дисплей
// col code 1, 3..199
static uint_fast8_t getrow4bytesodd(uint_fast8_t col, uint_fast8_t row, uint_fast8_t stage)
{
	uint_fast8_t r = 0;
	// row/col - координаты пикселя
	r = (r << 2) | getbufferbit(col, row, stage); col += 2;
	r = (r << 2) | getbufferbit(col, row, stage); col += 2;
	r = (r << 2) | getbufferbit(col, row, stage); col += 2;
	r = (r << 2) | getbufferbit(col, row, stage);;
	return r;
}

static void eink_BWdummyline(uint_fast8_t bv)
{
	const spitarget_t target = targetlcd;
	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x70);
	spi_progval8_p2(target, 0x0a);		// 75 байт данных
	spi_complete(target);
	spi_unselect(target);

	spi_select(target, EINC_SPIMODE);
	spi_progval8_p1(target, 0x72);

	spi_progval8_p2(target, bv);
	int n;
	for (n = 0; n < 74; ++ n)
		spi_progval8_p2(target, 0x00);
	spi_complete(target);
	spi_unselect(target);

	eink_write(0x02, 0x07);	// Output data from COG driver to panel.
}

static void eink_dummyline(void)
{
	const spitarget_t target = targetlcd;
	spi_select(target, EINC_SPIMODE);

	spi_progval8_p1(target, 0x70);
	spi_progval8_p2(target, 0x0a);		// 75 байт данных
	spi_complete(target);
	spi_unselect(target);

	spi_select(target, EINC_SPIMODE);
	spi_progval8_p1(target, 0x72);

	while (eink_lcd_busy())
		debug_printf_P(PSTR("eink: wait busy\n"));
	spi_progval8_p2(target, 0x00);
	int n;
	for (n = 0; n < 74; ++ n)
	{
		while (eink_lcd_busy())
			debug_printf_P(PSTR("eink: wait busy\n"));
		spi_progval8_p2(target, 0x00);
	}
	spi_complete(target);
	spi_unselect(target);

	eink_write(0x02, 0x07);	// Output data from COG driver to panel.
}


static void eink_displayimage(uint_fast8_t stage)
{
	


	{
		uint_fast8_t state = eink_read(0x0f);		// Check DC/DC
		if ((state & 0x40) != 0)
		{
		}
		else
		{
			debug_printf_P(PSTR("eink: Feedback to System (14) - dc/dc is not started, state=%02x\n"), state);
		}
	}	

	// 200 x 96
	const spitarget_t target = targetlcd;
	//
	int row;
	for (row = 0; row < 96; ++ row)
	{
		//eink_lcd_toggle_border();
		int col8;
		int row4;
		// send each line
		spi_select(target, EINC_SPIMODE);

		spi_progval8_p1(target, 0x70);
		spi_progval8_p2(target, 0x0a);		// 75 байт данных
		spi_complete(target);
		spi_unselect(target);

		spi_select(target, EINC_SPIMODE);
		spi_progval8_p1(target, 0x72);

		spi_progval8_p2(target, 0x00);	// border byte


		// send 1..25 (50 total) data byte
		// lines 199, 197.. 1
		// line code 198, 196..0
		// Data Bytes
		for (col8 = 0; col8 < 25; ++ col8)
		{
			while (eink_lcd_busy())
				debug_printf_P(PSTR("eink: wait busy\n"));
			spi_progval8_p2(target, getrow4byteseven(198 - col8 * 8, row, stage));
		}
		// Scan bytes
		// send 1..24 (24 total) scan byte
		for (row4 = 0; row4 < 24; ++ row4)
		{
			while (eink_lcd_busy())
				debug_printf_P(PSTR("eink: wait busy\n"));
			spi_progval8_p2(target, getscan4bytes(95 - row4 * 4, row, stage));
		}
		// send 26..50 (50 total) data byte
		// lines 2, 4, .. 200
		// line code 1, 3..199
		// Data Bytes
		for (col8 = 0; col8 < 25; ++ col8)
		{
			while (eink_lcd_busy())
				debug_printf_P(PSTR("eink: wait busy\n"));
			spi_progval8_p2(target, getrow4bytesodd(col8 * 8 + 1, row, stage));
		}
		//spi_progval8_p2(target, 0x00);	// border byte
		spi_complete(target);
		spi_unselect(target);
		//local_delay_ms(20);
		eink_write(0x02, 0x07);	// Output data from COG driver to panel.
		if (stage == 2)
			local_delay_ms(200);	// delay for show results of patern putput
	}
}

void eink_initialize(void)
{
	debug_printf_P(PSTR("eink test, SPISPEED=%ld\n"), (long) SPISPEED);

	eink_lcd_on_border(1);
	// Section 3: Power On G2 COG Driver
	board_lcd_reset(0); 	// Pull RST pin down
	board_update();
	local_delay_ms(50);
	eink_lcd_pwron(1);
	eink_lcd_discharge(0);		// 1=discharge

	local_delay_ms(50);

	eink_reset();

	int w = 0;

#if 1
	// Section 4: Initialize G2 COG Driver
	debug_printf_P(PSTR("eink: Section 4: Initialize G2 COG Driver\n"));
	while (eink_lcd_busy() != 0)
	{
		debug_printf_P(PSTR("eink: wait busy\n"));
		//eink_lcd_toggle_border();
		local_delay_ms(500);
		++ w;
	}
	uint_fast8_t id = eink_read_id();
	if ((id & 0x0f) == 0x02)
	{
		eink_write(0x02, 0x40);	// Disable OE
		const uint_fast8_t status = eink_read(0x0f);	// Check Breakage
		if ((status & 0x80) != 0)
		{
			debug_printf_P(PSTR("eink: Check Breakage pass\n"));
			eink_write(0x0b, 0x02);	// Power Saving Mode

			// Channel Select
#if 1
			// 2": SPI(0x01, (0x0000,0x0000,0x01FF,0xE000))
			eink_write8bytes(0x01,		// Channel Select
					0x0000,
					0x0000,
					0x01FF,
					0xE000
					);
#else
			// 2.7": SPI(0x01, (0x0000,0x007F,0xFFFE,0x0000))
			eink_write8bytes(0x01,		// Channel Select
					0x0000,
					0x007F,
					0xFFFE,
					0x0000
					);
#endif

			eink_write(0x07, 0xd1);	// High Power Mode Osc Setting
			eink_write(0x08, 0x02);	// Power Setting
			eink_write(0x09, 0xc2);	// Set Vcom level
			eink_write(0x04, 0x03);	// Power Setting
			eink_write(0x03, 0x01);	// Driver latch on
			eink_write(0x03, 0x00);	// Driver latch off
			local_delay_ms(10);		// Delay >= 5ms

			uint_fast8_t i;
			for (i = 0; i < 4; ++ i)
			{
				debug_printf_P(PSTR("eink: Start chargepump\n"));
				eink_write(0x05, 0x01);	// Start chargepump positive V
				eink_write(0x05, 0x03);	// Start chargepump neg voltage
				eink_write(0x05, 0x0f);	// Set chargepump Vcom_Driver to ON
				local_delay_ms(300);
				const uint_fast8_t status = eink_read(0x0f);	// Check DC/DC
				if ((status & 0x40) != 0)
				{
					eink_write(0x02, 0x40);	// Output enable to disable
					goto sect4done;
				}
			}
			debug_printf_P(PSTR("eink: Feedback to System (1), status=%02x\n"), status);
		}
		else
		{
			debug_printf_P(PSTR("eink: Feedback to System (2)\n"));
		}
	}
	else
	{
		debug_printf_P(PSTR("eink: Feedback to System (3)\n"));
	}
#endif
sect4done:
	eink_write(0x02, 0x40);	// Output enable to disable
	debug_printf_P(PSTR("eink: Section 4: Initialize G2 COG Driver done\n"));
	eink_lcd_on_border(1);

	for (;;)
	{
		eink_displayimage(0);
		eink_displayimage(1);
		eink_displayimage(2);
	}

	/*
	eink_BWdummyline(0xff);
	eink_BWdummyline(0xaa);
	eink_dummyline();
	*/
	debug_printf_P(PSTR("eink reset done, w = %d\n"), w);
	for (;;)
	{
		//eink_lcd_toggle_border();
		local_delay_ms(500);
		uint_fast8_t id = eink_read_id();

		uint_fast8_t v2 = eink_read(0x02);
		const uint_fast8_t status = eink_read(0x0f);	// Check DC/DC

		debug_printf_P(PSTR("eink id=%02x.v2=%02x,status=%02x\n"), id, v2, status);
		if (id != 0xff)
			break;
	}
	// 6 Power off G2 COG Driver
	{
		uint_fast8_t state = eink_read(0x0f);		// Check DC/DC
		if ((state & 0x40) != 0)
		{
			eink_write(0x03, 0x01);	// Turn on Latch Reset
			eink_write(0x02, 0x05);	// Turn off OE
			eink_write(0x05, 0x0e);	// Power off positive charge pump
			eink_write(0x05, 0x02);	// Power off charge pump Vcom
			eink_write(0x05, 0x00);	// Turn off all charge pumps
			eink_write(0x07, 0x0d);	// Turn off OSC
			eink_write(0x04, 0x83);	// Discharge internal
			local_delay_ms(150);	// Delay >= 120ms
			eink_write(0x04, 0x00);	// Turn off discharge internal
		}
		else
		{
			debug_printf_P(PSTR("eink: Feedback to System (4) - dc/dc is not started\n"));
		}
	}
	debug_printf_P(PSTR("eink test done, w = %d\n"), w);
	board_lcd_reset(0); 	// Pull RST pin down
	board_update();
	eink_lcd_discharge(1);		// 1=discharge
	eink_lcd_pwron(0);
	debug_printf_P(PSTR("eink reset\n"));
}


#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */

#if 1 && ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED
/**
* \file
*
* \brief The waveform driving processes and updating stages of G2 COG with V230 EPD
*
* Copyright (c) 2012-2014 Pervasive Displays Inc. All rights reserved.
*
* \asf_license_start
*
* \page License
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
* 1. Redistributions of source code must retain the above copyright notice,
*    this list of conditions and the following disclaimer.
*
* 2. Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the documentation
*    and/or other materials provided with the distribution.
*
* 3. The name of Atmel may not be used to endorse or promote products derived
*    from this software without specific prior written permission.
*
* 4. This software may only be redistributed and used in connection with an
*    Atmel microcontroller product.
*
* THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
* EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
* POSSIBILITY OF SUCH DAMAGE.
*
* \asf_license_stop
**/

//#include "EPD_COG_Process.h"

#define COG_V230_G2 1


#define USE_EPD144 0 /**< 1.44 inch PDi EPD */
#define USE_EPD200 1 /**< 2 inch PDi EPD */
#define USE_EPD270 2 /**< 2.7 inch PDi EPD */

/* Using which EPD size for demonstration. 
 * Change to USE_EPD270 if you are connecting with 2.7 inch EPD. USE_EPD144 for 1.44 inch. */
#define USE_EPD_Type USE_EPD200 /**< default is connecting with 2 inch EPD */

#if (USE_EPD_Type==USE_EPD144) // array size=96*16, (128/8=16)
	extern uint8_t const image_array_144_1[]; /**< use 1.44" image array #1 */
	extern uint8_t const image_array_144_2[]; /**< use 1.44" image array #2 */
#elif (USE_EPD_Type==USE_EPD200) // array size=96*25, (200/8=25)
	extern uint8_t const image_array_200_1[]; /**< use 2" image array #1 */
	extern uint8_t const image_array_200_2[]; /**< use 2" image array #2 */
#elif (USE_EPD_Type==USE_EPD270) // array size=176*33, (264/8=33)
	extern uint8_t const image_array_270_1[]; /**< use 2.7" image array #1 */
	extern uint8_t const image_array_270_2[]; /**< use 2.7" image array #2 */
#endif


#if (USE_EPD_Type==USE_EPD144)
#define image_width_144 128 /**< the resolution of 1.44 inch is 128*96 */
#define image_height_144 96 /**< the image array size of 1.44 inch is 96*16 where 16=128/8 */
uint8_t const image_array_144_1[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 1
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 2
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x3C, 0xFF, 0x00, 0x03,  // 3
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x3C, 0xFF, 0x00, 0x03,  // 4
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0x33, 0xFF, 0x3F, 0xF3,  // 5
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0x33, 0xFF, 0x3F, 0xF3,  // 6
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x03, 0x33, 0x0F, 0x30, 0x33,  // 7
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x03, 0x33, 0x0F, 0x30, 0x33,  // 8
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x03, 0x3C, 0xCF, 0x30, 0x33,  // 9
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x03, 0x3C, 0xCF, 0x30, 0x33,  // 10
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x03, 0x30, 0x0F, 0x30, 0x33,  // 11
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x03, 0x30, 0x0F, 0x30, 0x33,  // 12
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0x30, 0x0F, 0x3F, 0xF3,  // 13
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0x30, 0x0F, 0x3F, 0xF3,  // 14
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x33, 0x33, 0x00, 0x03,  // 15
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x33, 0x33, 0x00, 0x03,  // 16
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xCF, 0xFF, 0xFF,  // 17
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xCF, 0xFF, 0xFF,  // 18
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xCF, 0x0F, 0x03, 0x03, 0x0F,  // 19
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xCF, 0x0F, 0x03, 0x03, 0x0F,  // 20
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0C, 0xFC, 0x3C, 0xC0, 0xFF,  // 21
  0xFF, 0xFF, 0x1E, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x0C, 0xFC, 0x3C, 0xC0, 0xFF,  // 22
  0xFF, 0xFE, 0x1E, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x0F, 0x3F, 0xC3, 0x0F, 0x33,  // 23
  0xFF, 0xFE, 0x1E, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x0F, 0x3F, 0xC3, 0x0F, 0x33,  // 24
  0xFF, 0xFC, 0x1E, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xF0, 0x0F, 0xCF, 0x3F, 0x0C, 0xF3,  // 25
  0xFF, 0xF8, 0x1E, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xF0, 0x0F, 0xCF, 0x3F, 0x0C, 0xF3,  // 26
  0xFF, 0xF0, 0x9E, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFC, 0x0C, 0x0F, 0xF3, 0xCF, 0x03,  // 27
  0xFF, 0xE1, 0x9C, 0x01, 0xF0, 0x38, 0x3F, 0xE0, 0x3F, 0x1F, 0xFC, 0x0C, 0x0F, 0xF3, 0xCF, 0x03,  // 28
  0xFF, 0xC3, 0x9C, 0x01, 0xE0, 0x00, 0x0F, 0x80, 0x0F, 0x1F, 0xFF, 0xFF, 0xF0, 0x03, 0x0F, 0xFF,  // 29
  0xFF, 0xC7, 0x9C, 0x01, 0xC0, 0x00, 0x07, 0x80, 0x07, 0x1F, 0xFF, 0xFF, 0xF0, 0x03, 0x0F, 0xFF,  // 30
  0xFF, 0x0F, 0x9E, 0x3F, 0x8F, 0x87, 0xC3, 0x0F, 0xC3, 0x1F, 0xF0, 0x00, 0x30, 0xC0, 0xC0, 0x0F,  // 31
  0xFF, 0x0F, 0x9E, 0x3F, 0x8F, 0xC7, 0xC3, 0x1F, 0xC3, 0x1F, 0xF0, 0x00, 0x30, 0xC0, 0xC0, 0x0F,  // 32
  0xFE, 0x03, 0x9E, 0x3F, 0x8F, 0xC7, 0xC3, 0x00, 0x03, 0x1F, 0xF3, 0xFF, 0x3F, 0xCF, 0xCC, 0xCF,  // 33
  0xFE, 0x03, 0x9E, 0x3F, 0x8F, 0xC7, 0xE3, 0x00, 0x03, 0x1F, 0xF3, 0xFF, 0x3F, 0xCF, 0xCC, 0xCF,  // 34
  0xF8, 0x03, 0x9E, 0x3F, 0x8F, 0xC7, 0xE3, 0x00, 0x03, 0x1F, 0xF3, 0x03, 0x3C, 0x00, 0xFF, 0xC3,  // 35
  0xF0, 0xFF, 0x9E, 0x3F, 0x8F, 0xC7, 0xE3, 0x1F, 0xFF, 0x1F, 0xF3, 0x03, 0x3C, 0x00, 0xFF, 0xC3,  // 36
  0xE1, 0xFF, 0x9E, 0x3F, 0x8F, 0xC7, 0xE3, 0x1F, 0xFF, 0x1F, 0xF3, 0x03, 0x30, 0xF3, 0xF3, 0xF3,  // 37
  0xE3, 0xFF, 0x9F, 0x0F, 0x8F, 0xC7, 0xE3, 0x0F, 0xC3, 0x0F, 0xF3, 0x03, 0x30, 0xF3, 0xF3, 0xF3,  // 38
  0xC7, 0xFF, 0x9F, 0x01, 0x8F, 0xC7, 0xE3, 0x87, 0x87, 0x81, 0xF3, 0x03, 0x3C, 0xC3, 0xC3, 0x33,  // 39
  0x87, 0xFF, 0x9F, 0x81, 0x8F, 0xC7, 0xE3, 0x80, 0x0F, 0xC1, 0xF3, 0x03, 0x3C, 0xC3, 0xC3, 0x33,  // 40
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xF3, 0xFF, 0x33, 0x3C, 0xC3, 0xFF,  // 41
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0x33, 0x3C, 0xC3, 0xFF,  // 42
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x30, 0xF3, 0x3F, 0x0F,  // 43
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x30, 0xF3, 0x3F, 0x0F,  // 44
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 45
  0xFF, 0xFF, 0xFF, 0xFE, 0x0F, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 46
  0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 47
  0xFF, 0xFF, 0xFF, 0xFF, 0x86, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 48
  0xFF, 0xFF, 0xFF, 0xFF, 0x82, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 49
  0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 50
  0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 51
  0x81, 0x81, 0xC0, 0xFF, 0xE0, 0x3E, 0x07, 0x3F, 0xC7, 0x86, 0x7D, 0x81, 0x81, 0xFF, 0xFF, 0xFF,  // 52
  0x9F, 0x9C, 0xCE, 0x7F, 0xF0, 0x7E, 0x73, 0x3F, 0xC7, 0xCE, 0x3D, 0x9F, 0x9C, 0xFF, 0xFF, 0xFF,  // 53
  0x9F, 0x9C, 0xCF, 0x3F, 0xE0, 0x3E, 0x73, 0x3F, 0x93, 0xCE, 0x9D, 0x9F, 0x9E, 0x7F, 0xFF, 0xFF,  // 54
  0x9F, 0x9C, 0xCF, 0x3F, 0xE0, 0x3E, 0x73, 0x3F, 0x93, 0xCE, 0x9D, 0x9F, 0x9E, 0x7C, 0x30, 0xE3,  // 55
  0x81, 0x9C, 0xCF, 0x3F, 0xC0, 0x1E, 0x73, 0x3F, 0x93, 0xCE, 0xCD, 0x81, 0x9E, 0x7D, 0xB6, 0x59,  // 56
  0x9F, 0x81, 0xCF, 0x3F, 0x82, 0x0E, 0x07, 0x3F, 0x93, 0xCE, 0xE5, 0x9F, 0x9E, 0x7D, 0xB6, 0x9D,  // 57
  0x9F, 0x9F, 0xCF, 0x3F, 0x87, 0x0E, 0x7F, 0x3F, 0x01, 0xCE, 0xE5, 0x9F, 0x9E, 0x7C, 0x31, 0x9D,  // 58
  0x9F, 0x9F, 0xCE, 0x7F, 0x07, 0x06, 0x7F, 0x3F, 0x39, 0xCE, 0xF1, 0x9F, 0x9C, 0xFD, 0xF4, 0xD9,  // 59
  0x81, 0x9F, 0xC0, 0xFE, 0x0F, 0x82, 0x7F, 0x01, 0x39, 0x86, 0xF9, 0x81, 0x81, 0xFD, 0xF6, 0x43,  // 60
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 61
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 62
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 63
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 64
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 65
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 66
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 67
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 68
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 69
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 70
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 71
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 72
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 73
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 74
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 75
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 76
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 77
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 78
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 79
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 80
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 81
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 82
  0xF0, 0x60, 0xC0, 0xCF, 0xBB, 0xE0, 0xC9, 0xF2, 0x0E, 0x03, 0x9C, 0x30, 0x67, 0xF9, 0x9F, 0x63,  // 83
  0xF3, 0x27, 0xCC, 0x47, 0x33, 0xCC, 0xCD, 0xF6, 0x7E, 0x79, 0x99, 0xF3, 0x27, 0xF9, 0xCE, 0x5D,  // 84
  0xF3, 0xA7, 0xCE, 0x47, 0x31, 0xCF, 0xCC, 0xE6, 0x7E, 0x7C, 0x9B, 0xF3, 0xA7, 0xF8, 0xCE, 0xDF,  // 85
  0xF3, 0xA7, 0xCE, 0x67, 0x61, 0xC7, 0xCC, 0xE6, 0x7E, 0x7C, 0x99, 0xF3, 0xA7, 0xF6, 0xE4, 0xCF,  // 86
  0xF3, 0x20, 0xCC, 0xE2, 0x68, 0xE3, 0xCE, 0x6E, 0x0E, 0x7E, 0x9C, 0x72, 0x27, 0xF6, 0x71, 0xE3,  // 87
  0xF0, 0x67, 0xC1, 0xF2, 0xCC, 0xF1, 0xCE, 0x6E, 0x7E, 0x7E, 0x9E, 0x30, 0xE7, 0xE0, 0x7B, 0xF9,  // 88
  0xF3, 0xE7, 0xC0, 0xF0, 0xC0, 0xF9, 0xCE, 0x4E, 0x7E, 0x7C, 0x9F, 0x93, 0xE7, 0xEE, 0x7B, 0xFD,  // 89
  0xF3, 0xE7, 0xCC, 0xF0, 0x9E, 0x7C, 0xCF, 0x1E, 0x7E, 0x7C, 0x9F, 0x93, 0xE7, 0xCF, 0x3B, 0xFD,  // 90
  0xF3, 0xE7, 0xCC, 0x79, 0x9E, 0x4C, 0xCF, 0x1E, 0x7E, 0x79, 0x9B, 0xB3, 0xE7, 0xDF, 0x3B, 0xDD,  // 91
  0xF3, 0xE0, 0xCE, 0x79, 0xBF, 0x61, 0xCF, 0xBE, 0x0E, 0x03, 0x98, 0x73, 0xE0, 0x5F, 0x9B, 0xE3,  // 92
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 93
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 94
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 95
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF   // 96
};
//2013/04/03 Resolution: 128 x 96


uint8_t const image_array_144_2[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 1
  0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 2
  0xFF, 0xFF, 0xC0, 0x3C, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 3
  0xFF, 0xFE, 0x1E, 0x10, 0x78, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 4
  0xFF, 0xFC, 0x30, 0x7F, 0x0C, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 5
  0xFF, 0xF8, 0x67, 0xFF, 0xE2, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 6
  0xFF, 0xF8, 0x4F, 0xFF, 0xFA, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 7
  0xFF, 0xFA, 0x1F, 0xFF, 0xFC, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 8
  0xFF, 0xF8, 0x3F, 0xFF, 0xBC, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 9
  0xFF, 0xF8, 0x3B, 0xFF, 0x99, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 10
  0xFF, 0xFD, 0xF9, 0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 11
  0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 12
  0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 13
  0xFF, 0xFF, 0xFE, 0x07, 0x80, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 14
  0xFF, 0xFF, 0xF9, 0xF3, 0x23, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 15
  0xFF, 0xFF, 0xF3, 0xC0, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 16
  0xFF, 0xBB, 0xE6, 0x00, 0x1C, 0x2D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 17
  0xFF, 0x73, 0x98, 0x1C, 0x3F, 0xCD, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x1F, 0xFF, 0xE0, 0x1F, 0xFF,  // 18
  0xFF, 0x71, 0x30, 0xFC, 0x41, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x07, 0xFF, 0x80, 0x07, 0xFF,  // 19
  0xFF, 0x70, 0x03, 0xC0, 0x60, 0x1D, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x07, 0xFE, 0x00, 0x07, 0xFF,  // 20
  0xFE, 0x70, 0x07, 0x0C, 0x1F, 0xBD, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x07, 0xFC, 0x00, 0x07, 0xFF,  // 21
  0xFE, 0x73, 0x3E, 0x3C, 0xC0, 0x3D, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x07, 0xF8, 0x00, 0x07, 0xFF,  // 22
  0xFE, 0x78, 0xF8, 0x79, 0xE0, 0xFB, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xC7, 0xF0, 0x0F, 0xC7, 0xFF,  // 23
  0xFE, 0x78, 0x01, 0xF1, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF,  // 24
  0xFE, 0x7C, 0x0F, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF,  // 25
  0xFF, 0x3F, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x7F, 0xFF, 0xE0, 0x7F, 0xFF, 0xFF,  // 26
  0xFF, 0x3F, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xFF,  // 27
  0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xFF, 0xFF, 0xC0, 0xFF, 0xFF, 0xFF,  // 28
  0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xE0, 0x3F, 0xC0, 0xE0, 0x3F, 0xFF,  // 29
  0xFF, 0xC7, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x0F, 0xC0, 0x00, 0x0F, 0xFF,  // 30
  0xFF, 0xF3, 0xF9, 0xFF, 0xE7, 0x87, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x07, 0xC0, 0x00, 0x07, 0xFF,  // 31
  0xFF, 0xF8, 0xF8, 0x3F, 0xC7, 0x87, 0xFF, 0xFF, 0xEF, 0xC0, 0x00, 0x03, 0xC0, 0x00, 0x03, 0xFF,  // 32
  0xFF, 0xFF, 0xFC, 0x07, 0x07, 0xB7, 0xFF, 0xFF, 0xEF, 0xC0, 0x00, 0x03, 0xC0, 0x00, 0x03, 0xFF,  // 33
  0xFF, 0xFF, 0xFC, 0x00, 0x07, 0xB7, 0xFF, 0xFF, 0x83, 0xC0, 0x3E, 0x01, 0xC0, 0x3E, 0x01, 0xFF,  // 34
  0xFF, 0xFF, 0xFC, 0x00, 0x07, 0x37, 0xFF, 0xFF, 0x39, 0xC0, 0xFF, 0x01, 0xC0, 0xFF, 0x01, 0xFF,  // 35
  0xFF, 0xFF, 0xFC, 0x00, 0x07, 0x77, 0xFF, 0xFE, 0x7F, 0xC0, 0xFF, 0x81, 0xC0, 0xFF, 0x81, 0xFF,  // 36
  0xFF, 0xFF, 0xFE, 0x01, 0x07, 0x77, 0xFF, 0xFE, 0x7F, 0xC0, 0xFF, 0x81, 0xC0, 0xFF, 0x81, 0xFF,  // 37
  0xFF, 0xFF, 0xFE, 0x03, 0xE4, 0x76, 0x1F, 0xFE, 0x7F, 0xC0, 0xFF, 0x81, 0xC0, 0xFF, 0x81, 0xFF,  // 38
  0xFF, 0xFF, 0xFE, 0x0F, 0xE0, 0x70, 0x9F, 0xFF, 0x1F, 0xC0, 0xFF, 0x81, 0xC0, 0xFF, 0x81, 0xFF,  // 39
  0xFF, 0x87, 0xFE, 0x1F, 0xCF, 0x73, 0xC0, 0x7F, 0x83, 0xC0, 0xFF, 0x81, 0xC0, 0xFF, 0x81, 0xFF,  // 40
  0xFE, 0x03, 0xF8, 0x30, 0x1F, 0x73, 0xE7, 0x3F, 0xF1, 0xE0, 0x7F, 0x01, 0xE0, 0x7F, 0x01, 0xFF,  // 41
  0xFC, 0x79, 0xF3, 0x87, 0x1F, 0x77, 0xEF, 0x3F, 0xF9, 0xE0, 0x7F, 0x03, 0xE0, 0x7F, 0x03, 0xFF,  // 42
  0xF9, 0xFC, 0xF3, 0x9F, 0x3F, 0x66, 0xEF, 0x7F, 0xFD, 0xE0, 0x3E, 0x03, 0xE0, 0x3E, 0x03, 0xFF,  // 43
  0xF3, 0xFE, 0xF3, 0xBF, 0xB7, 0x66, 0xFC, 0x7F, 0xF9, 0xF0, 0x00, 0x07, 0xF0, 0x00, 0x07, 0xFF,  // 44
  0xE7, 0xFE, 0x70, 0x3F, 0xB7, 0x6E, 0xF8, 0xFE, 0xF9, 0xF0, 0x00, 0x07, 0xF0, 0x00, 0x07, 0xFF,  // 45
  0xEF, 0x8F, 0x61, 0x9F, 0xB7, 0x6F, 0xD9, 0xFF, 0x07, 0xF8, 0x00, 0x0F, 0xF8, 0x00, 0x0F, 0xFF,  // 46
  0xCF, 0x8F, 0x09, 0x99, 0xB7, 0x6F, 0x9D, 0xFF, 0xDF, 0xFC, 0x00, 0x3F, 0xFC, 0x00, 0x3F, 0xFF,  // 47
  0x8F, 0x87, 0x0D, 0xD9, 0xF7, 0x6F, 0x1D, 0xFF, 0xDF, 0xFF, 0x80, 0xFF, 0xFF, 0x80, 0xFF, 0xFF,  // 48
  0x8F, 0xC7, 0xFD, 0xD9, 0xF7, 0x6E, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 49
  0xCF, 0xC7, 0xF9, 0xDD, 0xF7, 0x6E, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 50
  0xC1, 0xE7, 0xF9, 0xDD, 0xFF, 0x6F, 0x0D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 51
  0xE1, 0xE3, 0xF9, 0xDD, 0x9F, 0xEF, 0xBD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 52
  0xE1, 0xE7, 0xB8, 0xDD, 0x9F, 0x67, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 53
  0xF0, 0xE7, 0x38, 0xDD, 0xCF, 0x00, 0x7B, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF,  // 54
  0xFC, 0xF7, 0x38, 0xED, 0x87, 0x00, 0x63, 0xFC, 0xF1, 0xE3, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF,  // 55
  0xFC, 0xFF, 0x38, 0xEC, 0x06, 0x7E, 0x07, 0xFE, 0xEE, 0xDD, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF,  // 56
  0xFC, 0x7F, 0x1C, 0xFC, 0x0E, 0xFF, 0x9F, 0xFE, 0xFE, 0xDD, 0xC3, 0xEF, 0x9F, 0x87, 0x8E, 0x3F,  // 57
  0xFE, 0x7E, 0x1C, 0xE0, 0xDE, 0xFF, 0xFF, 0xFE, 0xF1, 0xDD, 0xB7, 0xDF, 0xDF, 0xBB, 0x7D, 0xFF,  // 58
  0xFE, 0x7E, 0x9C, 0x43, 0xDC, 0xFF, 0xFF, 0xFE, 0xFE, 0xDD, 0xB7, 0xDF, 0xDF, 0xBB, 0x7C, 0xFF,  // 59
  0xFE, 0x3C, 0x9C, 0x0F, 0x89, 0xFF, 0xFF, 0xFE, 0xFE, 0xDD, 0xCF, 0xDF, 0xDF, 0xBB, 0x7F, 0x3F,  // 60
  0xFF, 0x3D, 0xCE, 0x1F, 0x81, 0xFF, 0xFF, 0xFE, 0xEE, 0xDD, 0xBF, 0xBF, 0xDF, 0xBB, 0x7F, 0xBF,  // 61
  0xFF, 0x1C, 0xCC, 0x7F, 0xC7, 0xFF, 0xFF, 0xFC, 0x71, 0xE3, 0xC7, 0xBF, 0xDF, 0x87, 0x8C, 0x7F,  // 62
  0xFF, 0x1E, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBB, 0x7F, 0x8F, 0xBF, 0xFF, 0xFF,  // 63
  0xFF, 0x9E, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0x7F, 0xFF, 0xBF, 0xFF, 0xFF,  // 64
  0xFF, 0x8E, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 65
  0xFF, 0xCF, 0x6F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 66
  0xFF, 0xCF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 67
  0xFF, 0xC7, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 68
  0xFF, 0xE6, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 69
  0xFF, 0xE0, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 70
  0xFF, 0xE1, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 71
  0xFF, 0xF3, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 72
  0xFF, 0xF3, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 73
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 74
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 75
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 76
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 77
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 78
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 79
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 80
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 81
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 82
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 83
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 84
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 85
  0xFF, 0xFF, 0xFC, 0xB1, 0xA6, 0x37, 0x4E, 0x3A, 0x4F, 0x59, 0x09, 0x61, 0xA7, 0x14, 0xFF, 0xFF,  // 86
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 87
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xC7, 0x1F, 0x70, 0xC6, 0x0C, 0x71, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,  // 88
  0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xBA, 0xEE, 0x77, 0xBB, 0xDB, 0xAE, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF,  // 89
  0xFF, 0xFF, 0xFF, 0xFF, 0xEB, 0xFB, 0xED, 0x6F, 0xBF, 0xDB, 0xAE, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF,  // 90
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFB, 0x9D, 0x61, 0x87, 0xBC, 0x6E, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF,  // 91
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xF7, 0xEB, 0x7E, 0xBB, 0xBB, 0xB0, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF,  // 92
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xEF, 0xE8, 0x3E, 0xBB, 0x7B, 0xBE, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF,  // 93
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xDE, 0xEF, 0x6E, 0xBB, 0x7B, 0xAE, 0xBB, 0xFF, 0xFF, 0xFF, 0xFF,  // 94
  0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0x83, 0x1F, 0x71, 0xC7, 0x7C, 0x71, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,  // 95
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF   // 96
};
//2013/04/03 Resolution: 128 x 96


#elif (USE_EPD_Type==USE_EPD200)

#define image_width_200 200 /**< the resolution of 2 inch is 200*96 */
#define image_height_200 96 /**< the image array size of 2 inch is 96*25 where 25=200/8 */
uint8_t const image_array_200_1[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xfe,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,
0x60,0x00,0x00,0x7f,0xff,0x80,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x3f,
0xff,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0xf0,0x00,0x00,0xff,0xff,0xc0,0x00,
0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x01,0xe0,0x00,0x00,
0x00,0x00,0xf0,0x00,0x00,0x7f,0xff,0x80,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,
0x00,0x3c,0x0f,0xc0,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0xf0,0x00,0x00,0x01,0xe0,
0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x00,0x3c,0x07,0xc0,0x00,0x01,0xe0,
0x00,0x00,0x00,0x00,0xf0,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,
0x00,0x00,0x00,0x3c,0x03,0xc0,0x00,0x01,0xe0,0x00,0x00,0x00,0x00,0xf0,0x00,0x00,
0x01,0xe0,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x00,0x3c,0x03,0xc0,0x7e,
0x07,0xfc,0x67,0xc0,0x7e,0x00,0xf0,0x63,0xe0,0x01,0xe0,0x06,0x7c,0x0f,0xe0,0x07,
0xcf,0x00,0xfc,0x00,0x00,0x3c,0x03,0xc1,0xff,0x87,0xfc,0xff,0xe1,0xff,0x80,0xf0,
0xf7,0xf8,0x01,0xe0,0x0f,0xfe,0x3f,0xf8,0x1f,0xef,0x03,0xff,0x00,0x00,0x3c,0x07,
0xc3,0xff,0xc7,0xfc,0xff,0xe3,0xff,0xc0,0xf0,0xff,0xf8,0x01,0xe0,0x0f,0xfe,0x7f,
0xf8,0x3f,0xff,0x07,0xff,0x80,0x00,0x3c,0x0f,0x87,0x83,0xc1,0xe0,0xf8,0x47,0xc3,
0xe0,0xf0,0xfc,0x7c,0x01,0xe0,0x0f,0x84,0x78,0x7c,0x3e,0x3f,0x0f,0x07,0x80,0x00,
0x3f,0xff,0x8f,0x01,0xe1,0xe0,0xf8,0x07,0x81,0xe0,0xf0,0xf8,0x3c,0x01,0xe0,0x0f,
0x80,0x70,0x3c,0x7c,0x1f,0x1e,0x03,0xc0,0x00,0x3f,0xff,0x0f,0x01,0xe1,0xe0,0xf0,
0x0f,0x00,0xf0,0xf0,0xf0,0x3c,0x01,0xe0,0x0f,0x00,0x00,0x7c,0x78,0x1f,0x1e,0x03,
0xc0,0x00,0x3f,0xfc,0x0f,0xff,0xe1,0xe0,0xf0,0x0f,0x00,0xf0,0xf0,0xf0,0x3c,0x01,
0xe0,0x0f,0x00,0x07,0xfc,0x78,0x0f,0x1f,0xff,0xc0,0x00,0x3c,0x00,0x0f,0xff,0xc1,
0xe0,0xf0,0x0f,0x00,0xf0,0xf0,0xf0,0x3c,0x01,0xe0,0x0f,0x00,0x3f,0xfc,0x78,0x0f,
0x1f,0xff,0x80,0x00,0x3c,0x00,0x0f,0x00,0x01,0xe0,0xf0,0x0f,0x00,0xf0,0xf0,0xf0,
0x3c,0x01,0xe0,0x0f,0x00,0x7f,0x3c,0x78,0x0f,0x1e,0x00,0x00,0x00,0x3c,0x00,0x0f,
0x00,0x41,0xe0,0xf0,0x0f,0x00,0xf0,0xf0,0xf0,0x3c,0x01,0xe0,0x0f,0x00,0xf0,0x3c,
0x78,0x0f,0x1e,0x00,0x80,0x00,0x3c,0x00,0x0f,0x81,0xe1,0xe0,0xf0,0x07,0x81,0xe0,
0xf0,0xf0,0x3c,0x01,0xe0,0x0f,0x00,0xf0,0x3c,0x7c,0x1f,0x1f,0x03,0xc0,0x00,0x3c,
0x00,0x07,0xc3,0xc1,0xe0,0xf0,0x07,0xc3,0xe0,0xf0,0xf0,0x3c,0x01,0xe0,0x0f,0x00,
0xf8,0xfc,0x3e,0x3f,0x0f,0x87,0x80,0x00,0x3c,0x00,0x03,0xff,0xc1,0xfe,0xf0,0x03,
0xff,0xc0,0xf0,0xf0,0x3c,0x01,0xe0,0x0f,0x00,0xff,0xfe,0x3f,0xff,0x07,0xff,0x80,
0x00,0x3c,0x00,0x01,0xff,0x80,0xfe,0xf0,0x01,0xff,0x80,0xf0,0xf0,0x3c,0x01,0xe0,
0x0f,0x00,0x7f,0x9e,0x1f,0xef,0x03,0xff,0x00,0x00,0x18,0x00,0x00,0x7e,0x00,0x7c,
0x60,0x00,0x7e,0x00,0x60,0x60,0x18,0x00,0xc0,0x06,0x00,0x3e,0x0c,0x07,0x86,0x00,
0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x3e,0x00,
0x03,0x00,0x3f,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x01,0xff,0x80,0xff,0x80,0x07,0x80,0x7f,0xf8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0xc1,
0xff,0xc0,0x07,0x80,0x7f,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xc3,0xc3,0xe3,0xe0,0x0f,0x80,0x70,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,
0x81,0xe3,0xc1,0xe0,0x3f,0x80,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x81,0xe3,0xc0,0xe0,0x7f,0x80,0x70,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x07,0x01,0xe7,0x80,0xf1,0xf7,0x80,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x01,0xe7,0x80,0xf1,0xe7,
0x80,0xf7,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0xe7,0x80,0xf1,0xc7,0x80,0xff,0xf0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xc7,0x80,
0xf0,0x07,0x80,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x87,0x80,0xf0,0x07,0x80,0xf0,0xf8,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,
0x87,0x80,0xf0,0x07,0x80,0xe0,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x07,0x80,0xf0,0x07,0x80,0x00,0x3c,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x7c,0x07,0x80,0xf0,0x07,0x80,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0x80,0xf0,0x07,0x80,
0xc0,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0xf0,0x03,0xc1,0xe0,0x07,0x81,0xe0,0x3c,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xe0,0x03,0xc1,0xe0,
0x07,0x81,0xe0,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x07,0xc0,0x03,0xe3,0xe0,0x07,0x80,0xf0,0xf8,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0xe1,
0xff,0xc0,0x07,0x80,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0xe0,0xff,0x80,0x07,0x80,0x7f,0xe0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,
0xff,0xe0,0x3e,0x00,0x03,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
//2013/04/03 Resolution: 200 x 96

uint8_t const image_array_200_2[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0xff,0x80,0x00,0x60,0x70,0x01,0x81,0x80,0x1c,
0x00,0x00,0x06,0x06,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x3f,
0xff,0x80,0x00,0xf0,0xf8,0x03,0xc3,0xc0,0x3c,0x00,0x00,0x0f,0x0f,0x00,0x00,0x00,
0x00,0x03,0xc0,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0xf0,0xfc,0x03,0xc3,
0xc0,0x7c,0x00,0x00,0x0f,0x0f,0x00,0x00,0x00,0x00,0x03,0xc0,0x00,0x00,0x00,0x00,
0x00,0x3c,0x00,0x00,0x00,0xf0,0xfc,0x03,0xc3,0xc0,0xfc,0x00,0x00,0x0f,0x06,0x00,
0x00,0x00,0x00,0x03,0xc0,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0xf0,0xfe,
0x03,0xc3,0xc1,0xf0,0x00,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,0x03,0xc0,0x00,0x00,
0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0xf0,0xff,0x03,0xc3,0xc3,0xe0,0x00,0x00,0x0f,
0x00,0x00,0x00,0x00,0x00,0x03,0xc0,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,
0xf0,0xff,0x03,0xc3,0xc7,0xc0,0x00,0x07,0xcf,0x06,0x03,0xf8,0x06,0x3e,0x03,0xc0,
0x7f,0x01,0x80,0x70,0x00,0x3c,0x00,0x00,0x00,0xf0,0xff,0x83,0xc3,0xcf,0x80,0x00,
0x1f,0xef,0x0f,0x0f,0xfe,0x0f,0x7f,0x83,0xc1,0xff,0xc3,0xc0,0x70,0x00,0x3c,0x00,
0x00,0x00,0xf0,0xf7,0xc3,0xc3,0xdf,0x00,0x00,0x3f,0xff,0x0f,0x1f,0xff,0x0f,0xff,
0xc3,0xc3,0xff,0xc3,0xc0,0xf0,0x00,0x3f,0xff,0x00,0x00,0xf0,0xf3,0xc3,0xc3,0xff,
0x80,0x00,0x3e,0x3f,0x0f,0x1f,0x0f,0x0f,0xc7,0xc3,0xc3,0xc3,0xe1,0xc0,0xe0,0x00,
0x3f,0xff,0x80,0x00,0xf0,0xf3,0xe3,0xc3,0xff,0xc0,0x00,0x7c,0x1f,0x0f,0x1e,0x07,
0x0f,0x83,0xe3,0xc3,0x81,0xe1,0xe1,0xe0,0x00,0x3f,0xff,0x00,0x00,0xf0,0xf1,0xf3,
0xc3,0xfb,0xe0,0x00,0x78,0x1f,0x0f,0x1f,0x02,0x0f,0x01,0xe3,0xc0,0x03,0xe1,0xe1,
0xe0,0x00,0x3c,0x00,0x1f,0xf0,0xf0,0xf0,0xf3,0xc3,0xf3,0xe0,0x00,0x78,0x0f,0x0f,
0x0f,0xf8,0x0f,0x01,0xe3,0xc0,0x3f,0xe0,0xe1,0xc0,0x00,0x3c,0x00,0x1f,0xf0,0xf0,
0xf0,0x7b,0xc3,0xe1,0xf0,0x00,0x78,0x0f,0x0f,0x03,0xfe,0x0f,0x01,0xe3,0xc1,0xff,
0xe0,0xf3,0xc0,0x00,0x3c,0x00,0x1f,0xf0,0xf0,0xf0,0x7f,0xc3,0xc0,0xf8,0x00,0x78,
0x0f,0x0f,0x00,0x7f,0x8f,0x01,0xe3,0xc3,0xf9,0xe0,0x73,0xc0,0x00,0x3c,0x00,0x00,
0x00,0xf0,0xf0,0x3f,0xc3,0xc0,0xf8,0x00,0x78,0x0f,0x0f,0x0c,0x0f,0x8f,0x01,0xe3,
0xc7,0x81,0xe0,0x7b,0x80,0x00,0x3c,0x00,0x00,0x00,0xf0,0xf0,0x1f,0xc3,0xc0,0x7c,
0x00,0x7c,0x1f,0x0f,0x1e,0x07,0x8f,0x83,0xe3,0xc7,0x81,0xe0,0x7f,0x80,0x00,0x3c,
0x00,0x00,0x00,0xf0,0xf0,0x1f,0xc3,0xc0,0x3e,0x00,0x3e,0x3f,0x0f,0x1f,0x0f,0x8f,
0xc7,0xc3,0xc7,0xc7,0xe0,0x3f,0x00,0x00,0x3f,0xff,0x80,0x00,0xf0,0xf0,0x0f,0xc3,
0xc0,0x3e,0x00,0x3f,0xff,0x0f,0x1f,0xff,0x0f,0xff,0xc3,0xc7,0xff,0xf0,0x3f,0x00,
0x00,0x3f,0xff,0xc0,0x00,0xf0,0xf0,0x07,0xc3,0xc0,0x1e,0x00,0x1f,0xef,0x0f,0x0f,
0xfe,0x0f,0x7f,0x83,0xc3,0xfc,0xf0,0x1f,0x00,0x00,0x1f,0xff,0x80,0x00,0x60,0x60,
0x03,0x81,0x80,0x0e,0x00,0x07,0x86,0x06,0x03,0xf8,0x0f,0x3e,0x01,0x81,0xf0,0x60,
0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,
0x00,0x00,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,
0x00,0x00,0x00,0x03,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x00,0x03,0xf8,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x06,0x00,0x00,0x00,0x00,0x03,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x3f,0x01,0xe7,0x80,0x00,0xfc,0x00,0x7c,0x00,0x3e,0x00,0x00,
0x00,0x7e,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xc1,0xe7,
0x80,0x03,0xff,0x01,0xff,0x00,0xff,0x80,0x00,0x00,0xff,0x80,0x7f,0xe0,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0xff,0xe1,0xe7,0x80,0x07,0xff,0x83,0xff,0x81,0xff,
0xc0,0x00,0x01,0xff,0xc0,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xe1,
0xe1,0xe7,0x80,0x0f,0x87,0x87,0xc7,0xc3,0xe3,0xe0,0x00,0x03,0xe3,0xe0,0xf0,0xf0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xc0,0xf1,0xe7,0x80,0x0f,0x03,0xc7,0x83,
0xc3,0xc1,0xe0,0x00,0x07,0xc1,0xe1,0xe0,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x03,0xc0,0xf1,0xe7,0x80,0x0f,0x03,0xc7,0x81,0xc3,0xc0,0xe0,0x00,0x07,0x80,0xe1,
0xc0,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0xf1,0xe7,0x80,0x0e,0x03,
0xcf,0x01,0xe7,0x80,0xf1,0x80,0xc7,0x80,0xf3,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x03,0x00,0xf0,0xc3,0x00,0x0c,0x03,0xcf,0x01,0xe7,0x80,0xf3,0xc1,0xe7,
0x80,0xf3,0xcf,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xf0,0x00,0x00,
0x00,0x07,0xcf,0x01,0xe7,0x80,0xf1,0xe3,0xc7,0x80,0xf3,0xdf,0xe0,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x01,0xe0,0x00,0x00,0x00,0x07,0x8f,0x01,0xe7,0x80,0xf1,
0xe3,0xc7,0xc1,0xf3,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xc0,
0x00,0x00,0x00,0x0f,0x0f,0x01,0xe7,0x80,0xf0,0xf7,0x83,0xe3,0xf3,0xf1,0xf0,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0xc0,0x00,0x00,0x00,0x3f,0x0f,0x01,0xe7,
0x80,0xf0,0x7f,0x03,0xff,0xf3,0xe0,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x1f,0x00,0x00,0x00,0x00,0x7c,0x0f,0x01,0xe7,0x80,0xf0,0x7f,0x01,0xfe,0xf3,0xc0,
0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x00,0xf8,0x0f,
0x01,0xe7,0x80,0xf0,0x3e,0x00,0x7c,0xf3,0xc0,0x78,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x7c,0x00,0x00,0x00,0x01,0xf0,0x0f,0x01,0xe7,0x80,0xf0,0x7f,0x00,0x00,
0xf3,0xc0,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x00,0x00,0x00,0x03,
0xe0,0x07,0x83,0xc3,0xc1,0xe0,0x7f,0x01,0x00,0xe1,0xc0,0x78,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0xf0,0x00,0x00,0x00,0x07,0xc0,0x07,0x83,0xc3,0xc1,0xe0,0xf7,
0x83,0x81,0xe1,0xe0,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xe0,0x00,0x00,
0x00,0x0f,0x80,0x07,0xc7,0xc3,0xe3,0xe1,0xe3,0xc3,0xc3,0xc1,0xf1,0xf0,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x03,0xff,0xf0,0x00,0x00,0x0f,0xff,0xc3,0xff,0x81,0xff,
0xc3,0xe3,0xe3,0xff,0xc0,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xff,
0xf0,0x00,0x00,0x0f,0xff,0xc1,0xff,0x00,0xff,0x83,0xc1,0xe1,0xff,0x80,0x7f,0xc0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0xf0,0x00,0x00,0x0f,0xff,0xc0,0x7c,
0x00,0x3e,0x03,0x80,0xe0,0x7e,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
//2013/04/03 Resolution: 200 x 96


#elif (USE_EPD_Type==USE_EPD270)

#define image_width_270 264 /**< The resolution of 2 inch is 264*176 */
#define image_height_270 176 /**< the image array size of 2.7 inch is 176*33 where 33=264/8 */
uint8_t const image_array_270_1[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 1
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 2
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 3
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 4
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 5
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 6
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 7
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 8
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x1E, 0x7E, 0x07, 0x80, 0x01, 0xFF,  // 9
  0xFF, 0xFF, 0xFF, 0xE0, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x1E, 0x7E, 0x07, 0x80, 0x01, 0xFF,  // 10
  0xFF, 0xFF, 0xFF, 0xC0, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x98, 0x61, 0xF9, 0x9F, 0xF9, 0xFF,  // 11
  0xFF, 0xFF, 0xFF, 0x80, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x98, 0x61, 0xF9, 0x9F, 0xF9, 0xFF,  // 12
  0xFF, 0xFF, 0xFF, 0x80, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x9E, 0x07, 0x9F, 0x98, 0x19, 0xFF,  // 13
  0xFF, 0xFF, 0xFF, 0x00, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x9E, 0x07, 0x9F, 0x98, 0x19, 0xFF,  // 14
  0xFF, 0xFF, 0xFE, 0x00, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x98, 0x67, 0x99, 0x98, 0x19, 0xFF,  // 15
  0xFF, 0xFF, 0xFC, 0x00, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x98, 0x67, 0x99, 0x98, 0x19, 0xFF,  // 16
  0xFF, 0xFF, 0xF8, 0x10, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x9F, 0x98, 0x01, 0x98, 0x19, 0xFF,  // 17
  0xFF, 0xFF, 0xF0, 0x30, 0xFC, 0x1F, 0xFF, 0xF8, 0xFF, 0xE3, 0xFF, 0xFF, 0xC1, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x9F, 0x98, 0x01, 0x98, 0x19, 0xFF,  // 18
  0xFF, 0xFF, 0xE0, 0x70, 0xF0, 0x00, 0x3F, 0xC0, 0x1F, 0x00, 0x7F, 0xFE, 0x00, 0x3F, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x99, 0x9F, 0xE7, 0x9F, 0xF9, 0xFF,  // 19
  0xFF, 0xFF, 0xE0, 0xF0, 0xF0, 0x00, 0x3F, 0x00, 0x0E, 0x00, 0x1F, 0xF8, 0x00, 0x0F, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x99, 0x9F, 0xE7, 0x9F, 0xF9, 0xFF,  // 20
  0xFF, 0xFF, 0xC1, 0xF0, 0xF0, 0x00, 0x3F, 0x00, 0x04, 0x00, 0x0F, 0xF0, 0x00, 0x07, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x19, 0x99, 0x99, 0x80, 0x01, 0xFF,  // 21
  0xFF, 0xFF, 0x83, 0xF0, 0xF0, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x08, 0x03, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x19, 0x99, 0x99, 0x80, 0x01, 0xFF,  // 22
  0xFF, 0xFF, 0x03, 0xF0, 0xFC, 0x1F, 0xFC, 0x07, 0x00, 0x1C, 0x07, 0xE0, 0x7F, 0x03, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x9F, 0xFF, 0xFF, 0xFF,  // 23
  0xFF, 0xFE, 0x07, 0xF0, 0xFC, 0x1F, 0xFC, 0x1F, 0xC0, 0x7F, 0x03, 0xC0, 0xFF, 0x81, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x9F, 0xFF, 0xFF, 0xFF,  // 24
  0xFF, 0xFC, 0x0F, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0x7F, 0x83, 0xC1, 0xFF, 0xC1, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0x80, 0x19, 0xF8, 0x66, 0x67, 0xFF,  // 25
  0xFF, 0xF8, 0x1F, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0x83, 0x81, 0xFF, 0xC1, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0x80, 0x19, 0xF8, 0x66, 0x67, 0xFF,  // 26
  0xFF, 0xF0, 0x00, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0x83, 0x80, 0x00, 0x01, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xE6, 0x7E, 0x60, 0x07, 0x9F, 0xFF,  // 27
  0xFF, 0xF0, 0x00, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0x80, 0x00, 0x00, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xE6, 0x7E, 0x60, 0x07, 0x9F, 0xFF,  // 28
  0xFF, 0xE0, 0x00, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0x80, 0x00, 0x00, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE6, 0x18, 0x61, 0xE7, 0xF9, 0xE1, 0xFF,  // 29
  0xFF, 0xC0, 0x00, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0x80, 0x00, 0x00, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE6, 0x18, 0x61, 0xE7, 0xF9, 0xE1, 0xFF,  // 30
  0xFF, 0x80, 0x00, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0x80, 0x07, 0xCE, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0xF8, 0x07, 0xE6, 0x01, 0xF9, 0xFF,  // 31
  0xFF, 0x03, 0xFF, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0x83, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x01, 0xF8, 0x07, 0xE6, 0x01, 0xF9, 0xFF,  // 32
  0xFE, 0x07, 0xFF, 0xF0, 0xFC, 0x1F, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0xC1, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE6, 0x00, 0x67, 0xF8, 0x7E, 0x01, 0xFF,  // 33
  0xFE, 0x0F, 0xFF, 0xF0, 0xFE, 0x0F, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0xC1, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE6, 0x00, 0x67, 0xF8, 0x7E, 0x01, 0xFF,  // 34
  0xFC, 0x1F, 0xFF, 0xF0, 0xFE, 0x07, 0xF8, 0x3F, 0xE0, 0xFF, 0xC3, 0xC0, 0xFF, 0xC1, 0xE0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x9E, 0x61, 0x99, 0x86, 0x19, 0xE7, 0xFF,  // 35
  0xF8, 0x3F, 0xFF, 0xF0, 0xFF, 0x00, 0x38, 0x3F, 0xE0, 0xFF, 0xC3, 0xE0, 0x7F, 0x03, 0xF0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x9E, 0x61, 0x99, 0x86, 0x19, 0xE7, 0xFF,  // 36
  0xF0, 0x3F, 0xFF, 0xF0, 0xFF, 0x00, 0x38, 0x3F, 0xE0, 0xFF, 0xC3, 0xF0, 0x00, 0x03, 0xF8, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xE1, 0x9E, 0x7F, 0x80, 0x19, 0xE1, 0xFF,  // 37
  0xE0, 0x7F, 0xFF, 0xF0, 0xFF, 0x80, 0x38, 0x3F, 0xE0, 0xFF, 0xC3, 0xF0, 0x00, 0x07, 0xFC, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xE1, 0x9E, 0x7F, 0x80, 0x19, 0xE1, 0xFF,  // 38
  0xC0, 0xFF, 0xFF, 0xF0, 0xFF, 0xE0, 0x38, 0x3F, 0xE0, 0xFF, 0xC3, 0xFC, 0x00, 0x1F, 0xFE, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x87, 0xF8, 0x19, 0xFE, 0x1F, 0xE1, 0xFF,  // 39
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x87, 0xF8, 0x19, 0xFE, 0x1F, 0xE1, 0xFF,  // 40
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFE, 0x19, 0x99, 0xF8, 0x00, 0x19, 0xFF,  // 41
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFE, 0x19, 0x99, 0xF8, 0x00, 0x19, 0xFF,  // 42
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x1E, 0x19, 0xF9, 0x99, 0xFF,  // 43
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x1E, 0x19, 0xF9, 0x99, 0xFF,  // 44
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x19, 0x81, 0x81, 0x98, 0x61, 0xFF,  // 45
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x19, 0x81, 0x81, 0x98, 0x61, 0xFF,  // 46
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x9E, 0x06, 0x61, 0xF8, 0x61, 0xFF,  // 47
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x9E, 0x06, 0x61, 0xF8, 0x61, 0xFF,  // 48
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x1F, 0xFF, 0x80, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x98, 0x61, 0xE0, 0x00, 0x01, 0xFF,  // 49
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x0F, 0xFF, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x98, 0x61, 0xE0, 0x00, 0x01, 0xFF,  // 50
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0xFE, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x98, 0x18, 0x07, 0x98, 0x79, 0xFF,  // 51
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0xFE, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x98, 0x18, 0x07, 0x98, 0x79, 0xFF,  // 52
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x03, 0xFC, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x99, 0xF8, 0x79, 0x86, 0x79, 0xFF,  // 53
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x01, 0xF8, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0x81, 0x99, 0xF8, 0x79, 0x86, 0x79, 0xFF,  // 54
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x01, 0xF8, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x99, 0x98, 0x1F, 0x98, 0x79, 0xFF,  // 55
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0xF0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0x99, 0x98, 0x1F, 0x98, 0x79, 0xFF,  // 56
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0xE0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x18, 0x19, 0x99, 0xE7, 0x81, 0xFF,  // 57
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x60, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x18, 0x19, 0x99, 0xE7, 0x81, 0xFF,  // 58
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 59
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 60
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 61
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 62
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 63
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 64
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 65
  0xE0, 0x01, 0xE0, 0x03, 0xF8, 0x00, 0xFF, 0xFF, 0xFF, 0xF0, 0x01, 0xFF, 0xFC, 0x00, 0x7F, 0x07, 0xFF, 0xF0, 0x7F, 0x80, 0x0E, 0x07, 0xE1, 0xE0, 0x01, 0xE0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 66
  0xE0, 0x01, 0xE0, 0x00, 0xF8, 0x00, 0x3F, 0xFF, 0xFF, 0xE0, 0x00, 0xFF, 0xFC, 0x00, 0x1F, 0x07, 0xFF, 0xE0, 0x3F, 0x80, 0x0E, 0x07, 0xE1, 0xE0, 0x01, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 67
  0xE0, 0x01, 0xE0, 0x00, 0x78, 0x00, 0x1F, 0xFF, 0xFF, 0xE0, 0x00, 0x7F, 0xFC, 0x00, 0x0F, 0x07, 0xFF, 0xE0, 0x3F, 0x80, 0x0E, 0x03, 0xE1, 0xE0, 0x01, 0xE0, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 68
  0xE0, 0xFF, 0xE0, 0xF0, 0x38, 0x3C, 0x0F, 0xFF, 0xFF, 0xC0, 0x00, 0x7F, 0xFC, 0x1E, 0x07, 0x07, 0xFF, 0xC0, 0x1F, 0xF0, 0x7E, 0x01, 0xE1, 0xE0, 0xFF, 0xE0, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 69
  0xE0, 0xFF, 0xE0, 0xF8, 0x38, 0x3F, 0x07, 0xFF, 0xFF, 0x80, 0x00, 0x3F, 0xFC, 0x1F, 0x07, 0x07, 0xFF, 0xC0, 0x1F, 0xF0, 0x7E, 0x01, 0xE1, 0xE0, 0xFF, 0xE0, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 70
  0xE0, 0xFF, 0xE0, 0xF8, 0x38, 0x3F, 0x07, 0xFF, 0xFF, 0x80, 0x00, 0x1F, 0xFC, 0x1F, 0x07, 0x07, 0xFF, 0xC0, 0x1F, 0xF0, 0x7E, 0x00, 0xE1, 0xE0, 0xFF, 0xE0, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 71
  0xE0, 0xFF, 0xE0, 0xF8, 0x38, 0x3F, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x1F, 0xFC, 0x1F, 0x07, 0x07, 0xFF, 0x86, 0x0F, 0xF0, 0x7E, 0x10, 0x61, 0xE0, 0xFF, 0xE0, 0xFE, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 72
  0xE0, 0x03, 0xE0, 0xF8, 0x38, 0x3F, 0x83, 0xFF, 0xFE, 0x00, 0x00, 0x0F, 0xFC, 0x1F, 0x07, 0x07, 0xFF, 0x86, 0x0F, 0xF0, 0x7E, 0x10, 0x61, 0xE0, 0x03, 0xE0, 0xFE, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 73
  0xE0, 0x03, 0xE0, 0xF0, 0x78, 0x3F, 0x83, 0xFF, 0xFE, 0x00, 0xC0, 0x07, 0xFC, 0x1E, 0x0F, 0x07, 0xFF, 0x86, 0x0F, 0xF0, 0x7E, 0x18, 0x21, 0xE0, 0x03, 0xE0, 0xFE, 0x0F, 0xFC, 0x0F, 0x01, 0xFC, 0x3F,  // 74
  0xE0, 0x03, 0xE0, 0x00, 0x78, 0x3F, 0x83, 0xFF, 0xFC, 0x01, 0xE0, 0x07, 0xFC, 0x00, 0x0F, 0x07, 0xFF, 0x0F, 0x07, 0xF0, 0x7E, 0x18, 0x21, 0xE0, 0x03, 0xE0, 0xFE, 0x0F, 0xFC, 0xE7, 0x3C, 0xF3, 0xCF,  // 75
  0xE0, 0xFF, 0xE0, 0x00, 0xF8, 0x3F, 0x83, 0xFF, 0xF8, 0x01, 0xE0, 0x03, 0xFC, 0x00, 0x1F, 0x07, 0xFF, 0x0F, 0x07, 0xF0, 0x7E, 0x1C, 0x01, 0xE0, 0xFF, 0xE0, 0xFE, 0x0F, 0xFC, 0xF3, 0x3E, 0x73, 0xCF,  // 76
  0xE0, 0xFF, 0xE0, 0x03, 0xF8, 0x3F, 0x83, 0xFF, 0xF8, 0x03, 0xF0, 0x01, 0xFC, 0x00, 0x7F, 0x07, 0xFE, 0x00, 0x03, 0xF0, 0x7E, 0x1E, 0x01, 0xE0, 0xFF, 0xE0, 0xFE, 0x0F, 0xFC, 0xF3, 0x3E, 0x67, 0xE7,  // 77
  0xE0, 0xFF, 0xE0, 0xFF, 0xF8, 0x3F, 0x07, 0xFF, 0xF0, 0x07, 0xF8, 0x01, 0xFC, 0x1F, 0xFF, 0x07, 0xFE, 0x00, 0x03, 0xF0, 0x7E, 0x1E, 0x01, 0xE0, 0xFF, 0xE0, 0xFC, 0x1F, 0xFC, 0xF3, 0x3C, 0xE7, 0xE7,  // 78
  0xE0, 0xFF, 0xE0, 0xFF, 0xF8, 0x3F, 0x07, 0xFF, 0xE0, 0x07, 0xF8, 0x00, 0xFC, 0x1F, 0xFF, 0x07, 0xFE, 0x00, 0x03, 0xF0, 0x7E, 0x1F, 0x01, 0xE0, 0xFF, 0xE0, 0xFC, 0x1F, 0xFC, 0xE7, 0x01, 0xE7, 0xE7,  // 79
  0xE0, 0xFF, 0xE0, 0xFF, 0xF8, 0x3C, 0x0F, 0xFF, 0xC0, 0x0F, 0xFC, 0x00, 0x7C, 0x1F, 0xFF, 0x07, 0xFC, 0x1F, 0x81, 0xF0, 0x7E, 0x1F, 0x81, 0xE0, 0xFF, 0xE0, 0xF0, 0x3F, 0xFC, 0x0F, 0x39, 0xE7, 0xE7,  // 80
  0xE0, 0x01, 0xE0, 0xFF, 0xF8, 0x00, 0x1F, 0xFF, 0xC0, 0x1F, 0xFC, 0x00, 0x7C, 0x1F, 0xFF, 0x00, 0x04, 0x3F, 0xC1, 0x80, 0x0E, 0x1F, 0x81, 0xE0, 0x01, 0xE0, 0x00, 0x7F, 0xFC, 0xFF, 0x3C, 0xF3, 0xCF,  // 81
  0xE0, 0x01, 0xE0, 0xFF, 0xF8, 0x00, 0x3F, 0xFF, 0x80, 0x1F, 0xFE, 0x00, 0x3C, 0x1F, 0xFF, 0x00, 0x04, 0x3F, 0xC1, 0x80, 0x0E, 0x1F, 0xC1, 0xE0, 0x01, 0xE0, 0x00, 0xFF, 0xFC, 0xFF, 0x3E, 0x73, 0xCF,  // 82
  0xE0, 0x01, 0xE0, 0xFF, 0xF8, 0x00, 0xFF, 0xFF, 0x00, 0x3F, 0xFF, 0x00, 0x1C, 0x1F, 0xFF, 0x00, 0x00, 0x7F, 0xC0, 0x80, 0x0E, 0x1F, 0xC1, 0xE0, 0x01, 0xE0, 0x03, 0xFF, 0xFC, 0xFF, 0x3F, 0x3C, 0x3F,  // 83
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 84
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 85
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 86
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 87
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 88
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 89
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 90
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 91
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 92
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 93
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 94
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 95
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 96
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 97
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 98
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 99
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 100
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 101
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 102
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 103
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 104
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 105
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 106
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 107
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 108
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 109
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 110
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 111
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 112
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 113
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 114
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 115
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 116
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 117
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 118
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 119
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 120
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 121
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 122
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 123
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 124
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 125
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 126
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 127
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 128
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 129
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 130
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 131
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 132
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 133
  0xFF, 0xFF, 0xFF, 0xE5, 0xBD, 0xCB, 0x88, 0x94, 0xEE, 0x4C, 0xC7, 0x4A, 0xC3, 0x35, 0xED, 0x3D, 0xE5, 0x9E, 0xB4, 0xDE, 0xF6, 0x49, 0x98, 0x89, 0x6C, 0x2E, 0x15, 0x0B, 0x9C, 0x53, 0xFF, 0xFF, 0xFF,  // 134
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 135
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 136
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 137
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 138
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 139
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 140
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 141
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 142
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 143
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 144
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 145
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 146
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 147
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 148
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 149
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 150
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 151
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 152
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7F, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0x8F,  // 153
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x1C, 0x03, 0x80, 0x38, 0x7F, 0x3C, 0xFF, 0x80, 0xE3, 0x0F, 0xF2, 0x00, 0xF8, 0x00, 0xF8, 0xF1, 0x1C, 0x01, 0xC7, 0xFF, 0xCF, 0x1F, 0xCE, 0x63,  // 154
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x0C, 0x03, 0x8E, 0x18, 0x7F, 0x3C, 0x7F, 0x1D, 0xE3, 0x0F, 0xE6, 0x00, 0xF9, 0xFE, 0x78, 0xF7, 0xDC, 0x78, 0xC7, 0xFF, 0xCF, 0x8F, 0xCC, 0xFB,  // 155
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x0C, 0x7F, 0x8F, 0x18, 0x7E, 0x38, 0x7E, 0x3D, 0xE3, 0x87, 0xE6, 0x1F, 0xF9, 0xFF, 0x38, 0xE7, 0xFC, 0x7C, 0xC7, 0xFF, 0xC7, 0xCF, 0xDC, 0xFF,  // 156
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x8C, 0x7F, 0x8F, 0x1C, 0x7E, 0x78, 0x7E, 0x3F, 0xE3, 0x87, 0xE6, 0x1F, 0xF9, 0xFF, 0x18, 0xE7, 0xFC, 0x7C, 0xC7, 0xFF, 0xA7, 0xC7, 0xBC, 0xFF,  // 157
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x8C, 0x7F, 0x8F, 0x1C, 0x3E, 0x70, 0x3E, 0x1F, 0xE3, 0xC3, 0xCE, 0x1F, 0xF9, 0xFF, 0x98, 0xE7, 0xFC, 0x7C, 0xC7, 0xFF, 0xB7, 0xE7, 0xBC, 0xFF,  // 158
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x0C, 0x7F, 0x8E, 0x1E, 0x3C, 0xF2, 0x3E, 0x07, 0xE3, 0xC3, 0xCE, 0x1F, 0xF9, 0xFF, 0x98, 0xF1, 0xFC, 0x78, 0xC7, 0xFF, 0x73, 0xF3, 0x7C, 0x3F,  // 159
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC6, 0x0C, 0x03, 0x8C, 0x3E, 0x1C, 0xE6, 0x1F, 0x03, 0xE3, 0xC3, 0x9E, 0x00, 0xF9, 0xFF, 0x98, 0xF0, 0x7C, 0x71, 0xC7, 0xFF, 0x73, 0xF0, 0x7E, 0x0F,  // 160
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x3C, 0x03, 0x80, 0xFF, 0x19, 0xE6, 0x1F, 0x80, 0xE3, 0xE1, 0x9E, 0x00, 0xF9, 0xFF, 0x98, 0xFC, 0x1C, 0x03, 0xC7, 0xFE, 0x79, 0xF8, 0xFF, 0x83,  // 161
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFC, 0x7F, 0x80, 0x7F, 0x09, 0xE7, 0x1F, 0xC0, 0xE3, 0xE1, 0x9E, 0x1F, 0xF9, 0xFF, 0x98, 0xFF, 0x1C, 0x7F, 0xC7, 0xFE, 0x01, 0xF8, 0xFF, 0xE1,  // 162
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFC, 0x7F, 0x88, 0x7F, 0x09, 0xC0, 0x0F, 0xF0, 0xE3, 0xF0, 0x3E, 0x1F, 0xF9, 0xFF, 0x98, 0xFF, 0x8C, 0x7F, 0xC7, 0xFC, 0xF8, 0xF8, 0xFF, 0xF1,  // 163
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFC, 0x7F, 0x8C, 0x3F, 0x83, 0xCF, 0x8F, 0xF8, 0xE3, 0xF0, 0x3E, 0x1F, 0xF9, 0xFF, 0x18, 0xFF, 0xCC, 0x7F, 0xC7, 0xFD, 0xFC, 0xF8, 0xFF, 0xF9,  // 164
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFC, 0x7F, 0x8E, 0x1F, 0x83, 0x9F, 0x86, 0xF8, 0xE3, 0xF8, 0x7E, 0x1F, 0xF9, 0xFF, 0x38, 0xFF, 0xCC, 0x7F, 0xC7, 0xF9, 0xFC, 0x78, 0xFF, 0xF9,  // 165
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFC, 0x7F, 0x8E, 0x0F, 0x87, 0x9F, 0x86, 0x78, 0xE3, 0xF8, 0x7E, 0x1F, 0xF9, 0xFE, 0x78, 0xEF, 0x9C, 0x7F, 0xC7, 0xFB, 0xFE, 0x78, 0xFD, 0xF3,  // 166
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFC, 0x03, 0x8F, 0x0F, 0xC7, 0x1F, 0xC2, 0x11, 0xE3, 0xF8, 0x7E, 0x00, 0xF9, 0xF8, 0xF8, 0xE7, 0x1C, 0x7F, 0xC0, 0x33, 0xFE, 0x38, 0xF8, 0xE3,  // 167
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFC, 0x03, 0x8F, 0x07, 0xC7, 0x3F, 0xC2, 0x03, 0xE3, 0xFC, 0xFE, 0x00, 0xF8, 0x03, 0xF8, 0xF0, 0x7C, 0x7F, 0xC0, 0x33, 0xFE, 0x38, 0xFC, 0x0F,  // 168
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 169
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 170
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 171
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 172
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 173
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 174
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 175
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF   // 176
};
//2013/04/03 Resolution: 264 x 176

uint8_t const image_array_270_2[] = {
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 1
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 2
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 3
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 4
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 5
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 6
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 7
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 8
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 9
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 10
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 11
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 12
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 13
  0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x18, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 14
  0xFF, 0xFF, 0x80, 0x3F, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x87, 0xFC, 0x3F, 0xFF, 0xFF, 0xFF, 0xE0, 0x7E, 0x18, 0x7F, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 15
  0xFF, 0xFF, 0x00, 0x3F, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x87, 0xFC, 0x3F, 0xFF, 0xC3, 0xFF, 0xE0, 0x7E, 0x18, 0x7F, 0xF0, 0xFF, 0xFF, 0xFF, 0xC0, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 16
  0xFF, 0xFE, 0x00, 0x3F, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x87, 0xFE, 0x7F, 0xFF, 0xC3, 0xFF, 0xC0, 0x7E, 0x18, 0x7F, 0xF0, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 17
  0xFF, 0xFC, 0x1F, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xC0, 0x3E, 0x18, 0x7F, 0xF0, 0xFF, 0xFF, 0xFF, 0x87, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 18
  0xFF, 0xF8, 0x3F, 0xFE, 0x0F, 0x87, 0xE0, 0xFC, 0x67, 0xF0, 0xE3, 0x0F, 0x87, 0x1E, 0x3F, 0x0F, 0xC0, 0xFF, 0xC4, 0x3E, 0x18, 0x7F, 0xF0, 0xE3, 0x0F, 0xFF, 0x07, 0xC1, 0xC6, 0x1F, 0xE1, 0xFF, 0xFF,  // 19
  0xFF, 0xF8, 0x7F, 0xF8, 0x03, 0x87, 0x80, 0x3C, 0x47, 0xF0, 0xE0, 0x07, 0x86, 0x1C, 0x3C, 0x03, 0x00, 0xFF, 0xC4, 0x3E, 0x18, 0x7F, 0xF0, 0xE0, 0x07, 0xFF, 0x0F, 0xE1, 0xC0, 0x0F, 0x80, 0x7F, 0xFF,  // 20
  0xFF, 0xF8, 0x7F, 0xF0, 0x03, 0x87, 0x00, 0x3C, 0x07, 0xF0, 0xE0, 0x03, 0x84, 0x1C, 0x38, 0x01, 0x00, 0xFF, 0x86, 0x3E, 0x18, 0x7F, 0xF0, 0xE0, 0x03, 0xFF, 0x0F, 0xE1, 0xC0, 0x07, 0x00, 0x3F, 0xFF,  // 21
  0xFF, 0xF8, 0x7F, 0xF0, 0xE1, 0x87, 0x0E, 0x1C, 0x07, 0xF0, 0xE0, 0x83, 0x84, 0x3C, 0x38, 0xE1, 0xC3, 0xFF, 0x86, 0x1E, 0x18, 0x7F, 0xF0, 0xE0, 0x83, 0xFF, 0x0F, 0xE1, 0xC1, 0x07, 0x1C, 0x3F, 0xFF,  // 22
  0xFF, 0xF8, 0x7F, 0xE1, 0xF0, 0x86, 0x1F, 0x0C, 0x1F, 0xF0, 0xE1, 0xC3, 0x80, 0x7C, 0x30, 0xF1, 0xC3, 0xFF, 0x8E, 0x1E, 0x18, 0x60, 0x70, 0xE1, 0xC3, 0x03, 0x0F, 0xE1, 0xC3, 0x86, 0x1E, 0x3F, 0xFF,  // 23
  0xFF, 0xF8, 0x7F, 0xE1, 0xF0, 0x86, 0x1F, 0x0C, 0x3F, 0xF0, 0xE1, 0xC3, 0x80, 0x7C, 0x30, 0x00, 0xC3, 0xFF, 0x00, 0x1E, 0x18, 0x60, 0x30, 0xE1, 0xC3, 0x01, 0x0F, 0xE1, 0xC3, 0x86, 0x00, 0x1F, 0xFF,  // 24
  0xFF, 0xF8, 0x7F, 0xE1, 0xF0, 0x86, 0x1F, 0x0C, 0x3F, 0xF0, 0xE1, 0xC3, 0x80, 0x7C, 0x30, 0x00, 0xC3, 0xFF, 0x00, 0x0E, 0x18, 0x60, 0x30, 0xE1, 0xC3, 0x01, 0x0F, 0xE1, 0xC3, 0x86, 0x00, 0x1F, 0xFF,  // 25
  0xFF, 0xF8, 0x3F, 0xE1, 0xF0, 0x86, 0x1F, 0x0C, 0x3F, 0xF0, 0xE1, 0xC3, 0x80, 0x3C, 0x30, 0xFF, 0xC3, 0xFF, 0x00, 0x0E, 0x18, 0x7F, 0xF0, 0xE1, 0xC3, 0xFF, 0x07, 0xC1, 0xC3, 0x86, 0x1F, 0xFF, 0xFF,  // 26
  0xFF, 0xFC, 0x1F, 0xF0, 0xE1, 0x87, 0x0E, 0x1C, 0x3F, 0xF0, 0xE1, 0xC3, 0x84, 0x1C, 0x30, 0xFF, 0xC3, 0xFE, 0x1F, 0x0E, 0x18, 0x7F, 0xF0, 0xE1, 0xC3, 0xFF, 0x83, 0x83, 0xC3, 0x86, 0x1F, 0xFF, 0xFF,  // 27
  0xFF, 0xFE, 0x00, 0x70, 0x01, 0x87, 0x00, 0x1C, 0x3F, 0xF0, 0xE1, 0xC3, 0x86, 0x1C, 0x38, 0x01, 0xC0, 0xFE, 0x1F, 0x06, 0x18, 0x7F, 0xF0, 0xE1, 0xC3, 0xFF, 0xC0, 0x03, 0xC3, 0x87, 0x00, 0x3F, 0xFF,  // 28
  0xFF, 0xFF, 0x00, 0x78, 0x03, 0x87, 0x80, 0x3C, 0x3F, 0xF0, 0xE1, 0xC3, 0x86, 0x0C, 0x3C, 0x01, 0xC0, 0xFE, 0x1F, 0x86, 0x18, 0x7F, 0xF0, 0xE1, 0xC3, 0xFF, 0xC0, 0x07, 0xC3, 0x87, 0x80, 0x3F, 0xFF,  // 29
  0xFF, 0xFF, 0x80, 0x7C, 0x07, 0x87, 0xC0, 0x7C, 0x3F, 0xF0, 0xE1, 0xC3, 0x87, 0x0C, 0x3E, 0x01, 0xE0, 0xFC, 0x1F, 0x86, 0x18, 0x7F, 0xF0, 0xE1, 0xC3, 0xFF, 0xF0, 0x1F, 0xC3, 0x87, 0xC0, 0x3F, 0xFF,  // 30
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 31
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 32
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 33
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 34
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 35
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 36
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 37
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 38
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 39
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 40
  0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 41
  0xFF, 0xFF, 0xF8, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0x0E, 0x3F, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 42
  0xFF, 0xFC, 0x00, 0xCF, 0x0E, 0x3F, 0xFF, 0xF0, 0x3F, 0x08, 0x00, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 43
  0xFF, 0x00, 0x3F, 0xE0, 0x00, 0x0F, 0xFF, 0x03, 0xFF, 0xC0, 0x03, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 44
  0xE0, 0x1F, 0xFF, 0xF3, 0xC3, 0xE7, 0xF0, 0x1F, 0xFF, 0xF0, 0x08, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 45
  0xE7, 0xFF, 0xFF, 0xFC, 0xF0, 0xE0, 0x01, 0xFF, 0xFF, 0xFC, 0x7E, 0x31, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 46
  0xE7, 0xFF, 0xFF, 0xFE, 0x38, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0x3F, 0x98, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 47
  0xE3, 0xFF, 0xFF, 0xFF, 0x9E, 0x19, 0xCF, 0xFF, 0xFF, 0xFF, 0x8F, 0xE6, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 48
  0xE1, 0xFF, 0xFF, 0xFF, 0xCF, 0x84, 0xE3, 0xFF, 0xFF, 0xFF, 0xE3, 0xF9, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 49
  0xE4, 0x7F, 0xFF, 0xFF, 0xE3, 0xC0, 0x79, 0xFF, 0xFF, 0xFF, 0xF8, 0xFE, 0x63, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 50
  0xE7, 0x3F, 0xFF, 0xFF, 0xF9, 0xF0, 0x3C, 0x7F, 0xFF, 0xFF, 0xFE, 0x7F, 0x98, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 51
  0xE7, 0x9F, 0xFF, 0xFF, 0xFC, 0x78, 0x0F, 0x3F, 0xFF, 0xFF, 0xFF, 0x1F, 0xE6, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 52
  0xE7, 0xCF, 0xFF, 0xFF, 0xFF, 0x39, 0xA7, 0x8F, 0xFF, 0xFF, 0xFF, 0xCF, 0xF1, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 53
  0xE7, 0xE7, 0xFF, 0xFF, 0xFF, 0x83, 0xD1, 0xE7, 0xFF, 0xFF, 0xFF, 0xEF, 0xFC, 0x63, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 54
  0xE7, 0xF3, 0xFF, 0xFF, 0xFF, 0xE7, 0xEC, 0xF1, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 55
  0xE7, 0xF9, 0xFF, 0xFF, 0xFF, 0xF3, 0xF6, 0x3C, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xC4, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 56
  0xE7, 0xFC, 0xFF, 0xFF, 0xFF, 0xF9, 0xFB, 0x9E, 0x3F, 0xFF, 0xFF, 0xC7, 0xFF, 0xF7, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 57
  0xE7, 0xFE, 0x7F, 0xFF, 0xFF, 0xFD, 0xF9, 0xCF, 0x9F, 0xFF, 0xFF, 0x8F, 0xFF, 0xE7, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 58
  0xF7, 0xFF, 0x3F, 0xFF, 0xFF, 0xFE, 0xFC, 0xF0, 0x07, 0xFF, 0xFE, 0x0F, 0xFF, 0xCE, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 59
  0xF7, 0xFF, 0x9F, 0xFF, 0xFF, 0xFE, 0x7E, 0x80, 0x01, 0xFF, 0xC0, 0x3F, 0xFC, 0x10, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 60
  0xF3, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0x7E, 0x07, 0xE4, 0xF8, 0x00, 0xFF, 0x80, 0x00, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 61
  0xF1, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xE6, 0x00, 0x0F, 0xE0, 0x00, 0x06, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 62
  0xF0, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xBF, 0xBF, 0xE0, 0x00, 0x7F, 0x00, 0x00, 0x38, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 63
  0xF2, 0x7F, 0xF3, 0xFF, 0xFF, 0xFF, 0x9F, 0x9E, 0x03, 0x07, 0xE0, 0x00, 0x00, 0x02, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xF0, 0x7F,  // 64
  0xF3, 0x3F, 0xF9, 0xFF, 0xFF, 0xFF, 0xDF, 0xC0, 0x60, 0x7C, 0x00, 0x00, 0x0F, 0xDE, 0x7F, 0xFF, 0xFF, 0xF0, 0x1F, 0xFC, 0x00, 0x00, 0x3F, 0xE0, 0x03, 0xFF, 0xFF, 0xFF, 0x00, 0x1F, 0xFF, 0x80, 0x1F,  // 65
  0xF3, 0x9F, 0xFD, 0xFF, 0xF9, 0xFF, 0xDF, 0xE6, 0x0F, 0x80, 0x00, 0x00, 0xCF, 0x4E, 0x7F, 0xFF, 0xFF, 0xC0, 0x1F, 0xF8, 0x00, 0x00, 0x3F, 0x80, 0x01, 0xFF, 0xFF, 0xFC, 0x00, 0x0F, 0xFF, 0x00, 0x0F,  // 66
  0xF3, 0xCF, 0xFC, 0xFF, 0xE1, 0xFF, 0xCF, 0xF0, 0x70, 0x01, 0x00, 0x1E, 0x07, 0xEE, 0x7F, 0xFF, 0xFF, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xF8, 0x00, 0x07, 0xFC, 0x00, 0x07,  // 67
  0xF3, 0xE7, 0xFE, 0xFF, 0xED, 0xFF, 0xCF, 0xFC, 0x00, 0xD8, 0x07, 0xC8, 0x0E, 0x06, 0x7F, 0xFF, 0xFE, 0x00, 0x3F, 0xF8, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7F, 0xFF, 0xF0, 0x00, 0x03, 0xF8, 0x00, 0x07,  // 68
  0xF1, 0xF3, 0xFE, 0xFF, 0xE1, 0xFF, 0xCF, 0xFF, 0x0F, 0x00, 0x18, 0x00, 0xF0, 0x86, 0x7F, 0xFF, 0xFC, 0x00, 0x3F, 0xF8, 0x00, 0x00, 0x7C, 0x07, 0xE0, 0x7F, 0xFF, 0xE0, 0x3F, 0x03, 0xF8, 0x1E, 0x03,  // 69
  0xF0, 0xF9, 0xFE, 0x7F, 0xC7, 0xFF, 0xCF, 0xFF, 0xE0, 0x00, 0x00, 0x06, 0x00, 0x82, 0xFF, 0xFF, 0xFE, 0x00, 0x3F, 0xFF, 0xFF, 0xC0, 0xFC, 0x0F, 0xE0, 0x7F, 0xFF, 0xE0, 0x7F, 0x03, 0xF0, 0x3F, 0x03,  // 70
  0xFA, 0xFC, 0xFF, 0x7F, 0xFF, 0xFF, 0xEF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x06, 0xC0, 0xFF, 0xFF, 0xFE, 0x30, 0x3F, 0xFF, 0xFF, 0xC1, 0xF8, 0x1F, 0xF0, 0x3F, 0xFF, 0xC0, 0xFF, 0x81, 0xE0, 0x7F, 0x83,  // 71
  0xFA, 0x7F, 0x7F, 0x7F, 0xFF, 0xFF, 0xEF, 0x80, 0x00, 0x07, 0xA8, 0x02, 0x78, 0x40, 0xFF, 0xFF, 0xFE, 0xF0, 0x3F, 0xFF, 0xFF, 0x81, 0xF8, 0x1F, 0xF0, 0x3F, 0xFF, 0xC0, 0xFF, 0x81, 0xE0, 0x7F, 0x81,  // 72
  0xFB, 0x3F, 0xBF, 0x3F, 0xFF, 0xFF, 0xE0, 0x01, 0xE0, 0xBF, 0xC0, 0x01, 0xC0, 0x04, 0xFF, 0xFF, 0xFF, 0xF0, 0x7F, 0xFF, 0xFF, 0x03, 0xF8, 0x1F, 0xF0, 0x3F, 0xFF, 0xC0, 0xFF, 0x81, 0xC0, 0xFF, 0x81,  // 73
  0xFB, 0x9F, 0xDF, 0x3F, 0xFF, 0xFF, 0x80, 0x1F, 0xE3, 0xFF, 0x94, 0x01, 0x00, 0xB8, 0xFF, 0xCF, 0xFF, 0xF0, 0x7F, 0xFF, 0xFF, 0x03, 0xF0, 0x3F, 0xF0, 0x3F, 0xFF, 0x81, 0xFF, 0x81, 0xC0, 0xFF, 0x81,  // 74
  0xFB, 0xCF, 0xEF, 0x3F, 0xFF, 0xF0, 0x01, 0xF0, 0xF3, 0xF0, 0x30, 0x00, 0x07, 0x80, 0xFF, 0x9F, 0xFF, 0xF0, 0x7F, 0xFF, 0xFE, 0x07, 0xF0, 0x3F, 0xF0, 0x3F, 0xFF, 0x81, 0xFF, 0x81, 0xC0, 0xFF, 0x81,  // 75
  0xF9, 0xE7, 0xF7, 0x3F, 0xFF, 0xE4, 0x7E, 0x10, 0x71, 0x02, 0x7A, 0x00, 0xF8, 0x00, 0xFF, 0x8F, 0xFF, 0xE0, 0x7F, 0xFF, 0xFC, 0x0F, 0xF0, 0x3F, 0xF0, 0x3F, 0xFF, 0x81, 0xFF, 0x81, 0x81, 0xFF, 0x81,  // 76
  0xF8, 0xF3, 0xFB, 0xBF, 0xFF, 0x0C, 0xC2, 0x1F, 0x38, 0x70, 0x22, 0x07, 0x80, 0x3D, 0xFE, 0x03, 0xFF, 0xE0, 0x7F, 0xFF, 0xFC, 0x0F, 0xF0, 0x3F, 0xE0, 0x3F, 0xFF, 0x81, 0xFF, 0x01, 0x81, 0xFF, 0x83,  // 77
  0xF8, 0x79, 0xFD, 0xBF, 0xF0, 0x2C, 0xC3, 0xBC, 0x3B, 0xE7, 0xA0, 0x7C, 0x07, 0x7D, 0xF8, 0x03, 0xFF, 0xE0, 0x7F, 0xFF, 0xF8, 0x1F, 0xF0, 0x1F, 0xE0, 0x3F, 0xFF, 0x80, 0xFF, 0x01, 0x81, 0xFF, 0x83,  // 78
  0xF9, 0x3C, 0xFE, 0xBF, 0x03, 0xEC, 0x63, 0xF8, 0x39, 0xF2, 0x21, 0xC0, 0x3F, 0x79, 0xF8, 0xFB, 0xFF, 0xE0, 0xFF, 0xFF, 0xF0, 0x3F, 0xF8, 0x1F, 0xC0, 0x7F, 0xFF, 0xC0, 0xFE, 0x03, 0x03, 0xFF, 0x03,  // 79
  0xF9, 0x9E, 0x7F, 0x30, 0x3F, 0xED, 0x7F, 0xF8, 0xFC, 0x30, 0xF0, 0x03, 0x7F, 0x79, 0xF1, 0xFF, 0xFF, 0xE0, 0xFF, 0xFF, 0xF0, 0x3F, 0xF8, 0x06, 0x00, 0x7F, 0xFF, 0xC0, 0x30, 0x03, 0x03, 0xFF, 0x03,  // 80
  0xF9, 0xCF, 0x3F, 0x87, 0xFF, 0xED, 0x7F, 0xFF, 0xC0, 0x03, 0x00, 0x1F, 0x7F, 0x79, 0xF1, 0xFF, 0xFF, 0xC0, 0xFF, 0xFF, 0xE0, 0x7F, 0xF8, 0x00, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x03, 0x03, 0xFF, 0x03,  // 81
  0xF9, 0xE7, 0x9F, 0xBF, 0xFF, 0xED, 0x3F, 0xFE, 0x02, 0x30, 0x00, 0x3F, 0x7E, 0x79, 0xF1, 0xFF, 0xFF, 0xC0, 0xFF, 0xFF, 0xC0, 0xFF, 0xFC, 0x00, 0x00, 0xFF, 0xFF, 0xE0, 0x00, 0x07, 0x03, 0xFF, 0x03,  // 82
  0xF9, 0xF3, 0xCF, 0xBF, 0xFF, 0xED, 0xBF, 0xC2, 0x06, 0x00, 0x00, 0x07, 0x7E, 0x79, 0xF0, 0xFF, 0xFF, 0xC0, 0xFF, 0xFF, 0xC0, 0xFF, 0xFE, 0x00, 0x40, 0xFF, 0xFF, 0xF0, 0x02, 0x07, 0x03, 0xFE, 0x07,  // 83
  0xF9, 0xF9, 0xE7, 0xBF, 0xFF, 0xED, 0x98, 0x52, 0x3E, 0x00, 0x00, 0x00, 0x7E, 0x79, 0xF8, 0x7F, 0xFF, 0xC1, 0xFF, 0xFF, 0x81, 0xFF, 0xFF, 0x80, 0xC0, 0xFF, 0xFF, 0xFC, 0x06, 0x07, 0x03, 0xFE, 0x07,  // 84
  0xF9, 0xFC, 0xF3, 0x9F, 0xFF, 0xED, 0xDB, 0x47, 0xE0, 0x00, 0x00, 0x18, 0x7E, 0x73, 0xFC, 0x1F, 0xFF, 0xC1, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x81, 0xFF, 0xFF, 0xFF, 0xFC, 0x0F, 0x03, 0xFE, 0x07,  // 85
  0xF9, 0xFE, 0xF9, 0xDF, 0xFF, 0xED, 0xC8, 0x7E, 0x00, 0x00, 0x00, 0x0F, 0x7E, 0x73, 0xFE, 0x0F, 0xFF, 0x81, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xF8, 0x0F, 0x03, 0xFC, 0x0F,  // 86
  0xFD, 0xFE, 0x7C, 0xDF, 0xFF, 0xED, 0xE3, 0xE0, 0x00, 0x00, 0x00, 0x03, 0x7E, 0xF3, 0xFF, 0x8F, 0xFF, 0x81, 0xFF, 0xFE, 0x07, 0xFF, 0xFF, 0xFE, 0x03, 0xFF, 0xFF, 0xFF, 0xF0, 0x1F, 0x03, 0xFC, 0x0F,  // 87
  0xFD, 0xFF, 0x3E, 0x5F, 0xFF, 0xE0, 0x78, 0x00, 0x00, 0x00, 0x3E, 0x01, 0x7C, 0xF3, 0xFF, 0xC7, 0xFF, 0x81, 0xFF, 0xFC, 0x07, 0xFF, 0xFF, 0xFC, 0x07, 0xFF, 0xFF, 0xFF, 0xE0, 0x3F, 0x03, 0xFC, 0x0F,  // 88
  0xFC, 0xFF, 0x9F, 0x18, 0x3F, 0x87, 0x0C, 0x00, 0x00, 0x03, 0xFF, 0x80, 0x79, 0xC3, 0xFF, 0xC7, 0xFF, 0x83, 0xFF, 0xFC, 0x0F, 0xFF, 0xFF, 0xF8, 0x07, 0xF8, 0x7F, 0xFF, 0xC0, 0x3F, 0x03, 0xF8, 0x1F,  // 89
  0xFC, 0xFF, 0xCF, 0x81, 0x9C, 0x0F, 0xE0, 0x00, 0x00, 0x3F, 0xFF, 0xE0, 0x63, 0x13, 0xFF, 0xC7, 0xFF, 0x83, 0xFF, 0xF8, 0x1F, 0xFF, 0xFF, 0xE0, 0x0F, 0xF0, 0x3F, 0xFF, 0x00, 0x7F, 0x01, 0xF0, 0x3F,  // 90
  0xFE, 0xFF, 0xE7, 0xDF, 0xC1, 0xEF, 0xE0, 0x00, 0x03, 0xFF, 0xF8, 0x30, 0x00, 0x73, 0xFF, 0xC7, 0xFF, 0x03, 0xFF, 0xF0, 0x1F, 0xFF, 0xFF, 0x00, 0x1F, 0xE0, 0x3F, 0xF8, 0x00, 0xFF, 0x81, 0xE0, 0x3F,  // 91
  0xFE, 0x7F, 0xF3, 0xDF, 0xDF, 0xEF, 0xE0, 0x00, 0x3F, 0xFF, 0xC0, 0x3C, 0x01, 0xF3, 0xDF, 0x8F, 0xFF, 0x03, 0xFF, 0xF0, 0x3F, 0xFF, 0xF0, 0x00, 0x3F, 0xE0, 0x3F, 0x80, 0x01, 0xFF, 0x80, 0x00, 0x7F,  // 92
  0xFF, 0x3F, 0xF9, 0xDF, 0xDF, 0xEF, 0xE0, 0x03, 0xFF, 0xFC, 0x01, 0xFF, 0x1C, 0x67, 0xC0, 0x0F, 0xFF, 0x03, 0xFF, 0xE0, 0x7F, 0xFF, 0xF0, 0x00, 0xFF, 0xE0, 0x3F, 0x80, 0x07, 0xFF, 0xC0, 0x00, 0xFF,  // 93
  0xFF, 0x3F, 0xFD, 0xDF, 0xDF, 0xEF, 0xE0, 0x1F, 0xFF, 0xF8, 0x1F, 0xE7, 0xC7, 0x27, 0xC0, 0x3F, 0xFF, 0x03, 0xFF, 0xC0, 0x7F, 0xFF, 0xF0, 0x01, 0xFF, 0xE0, 0x3F, 0x80, 0x0F, 0xFF, 0xE0, 0x01, 0xFF,  // 94
  0xFF, 0x9F, 0xFE, 0xDF, 0xDF, 0xEF, 0xE1, 0xFF, 0xFE, 0x1E, 0xFF, 0xFD, 0xE1, 0x87, 0xF8, 0xFF, 0xFF, 0x07, 0xFF, 0xC0, 0xFF, 0xFF, 0xF0, 0x0F, 0xFF, 0xF0, 0x7F, 0x80, 0x7F, 0xFF, 0xF0, 0x07, 0xFF,  // 95
  0xFF, 0x8F, 0xFE, 0xDF, 0xDF, 0xEF, 0xE7, 0xFF, 0xFC, 0x0F, 0xF7, 0xFF, 0xF8, 0xE7, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xFF, 0xFF, 0xF9, 0xFF, 0x8F, 0xFF, 0xFF, 0xFE, 0x3F, 0xFF,  // 96
  0xFF, 0xCF, 0xFE, 0x5F, 0xDF, 0xEF, 0xE7, 0xFF, 0xFE, 0x3F, 0x7F, 0xFF, 0xBE, 0x31, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 97
  0xFF, 0xE7, 0xFF, 0x5F, 0xDF, 0xEF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x08, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 98
  0xFF, 0xF3, 0xFF, 0x5F, 0xDF, 0xEF, 0xE7, 0xFF, 0xFF, 0xFF, 0xDF, 0xEF, 0xEF, 0xC6, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 99
  0xFF, 0xF9, 0xFF, 0x5F, 0xDF, 0xEF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xF1, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 100
  0xFF, 0xFC, 0xFF, 0x5F, 0xDF, 0xEF, 0xE7, 0xFF, 0x9F, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 101
  0xFF, 0xFE, 0x7F, 0x5F, 0xDF, 0xE7, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xBE, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 102
  0xFF, 0xFF, 0x3F, 0x5F, 0xDF, 0xF7, 0x87, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 103
  0xFF, 0xFF, 0x9F, 0x5F, 0xDF, 0xF0, 0x23, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 104
  0xFF, 0xFF, 0x8F, 0x5F, 0xCF, 0xFD, 0xE0, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 105
  0xFF, 0xFF, 0xCF, 0x5F, 0xE7, 0xFE, 0x00, 0x7F, 0xFF, 0x9F, 0xFF, 0xFF, 0xFB, 0xFC, 0xFC, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 106
  0xFF, 0xFF, 0xE7, 0x5F, 0xF3, 0xE0, 0x34, 0x1F, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 107
  0xFF, 0xFF, 0xF3, 0x1F, 0xF8, 0x00, 0x16, 0x0F, 0xFF, 0xE3, 0xFF, 0xFD, 0xFE, 0xFF, 0xFF, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 108
  0xFF, 0xFF, 0xF3, 0x1F, 0xFF, 0x03, 0xD7, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xF8, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 109
  0xFF, 0xFF, 0xF9, 0x1F, 0xF0, 0x3F, 0xD3, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0x3F, 0xFF, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 110
  0xFF, 0xFF, 0xFC, 0x1F, 0x80, 0x7F, 0x91, 0xC0, 0x7F, 0xFF, 0xFF, 0xFB, 0xFF, 0xFE, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 111
  0xFF, 0xFF, 0xFE, 0x4F, 0x30, 0xDF, 0x00, 0xE0, 0x1F, 0xFF, 0x9F, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 112
  0xFF, 0xFF, 0xFF, 0x2F, 0x68, 0x10, 0x08, 0x70, 0x8F, 0xFF, 0xF1, 0xFF, 0xFF, 0x81, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 113
  0xFF, 0xFF, 0xFF, 0x0F, 0x40, 0x00, 0xFC, 0x38, 0x63, 0xFF, 0xE7, 0xFF, 0xFC, 0x0F, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 114
  0xFF, 0xFF, 0xFF, 0x8F, 0x00, 0x0F, 0xFE, 0x1C, 0x01, 0xFF, 0xFF, 0xFF, 0xE0, 0xFF, 0xE7, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 115
  0xFF, 0xFF, 0xFF, 0xC7, 0x00, 0x7F, 0xFF, 0x06, 0x2C, 0x7F, 0xFF, 0xFF, 0x07, 0xFF, 0xE3, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 116
  0xFF, 0xFF, 0xFF, 0xE0, 0x07, 0xFF, 0xFF, 0x83, 0x1C, 0x3F, 0xFF, 0xF0, 0x3F, 0xFF, 0x00, 0x3C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 117
  0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xC1, 0x80, 0x0F, 0xFF, 0x81, 0xFF, 0xF8, 0x60, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 118
  0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xE0, 0x8E, 0x03, 0xFC, 0x0F, 0xFF, 0xE3, 0x07, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 119
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x2F, 0x01, 0xE0, 0x7F, 0xFE, 0x10, 0x3C, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 120
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x07, 0xC0, 0x03, 0xFF, 0xF8, 0xE1, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 121
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x0F, 0xC0, 0x13, 0xFF, 0xC3, 0x0F, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 122
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x1E, 0x01, 0xF9, 0xFE, 0x00, 0x3C, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 123
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x0F, 0xFC, 0xF8, 0xC1, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 124
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x7F, 0xFE, 0x02, 0x0F, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 125
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x7C, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 126
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x83, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 127
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 128
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x3C, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 129
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 130
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 131
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 132
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 133
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 134
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 135
  0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 136
  0xFF, 0xFE, 0x0E, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x8F, 0xFF, 0xFF, 0xFF, 0x83, 0xCE, 0xBF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x3F, 0x8F, 0x86, 0xBD, 0xF8, 0x60, 0xFF,  // 137
  0xFF, 0xFE, 0xF7, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x7F, 0xFF, 0xFF, 0xDF, 0xFB, 0xB6, 0xBD, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xBE, 0xDF, 0xF7, 0xBE, 0xBD, 0xF7, 0xEF, 0x7F,  // 138
  0xFE, 0x3E, 0xFA, 0xE6, 0x9D, 0x0D, 0xDF, 0x4C, 0x3A, 0x70, 0xDF, 0x7D, 0x22, 0x1C, 0x0F, 0xF7, 0xB6, 0xB8, 0xC3, 0xBB, 0x9A, 0x7E, 0x98, 0x74, 0xE1, 0xBE, 0xDF, 0xF7, 0xBE, 0xBD, 0xEF, 0xEF, 0xBF,  // 139
  0xFE, 0x3E, 0xFA, 0xDE, 0x6D, 0xF6, 0xBF, 0x37, 0xD9, 0xAF, 0x5F, 0xBC, 0xDD, 0xED, 0xDF, 0xF7, 0xCF, 0xFD, 0xBD, 0xBA, 0x79, 0xBE, 0x6F, 0xB3, 0x5E, 0xBF, 0x3F, 0xCF, 0x8F, 0xFD, 0xEF, 0xEF, 0xBF,  // 140
  0xFE, 0x3E, 0xFA, 0xCE, 0xED, 0x86, 0xBF, 0x76, 0x1B, 0xA0, 0x5F, 0xDD, 0xDD, 0x0D, 0xDF, 0xEF, 0xB7, 0xFD, 0xBD, 0xBA, 0xFB, 0xBE, 0xEC, 0x37, 0x40, 0xBE, 0xB7, 0xE7, 0xF7, 0xFD, 0xEF, 0xEF, 0xBF,  // 141
  0xFF, 0xFE, 0xFA, 0xF6, 0xED, 0x76, 0xBF, 0x75, 0xDB, 0xAF, 0xDF, 0xED, 0xDC, 0xED, 0xDF, 0xEF, 0x7B, 0xFD, 0xBD, 0xBA, 0xFB, 0xBE, 0xEB, 0xB7, 0x5F, 0xBD, 0xCF, 0xF7, 0xF7, 0xFD, 0xEF, 0xEF, 0xBF,  // 142
  0xFF, 0xFE, 0xE6, 0xF6, 0xED, 0x77, 0x3F, 0x75, 0xDB, 0xB7, 0xDF, 0xED, 0xDC, 0xED, 0xDF, 0xDF, 0x7B, 0xFD, 0xB9, 0xB2, 0x7B, 0xBE, 0xEB, 0xB7, 0x6F, 0xBD, 0xCF, 0xF6, 0xF7, 0xFD, 0xF7, 0xEE, 0x7F,  // 143
  0xFF, 0xFE, 0x1E, 0xCE, 0x1D, 0x87, 0x7F, 0x0E, 0x1B, 0xB8, 0x5F, 0x1D, 0xDD, 0x0D, 0xEF, 0x9F, 0x87, 0xFE, 0xC7, 0xCB, 0x9B, 0xBE, 0x1C, 0x37, 0x70, 0xBE, 0x27, 0x0E, 0x0F, 0xFC, 0x38, 0x61, 0xFF,  // 144
  0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 145
  0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFE, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 146
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 147
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 148
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 149
  0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBE, 0xFF,  // 150
  0xFE, 0x1F, 0xFB, 0x7F, 0xEF, 0xFF, 0xFF, 0xBF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xE1, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFB, 0xFF, 0xFD, 0xE1, 0xFF, 0xBF, 0xBE, 0xFF,  // 151
  0xC6, 0xEF, 0xFF, 0x6F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xEF, 0xBB, 0xFF, 0xFF, 0xFF, 0xEF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xDE, 0xFF, 0xFF, 0xBE, 0xFF,  // 152
  0xC6, 0xED, 0xDB, 0x47, 0xED, 0x3E, 0xED, 0xB1, 0x0D, 0x87, 0x39, 0xE1, 0xD3, 0xCB, 0xEF, 0x1A, 0x70, 0xC5, 0x38, 0x47, 0xD3, 0x84, 0x5D, 0xB0, 0xE2, 0xDB, 0x4F, 0x2F, 0xBF, 0x5D, 0xB9, 0xB6, 0xBB,  // 153
  0xC6, 0x1D, 0xDB, 0x6F, 0xEC, 0xDE, 0xCD, 0xB6, 0xF5, 0x7A, 0xF7, 0xFE, 0xCD, 0x33, 0xE1, 0xB9, 0xAF, 0x5C, 0xD7, 0xAF, 0xCD, 0x7A, 0xD9, 0xAF, 0x6E, 0xBB, 0x34, 0xCF, 0xBF, 0x5D, 0xA7, 0xAE, 0xD7,  // 154
  0xFE, 0xED, 0xDB, 0x6C, 0x6D, 0xDF, 0x4B, 0xB6, 0x05, 0x02, 0x73, 0xF0, 0xDD, 0x7B, 0xEF, 0xBB, 0xA0, 0x5D, 0xD0, 0x2F, 0xDD, 0x02, 0xE9, 0x6F, 0x6E, 0x7B, 0x75, 0xEF, 0xBF, 0x5D, 0xAF, 0x9E, 0xD7,  // 155
  0xFE, 0xED, 0xDB, 0x6F, 0xED, 0xDF, 0x2B, 0xB6, 0xFD, 0x7F, 0xBD, 0xEE, 0xDD, 0x7B, 0xEF, 0xBB, 0xAF, 0xDD, 0xD7, 0xEF, 0xDD, 0x7E, 0xE5, 0x6F, 0x6E, 0xBB, 0x75, 0xEF, 0xBF, 0x5D, 0xAF, 0xAE, 0xD7,  // 156
  0xFE, 0xED, 0x9B, 0x6F, 0xED, 0xDF, 0x33, 0xB7, 0x7D, 0xBF, 0xBD, 0xEE, 0xDD, 0x73, 0xEF, 0xBB, 0xB7, 0xDD, 0xDB, 0xEF, 0xDD, 0xBE, 0xE6, 0x6E, 0x6E, 0xDB, 0x75, 0xCF, 0xDE, 0xD9, 0xA7, 0xB6, 0xE7,  // 157
  0xFE, 0x1E, 0x5B, 0x77, 0xED, 0xDF, 0xB7, 0xB7, 0x85, 0xC2, 0x73, 0xF0, 0xDD, 0x8B, 0xE1, 0xDB, 0xB8, 0x5D, 0xDC, 0x37, 0xDD, 0xC3, 0x76, 0xF1, 0xEE, 0xCB, 0x76, 0x2F, 0xE1, 0xE5, 0xB9, 0xB2, 0xEF,  // 158
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFE, 0x7F, 0xFF, 0xFF, 0xEF,  // 159
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF,  // 160
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF,  // 161
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 162
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 163
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFB, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 164
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xDB, 0xFF, 0xFB, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 165
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0xFB, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 166
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x9C, 0x5A, 0x63, 0xC6, 0x21, 0xD2, 0x3D, 0xD8, 0x77, 0x63, 0xD2, 0x30, 0xE9, 0xDB, 0x0F, 0xCB, 0x0B, 0xB7, 0x30, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 167
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1E, 0x6D, 0xD9, 0xB7, 0xEE, 0xDE, 0xCD, 0xDE, 0xB7, 0xB7, 0x6F, 0xCD, 0xCF, 0x66, 0xDA, 0xF7, 0x32, 0xF5, 0x74, 0xEF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 168
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1E, 0xED, 0xDB, 0xB7, 0xEE, 0xDE, 0xDD, 0xDE, 0xB7, 0xB7, 0x6F, 0xDD, 0xCF, 0x6E, 0xDA, 0x07, 0x7A, 0x05, 0x75, 0xE0, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 169
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1E, 0xED, 0xDB, 0xB7, 0xEE, 0xDE, 0xDD, 0xDE, 0xB7, 0xB7, 0x6F, 0xDD, 0xCF, 0x6E, 0xDA, 0xFF, 0x7A, 0xFD, 0x75, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 170
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xED, 0xDB, 0xB7, 0xEE, 0xDC, 0xDD, 0xDF, 0x37, 0x36, 0x6F, 0xDD, 0xCE, 0x6E, 0xDB, 0x7F, 0x73, 0x7D, 0x74, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 171
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x1D, 0xDB, 0xBB, 0xEE, 0xE3, 0xDD, 0xDF, 0x78, 0xF9, 0x6F, 0xDD, 0xD1, 0xE1, 0xDB, 0x87, 0x8B, 0x86, 0xF7, 0x38, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 172
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 173
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 174
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // 175
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF   // 176
};
//2013/04/03 Resolution: 264 x 176
#endif


#define LINE_SIZE	64  /**< maximum data line size */

/**
 * \brief Support 1.44", 2" and 2.7" three type EPD */
enum EPD_SIZE {
	EPD_144,
	EPD_200,
	EPD_270
};

/**
 * \brief The definition for driving stage to compare with for getting Odd and Even data  */
#define BLACK0   (uint8_t)(0x03) /**< getting bit1 or bit0 as black color(11) */
#define BLACK1   (uint8_t)(0x0C) /**< getting bit3 or bit2 as black color(11) */
#define BLACK2   (uint8_t)(0x30) /**< getting bit5 or bit4 as black color(11) */
#define BLACK3   (uint8_t)(0xC0) /**< getting bit7 or bit6 as black color(11) */
#define WHITE0   (uint8_t)(0x02) /**< getting bit1 or bit0 as white color(10) */
#define WHITE1   (uint8_t)(0x08) /**< getting bit3 or bit2 as white color(10) */
#define WHITE2   (uint8_t)(0x20) /**< getting bit5 or bit4 as white color(10) */
#define WHITE3   (uint8_t)(0x80) /**< getting bit7 or bit6 as white color(10) */
#define NOTHING0 (uint8_t)(0x01) /**< getting bit1 or bit0 as nothing input(01) */
#define NOTHING1 (uint8_t)(0x04) /**< getting bit3 or bit2 as nothing input(01) */
#define NOTHING2 (uint8_t)(0x10) /**< getting bit5 or bit4 as nothing input(01) */
#define NOTHING3 (uint8_t)(0x40) /**< getting bit7 or bit6 as nothing input(01) */
#define NOTHING  (uint8_t)(0x00) /**< sending Nothing frame, 01=Nothing, 0101=0x5 */


#define ALL_BLACK	 	 (uint8_t)(0xFF)
#define ALL_WHITE		 (uint8_t)(0xAA)
#define BORDER_BYTE_B    (uint8_t)(0xFF)
#define BORDER_BYTE_W    (uint8_t)(0xAA)
#define ERROR_BUSY       (uint8_t)(0xF0)
#define ERROR_COG_ID     (uint8_t)(0xF1)
#define ERROR_BREAKAGE   (uint8_t)(0xF2)
#define ERROR_DC         (uint8_t)(0xF3)
#define ERROR_CHARGEPUMP (uint8_t)(0xF4)
#define RES_OK           (uint8_t)(0x00)

/**
 * \brief The COG Driver uses a buffer to update the EPD line by line.
   \note Use the 2.7" maximum data(66)+scan(44)+dummy(1) bytes as line buffer size=111.*/
#define LINE_BUFFER_DATA_SIZE 111

/**
 * \brief Support 1.44", 2" and 2.7" three type EPD currently */
#define COUNT_OF_EPD_TYPE 3

/**
 * \brief Four driving stages */
enum Stage {
	Stage1, /**< Inverse previous image */
	Stage2, /**< White */
	Stage3, /**< Inverse new image */
	Stage4  /**< New image */
};

#if (defined COG_V110_G1)
/** 
 * \brief Line data structure of 1.44 inch EPD
 * \note 
 * 1.44 inch needs to put border_control byte at the front of data line. 
 * Refer to COG document Section 5.2 - 1.44" Input Data Order. 
 */
struct COG_144_line_data_t {
	uint8_t border_byte;  /**< Internal border_control, for 1.44" EPD only */
	uint8_t even[16]; /**< 1.44" even byte array */
	uint8_t scan[24]; /**< 1.44" scan byte array */
	uint8_t odd [16]; /**< 1.44" odd byte array */
} ATTRPACKED;

/** 
 * \brief Line data structure of 2 inch EPD
 * \note
 * Add one byte x00 to complete a line
 * Refer to COG document Section 5.2 - 2" Input Data Order. 
 */
struct COG_200_line_data_t {
	uint8_t even[25]; /**< 2" even byte array */
	uint8_t scan[24]; /**< 2" scan byte array */
	uint8_t odd [25]; /**< 2" odd byte array */
	uint8_t dummy_data;	/**< dummy byte 0x00 */
} ATTRPACKED;

/** 
 * \brief Line data structure of 2.7 inch EPD
 * \note
 * Add one byte x00 to complete a line
 * Refer to COG document Section 5.2 - 2.7" Input Data Order. 
 */
struct COG_270_line_data_t {
	uint8_t even[33]; /**< 2.7" even byte array */
	uint8_t scan[44]; /**< 2.7" scan byte array */
	uint8_t odd [33]; /**< 2.7" odd byte array */
	uint8_t dummy_data;	/**< dummy byte 0x00 */
} ATTRPACKED;

#elif (defined COG_V110_G2) 

/** 
 * \brief Line data structure of 1.44 inch EPD with G2 COG
 * \note 
 * 1.44 inch needs to put border_control byte at the front of data line. 
 * Refer to COG document Section 5.2 - 1.44" Input Data Order. 
 */
struct COG_144_line_data_t {
	uint8_t even[16]; /**< 1.44" even byte array */
	uint8_t scan[24]; /**< 1.44" scan byte array */
	uint8_t odd [16]; /**< 1.44" odd byte array */
	uint8_t border_byte; /**< Internal border_control*/
} ATTRPACKED;

/** 
 * \brief Line data structure of 2 inch EPD with G2 COG
 * \note
 * Add one byte x00 to complete a line
 * Refer to COG document Section 5.2 - 2" Input Data Order. 
 */
struct COG_200_line_data_t {
    uint8_t border_byte; /**< Internal border_control*/
	uint8_t even[25]; /**< 2" even byte array */
	uint8_t scan[24]; /**< 2" scan byte array */
	uint8_t odd [25]; /**< 2" odd byte array */
} ATTRPACKED;
    
/** 
 * \brief Line data structure of 2.7 inch EPD with G2 COG
 * \note
 * Add one byte x00 to complete a line
 * Refer to COG document Section 5.2 - 2.7" Input Data Order. 
 */
struct COG_270_line_data_t {
    uint8_t border_byte; /**< Internal border_control*/
	uint8_t even[33]; /**< 2.7" even byte array */
	uint8_t scan[44]; /**< 2.7" scan byte array */
	uint8_t odd [33]; /**< 2.7" odd byte array */
} ATTRPACKED;

#elif (defined COG_V230_G2)
/** 
 * \brief Line data structure of 1.44 inch V230 EPD with G2 COG
 * \note 
 * 1.44 inch needs to put border_control byte at the front of data line. 
 * Refer to COG document Section 5.2 - 1.44" Input Data Order. 
 */
struct COG_144_line_data_t {
	uint8_t even[16]; /**< 1.44" even byte array */
	uint8_t scan[24]; /**< 1.44" scan byte array */
	uint8_t odd [16]; /**< 1.44" odd byte array */
	uint8_t border_byte; /**< Internal border_control*/
} ATTRPACKED;

/** 
 * \brief Line data structure of 2 inch V230 EPD with G2 COG
 * \note
 * Add one byte x00 to complete a line
 * Refer to COG document Section 5.2 - 2" Input Data Order. 
 */
struct COG_200_line_data_t {
    uint8_t border_byte; /**< Internal border_control*/
	uint8_t even[25]; /**< 2" even byte array */
	uint8_t scan[24]; /**< 2" scan byte array */
	uint8_t odd [25]; /**< 2" odd byte array */
} ATTRPACKED;
    
/** 
 * \brief Line data structure of 2.7 inch V230 EPD with G2 COG
 * \note
 * Add one byte x00 to complete a line
 * Refer to COG document Section 5.2 - 2.7" Input Data Order. 
 */
struct COG_270_line_data_t {
    uint8_t border_byte; /**< Internal border_control*/
	uint8_t even[33]; /**< 2.7" even byte array */
	uint8_t scan[44]; /**< 2.7" scan byte array */
	uint8_t odd [33]; /**< 2.7" odd byte array */
} ATTRPACKED;

struct EPD_WaveformTable_Struct
{
	uint8_t stage1_frame1;
	uint8_t stage1_block1;
	uint8_t stage1_step1;
	
	uint16_t stage2_t1;
	uint16_t stage2_t2;
	uint8_t stage2_cycle;
	
	uint8_t stage3_frame3;
	uint8_t stage3_block3;
	uint8_t stage3_step3;
};
struct EPD_V230_G2_Struct
{
	 int16_t frame_y0;
	 int16_t frame_y1;
	 int16_t block_y0;
	 int16_t block_y1;
	 int16_t block_size;
	 int16_t step_size;
	 int16_t frame_cycle;
	 int16_t step_y0;
	 int16_t step_y1;
	 int16_t number_of_steps;
};
#else
#error "ERROR: The EPD's COG type is not defined."
#endif

/** 
 * \brief Packet structure of a line data */
typedef union {
	union {
		struct COG_144_line_data_t line_data_for_144; /**< line data structure of 1.44" EPD */
		struct COG_200_line_data_t line_data_for_200; /**< line data structure of 2" EPD */
		struct COG_270_line_data_t line_data_for_270; /**< line data structure of 2.7" EPD */
	} line_data_by_size; /**< the line data of specific EPD size */
	uint8_t uint8[LINE_BUFFER_DATA_SIZE]; /**< the maximum line buffer data size as length */
} COG_line_data_packet_type;

/** 
 * \brief Define the COG driver's parameters */
struct COG_parameters_t {
	uint8_t   channel_select[8]; /**< the SPI register data of Channel Select */
	uint8_t   voltage_level;     /**< the SPI register data of Voltage Level */
	uint16_t  horizontal_size;   /**< the bytes of width of EPD */
	uint16_t  vertical_size;     /**< the bytes of height of EPD */
	uint8_t   data_line_size;    /**< Data + Scan + Dummy bytes */
	uint16_t  frame_time_offset; /**< the rest of frame time in a stage */
	uint16_t  stage_time;        /**< defined stage time */
} ;


/** 
 * \brief Developer needs to create an external function if wants to read flash */
typedef void (*EPD_read_flash_handler)(long flash_address,uint8_t *target_buffer, 
		uint8_t byte_length);

extern const struct COG_parameters_t  COG_parameters[COUNT_OF_EPD_TYPE];
extern const uint8_t   SCAN_TABLE[4];
void EPD_init(void);
void EPD_power_on (void);
uint8_t EPD_initialize_driver (uint8_t EPD_type_index);
void EPD_display_from_flash_prt (uint8_t EPD_type_index, long previous_image_flash_address,
	long new_image_flash_address,EPD_read_flash_handler On_EPD_read_flash);
uint8_t EPD_power_off (uint8_t EPD_type_index);
void COG_driver_EPDtype_select(uint8_t EPD_type_index);



void EPD_display_init(void);
void EPD_power_init(uint8_t EPD_type_index);
void EPD_display_from_flash(uint8_t EPD_type_index,long previous_image_address,
	long new_image_address,EPD_read_flash_handler On_EPD_read_flash);
void EPD_display_from_flash_Ex(uint8_t EPD_type_index,long previous_image_address,
	long new_image_address,EPD_read_flash_handler On_EPD_read_flash);


static int get_temperature(void)
{
	return 30;
}

static void initialize_temperature(void)
{

}

#ifdef COG_V230_G2

#define ADDRESS_NULL		0xffffffff
//EPD Panel parameters
const struct COG_parameters_t COG_parameters[COUNT_OF_EPD_TYPE]  = {
	{
		// FOR 1.44"
		{0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0x00},
		0x03,
		(128/8),
		96,
		((((128+96)*2)/8)+1),
		0,
		480
	},
	{
		// For 2.0"
		{0x00,0x00,0x00,0x00,0x01,0xFF,0xE0,0x00},
		0x03,
		(200/8),
		96,
		((((200+96)*2)/8)+1),
		0,
		480
	},
	{
		// For 2.7"
		{0x00,0x00,0x00,0x7F,0xFF,0xFE,0x00,0x00},
		0x00,
		(264/8),
		176,
		((((264+176)*2)/8)+1),
		0,
		630
	}
};

//EPD Waveform parameters
 const struct EPD_WaveformTable_Struct E_Waveform[COUNT_OF_EPD_TYPE][2]  = {
		{// FOR 1.44"
			{//50 ?? T ?? 40
				4,				//stage1_frame1
				16,				//stage1_block1
				2,				//stage1_step1				
				155,			//stage2_t1
				155,			//stage2_t2
				4,				//stage2_cycle
				4,				//stage3_frame3
				16,				//stage3_block3
				2				//stage3_step3
			}
			,{//40 ?? T ?? 10
				4,				//stage1_frame1
				16,				//stage1_block1
				2,				//stage1_step1				
				155,			//stage2_t1
				155,			//stage2_t2
				4,				//stage2_cycle
				4,				//stage3_frame3
				16,				//stage3_block3
				2				//stage3_step3
			}
			
		},
		{// For 2.0"
			{//50 ?? T ?? 40
				4,				//stage1_frame1
				48,				//stage1_block1
				2,				//stage1_step1				
				155,			//stage2_t1
				155,			//stage2_t2
				4,				//stage2_cycle
				4,				//stage3_frame3
				48,				//stage3_block3
				2				//stage3_step3
			}
			,{//40 ?? T ?? 10
				2,				//stage1_frame1
				48,				//stage1_block1
				2,				//stage1_step1				
				155,			//stage2_t1
				155,			//stage2_t2
				4,				//stage2_cycle
				2,				//stage3_frame3
				48,				//stage3_block3
				2				//stage3_step3
			}
		},
		{// For 2.7"
			{//50 ?? T ?? 40
				4,				//stage1_frame1
				22,				//stage1_block1
				2,				//stage1_step1				
				155,			//stage2_t1
				155,			//stage2_t2
				4,				//stage2_cycle
				4,				//stage3_frame3
				22,				//stage3_block3
				2				//stage3_step3
			}
			,{//40 ?? T ?? 10
				2,				//stage1_frame1
				22,				//stage1_block1
				2,				//stage1_step1				
				155,			//stage2_t1
				155,			//stage2_t2
				4,				//stage2_cycle
				2,				//stage3_frame3
				22,				//stage3_block3
				2				//stage3_step3
			}
		},
	 
 };

const uint8_t   SCAN_TABLE[4] = {0xC0,0x30,0x0C,0x03};
	
static const struct EPD_WaveformTable_Struct *action__Waveform_param;
static COG_line_data_packet_type COG_Line;
static EPD_read_flash_handler _On_EPD_read_flash=NULL;
static uint16_t current_frame_time;
static uint8_t  *data_line_even;
static uint8_t  *data_line_odd;
static uint8_t  *data_line_scan;
static uint8_t  *data_line_border_byte;

/**
* \brief According to EPD size and temperature to get stage_time
* \note Refer to COG document Section 5.3 for more details
*
* \param EPD_type_index The defined EPD size
*/
static void set_temperature_factor(uint8_t EPD_type_index) {
	int8_t temperature;
	temperature = get_temperature();	
        if (50 >= temperature  && temperature > 40){
			action__Waveform_param=&E_Waveform[EPD_type_index][0];
		}else if (40 >= temperature  && temperature > 10){
			action__Waveform_param=&E_Waveform[EPD_type_index][1];
		}else action__Waveform_param=&E_Waveform[EPD_type_index][1]; //Default
}


/**
* \brief Set EPD_CS pin to high
*/
void EPD_cs_high (void) {
}

/**
* \brief Set EPD_CS pin to low
*/
void EPD_cs_low (void) {
}

/**
* \brief Set Flash_CS pin to high
*/
void EPD_flash_cs_high(void) {
	//set_gpio_high(Flash_CS_PIN);
}

/**
* \brief Set Flash_CS pin to low
*/
void EPD_flash_cs_low (void) {
	//set_gpio_low(Flash_CS_PIN);
}

/**
* \brief Set /RESET pin to high
*/
void EPD_rst_high (void) {
	board_lcd_reset(1); 	// Pull RST pin high
	board_update();
}

/**
* \brief Set /RESET pin to low
*/
void EPD_rst_low (void) {
	board_lcd_reset(0); 	// Pull RST pin down
	board_update();
}

/**
* \brief Set DISCHARGE pin to high
*/
void EPD_discharge_high (void) {
	eink_lcd_discharge(1);
}

/**
* \brief Set DISCHARGE pin to low
*/
void EPD_discharge_low (void) {
	eink_lcd_discharge(0);
}

/**
* \brief Set Vcc (PANEL_ON) to high
*/
void EPD_Vcc_turn_on (void) {
	eink_lcd_pwron(1);
}

/**
* \brief Set Vcc (PANEL_ON) to low
*/
void EPD_Vcc_turn_off (void) {
	eink_lcd_pwron(0);
}

/**
* \brief Set BORDER_CONTROL pin to high
*/
void EPD_border_high(void) {
	eink_lcd_on_border(1);
}

/**
* \brief Set BORDER_CONTROL pin to low
*/
void EPD_border_low (void) {
	eink_lcd_on_border(0);
}

/**
* \brief Set PWM pin to high
*/
void EPD_pwm_high(void) {
	//set_gpio_high(PWM_PIN);
}

/**
* \brief Set PWM pin to low
*/
void EPD_pwm_low (void) {
	//set_gpio_low(PWM_PIN);
}

/**
* \brief Set MISO pin of SPI to low
*/
void SPIMISO_low(void) {
	//config_gpio_dir_o(SPIMISO_PIN);
	//set_gpio_low(SPIMISO_PIN);
}

/**
* \brief Set MOSI pin of SPI to low
*/
void SPIMOSI_low(void) {
	//set_gpio_low(SPIMOSI_PIN);
}

/**
* \brief Set Clock of SPI to low
*/
void SPICLK_low(void) {
	//set_gpio_low(SPICLK_PIN);
}

/**
* \brief Get BUSY pin status
*/
bool EPD_IsBusy(void) {
	return eink_lcd_busy();
}

/**
* \brief Configure GPIO
*/
void EPD_initialize_gpio(void) {
	//config_gpio_dir_i( EPD_BUSY_PIN);
	//config_gpio_dir_o( EPD_CS_PIN);
	//config_gpio_dir_o( EPD_RST_PIN);
	//config_gpio_dir_o( EPD_PANELON_PIN);
	//config_gpio_dir_o( EPD_DISCHARGE_PIN);
	//config_gpio_dir_o( EPD_BORDER_PIN);
	//config_gpio_dir_o( Flash_CS_PIN);
	//config_gpio_dir_i( Temper_PIN);
	EPD_flash_cs_high();
	EPD_border_low();
}




/**
* \brief Initialize the EPD hardware setting
*/
void EPD_display_hardware_init (void) {
	EPD_initialize_gpio();
	EPD_Vcc_turn_off();
	//epd_spi_init();
	initialize_temperature();
	//EPD_cs_low();
	EPD_pwm_low();
	EPD_rst_low();
	EPD_discharge_low();
	EPD_border_low();
	//initialize_EPD_timer();
}



/**
* \brief Initialize the EPD hardware setting
*/
void EPD_init(void) {
	EPD_display_hardware_init();
	EPD_cs_low();
	EPD_rst_low();
	EPD_discharge_low();
	EPD_border_low();
}

/**
* \brief Select the EPD size to get line data array for driving COG
*
* \param EPD_type_index The defined EPD size
*/
void COG_driver_EPDtype_select(uint8_t EPD_type_index) {
	switch(EPD_type_index) {
		case EPD_144:
		data_line_even = &COG_Line.line_data_by_size.line_data_for_144.even[0];
		data_line_odd  = &COG_Line.line_data_by_size.line_data_for_144.odd[0];
		data_line_scan = &COG_Line.line_data_by_size.line_data_for_144.scan[0];
		data_line_border_byte = &COG_Line.line_data_by_size.line_data_for_144.border_byte;
		break;
		case EPD_200:
		data_line_even = &COG_Line.line_data_by_size.line_data_for_200.even[0];
		data_line_odd  = &COG_Line.line_data_by_size.line_data_for_200.odd[0];
		data_line_scan = &COG_Line.line_data_by_size.line_data_for_200.scan[0];
		data_line_border_byte = &COG_Line.line_data_by_size.line_data_for_200.border_byte;
		break;
		case EPD_270:
		data_line_even = &COG_Line.line_data_by_size.line_data_for_270.even[0];
		data_line_odd  = &COG_Line.line_data_by_size.line_data_for_270.odd[0];
		data_line_scan = &COG_Line.line_data_by_size.line_data_for_270.scan[0];
		data_line_border_byte = &COG_Line.line_data_by_size.line_data_for_270.border_byte;
		break;
	}
}

/**
* \brief Power on COG Driver
* \note For detailed flow and description, please refer to the COG G2 document Section 3.
*/
void EPD_power_on (void) {	
	//epd_spi_init_2M();
	/* Initial state */
	EPD_Vcc_turn_on(); //Vcc and Vdd >= 2.7V	
	EPD_cs_high();
	EPD_border_high();
	EPD_rst_high();
	local_delay_ms(5);	
	EPD_rst_low();
	local_delay_ms(5);
	EPD_rst_high();
	local_delay_ms(5);
}

void epd_spi_send_byte(uint8_t register_index, uint8_t register_data) 
{
	eink_write(register_index, register_data);
}
/**
* \brief Initialize COG Driver
* \note For detailed flow and description, please refer to the COG G2 document Section 4.
*
* \param EPD_type_index The defined EPD size
*/
uint8_t EPD_initialize_driver (uint8_t EPD_type_index) {
	
	uint16_t i;
	// Empty the Line buffer
	//for (i = 0; i < LINE_BUFFER_DATA_SIZE; i ++) {
	//	COG_Line.uint8[i] = 0x00;
	//}
	memset(COG_Line.uint8, 0x00, sizeof COG_Line.uint8);
	// Determine the EPD size for driving COG
	COG_driver_EPDtype_select(EPD_type_index);

	// Sense temperature to determine Temperature Factor
	set_temperature_factor(EPD_type_index);
	i = 0;
	
	while (EPD_IsBusy()) {
		if ((i++) >= 0x0FFF) return ERROR_BUSY;
	}
	
	//Check COG ID
	if ((SPI_R(0x72,0x00) & 0x0f) !=0x02) return ERROR_COG_ID;

	//Disable OE
	epd_spi_send_byte(0x02,0x40);	

	//Check Breakage
	if ((SPI_R(0x0F,0x00) & 0x80) != 0x80) return ERROR_BREAKAGE;
	
	//Power Saving Mode
 	epd_spi_send_byte(0x0B, 0x02);

	//Channel Select
	epd_spi_send (0x01, COG_parameters[EPD_type_index].channel_select, 8);

	//High Power Mode Osc Setting
	epd_spi_send_byte(0x07,0xD1);

	//Power Setting
	epd_spi_send_byte(0x08,0x02);

	//Set Vcom level
	epd_spi_send_byte(0x09,0xC2);

	//Power Setting
	epd_spi_send_byte(0x04,0x03);

	//Driver latch on
	epd_spi_send_byte(0x03,0x01);

	//Driver latch off
	epd_spi_send_byte(0x03,0x00);

	local_delay_ms(5);

	//Chargepump Start
	i=0;
	do {
		//Start chargepump positive V
		//VGH & VDH on
		epd_spi_send_byte(0x05,0x01);

		local_delay_ms_spool(240);

		//Start chargepump neg voltage
		//VGL & VDL on
		epd_spi_send_byte(0x05,0x03);

		local_delay_ms_spool(40);

		//Set chargepump
		//Vcom_Driver to ON
		//Vcom_Driver on
		epd_spi_send_byte(0x05,0x0F);

		local_delay_ms_spool(40);

		//Check DC/DC
		if ((SPI_R(0x0F,0x00) & 0x40) != 0x00) break;	
		
	}while((i++) != 4);
	
	if (i>=4) 
	{
		//Output enable to disable
		epd_spi_send_byte(0x02,0x40);
		return ERROR_CHARGEPUMP;
	}
	else  return RES_OK;
}

/**
* \brief Initialize the parameters of Block type stage 
*
* \param EPD_type_index The defined EPD size
* \param EPD_V230_G2_Struct The Block type waveform structure
* \param block_size The width of Block size
* \param step_size The width of Step size
* \param frame_cycle The width of Step size
*/
void stage_init(uint8_t EPD_type_index,struct EPD_V230_G2_Struct *S_epd_v230,
				uint8_t block_size,uint8_t step_size,
				uint8_t frame_cycle)
{
	S_epd_v230->frame_y0 = 0;
	S_epd_v230->frame_y1 = 176;
	S_epd_v230->block_y0 = 0;
	S_epd_v230->block_y1 = 0;
	S_epd_v230->step_y0 = 0;
	S_epd_v230->step_y1 = 0;
	S_epd_v230->block_size = action__Waveform_param->stage1_block1;
	S_epd_v230->step_size =action__Waveform_param->stage1_step1;
	S_epd_v230->frame_cycle = action__Waveform_param->stage1_frame1;
	S_epd_v230->number_of_steps = (COG_parameters[EPD_type_index].vertical_size / S_epd_v230->step_size) + (action__Waveform_param->stage1_block1 / action__Waveform_param->stage1_step1) -1;
	
}

static int EPD_timer;
static void start_EPD_timer(void)
{
	EPD_timer = 0;
}
static void stop_EPD_timer(void)
{

}
static uint32_t get_current_time_tick(void)
{
	return EPD_timer += 50;
}

/**
* \brief For Frame type waveform to update all black/white pattern
*
* \param EPD_type_index The defined EPD size
* \param bwdata Black or White color to whole screen
* \param work_time The working time
*/
static inline void same_data_frame (uint8_t EPD_type_index, uint8_t bwdata, uint32_t work_time) {
	uint16_t i;
	for (i = 0; i <  COG_parameters[EPD_type_index].horizontal_size; i++) {
		data_line_even[i]=bwdata;
		data_line_odd[i]=bwdata;
	}
	start_EPD_timer();
	do 
	{	
		for (i = 0; i < COG_parameters[EPD_type_index].vertical_size; i++) {
			
			/* Scan byte shift per data line */
			data_line_scan[(i>>2)]=SCAN_TABLE[(i%4)];
			
			/* Sending data */
			epd_spi_send (0x0A, (uint8_t *)&COG_Line.uint8, COG_parameters[EPD_type_index].data_line_size);
		 
			/* Turn on Output Enable */
			epd_spi_send_byte(0x02, 0x07);
		
			data_line_scan[(i>>2)]=0;
			
		}
	} while (get_current_time_tick()<work_time);
		/* Stop system timer */
	stop_EPD_timer();
}

/**
* \brief Write nothing Line to COG
* \note A line whose all Scan Bytes are 0x00
*
* \param EPD_type_index The defined EPD size
*/
void nothing_line(uint8_t EPD_type_index) {
	uint16_t i;
	for (i = 0; i <  COG_parameters[EPD_type_index].horizontal_size; i++) {
		data_line_even[i]	=	NOTHING;
		data_line_odd[i]	=	NOTHING;
	}
}


/**
* \brief Get line data of Stage 1 and 3
*
* \note
* - One dot/pixel is comprised of 2 bits which are White(10), Black(11) or Nothing(01).
*   The image data bytes must be divided into Odd and Even bytes.
* - The COG driver uses a buffer to write one line of data (FIFO) - interlaced
*   It's different order from COG_G1
*   Odd byte {D(199,y),D(197,y), D(195,y), D(193,y)}, ... ,{D(7,y),D(5,y),D(3,y), D(1,y)}
*   Scan byte {S(96), S(95)...}
*   Odd byte  {D(2,y),D(4,y), D(6,y), D(8,y)}, ... ,{D(194,y),D(196,y),D(198,y), D(200,y)}
* - For more details on the driving stages, please refer to the COG G2 document Section 5.
*
* \param EPD_type_index The defined EPD size
* \param image_ptr The pointer of memory that stores image that will send to COG
* \param stage_no The assigned stage number that will proceed
*/
void read_line_data_handle(uint8_t EPD_type_index, const uint8_t *image_ptr,uint8_t stage_no)
{
	int16_t x,y,k;
	uint8_t	temp_byte; // Temporary storage for image data check
	k=COG_parameters[EPD_type_index].horizontal_size-1;	
	for (x =0 ; x < COG_parameters[EPD_type_index].horizontal_size ; x++) {
				temp_byte = *image_ptr++;				
				switch(stage_no) {
					case Stage1: // Inverse image
					/* Example at stage 1 to get Even and Odd data. It's different order from G1.
					* +---------+----+----+----+----+----+----+----+----+
					* |         |bit7|bit6|bit5|bit4|bit3|bit2|bit1|bit0|
					* |temp_byte+----+----+----+----+----+----+----+----+
					* |         |  1 |  0 |  1 |  1 |  0 |  1 |  0 |  0 |
					* +---------+----+----+----+----+----+----+----+----+ */
					data_line_odd[x]       = ((temp_byte & 0x40) ? BLACK3  : WHITE3); // WHITE3 = 0x80 = 1000 0000
					data_line_odd[x]      |= ((temp_byte & 0x10) ? BLACK2  : WHITE2); // BLACK2 = 0x30 = 0011 0000
					data_line_odd[x]      |= ((temp_byte & 0x04) ? BLACK1  : WHITE1); // BLACK1 = 0x0C = 0000 1100
					data_line_odd[x]	  |= ((temp_byte & 0x01) ? BLACK0  : WHITE0); // WHITE0 = 0x02 = 0000 0010
					/* data_line_odd[x] = 1000 0000 | 0011 0000 | 0000 1100 | 0000 0010 = 1011 1110 ==> 1011 1110
					* See Even data row at the table below*/
					
					data_line_even[k]    = ((temp_byte & 0x80) ? BLACK0  : WHITE0); // BLACK0 = 0x03 = 0000 0011
					data_line_even[k]   |= ((temp_byte & 0x20) ? BLACK1  : WHITE1); // BLACK1 = 0x0C = 0000 1100
					data_line_even[k]   |= ((temp_byte & 0x08) ? BLACK2  : WHITE2); // WHITE2 = 0x20 = 0010 0000
					data_line_even[k--] |= ((temp_byte & 0x02) ? BLACK3  : WHITE3); // WHITE3 = 0x80 = 1000 0000
					/* data_line_even[k] = 0000 0011 | 0000 1100 | 0010 0000 | 1000 0000 = 1010 1111 ==> 1111 1010
					* See Odd data row at the table below
					* +---------+----+----+----+----+----+----+----+----+
					* |         |bit7|bit6|bit5|bit4|bit3|bit2|bit1|bit0|
					* |temp_byte+----+----+----+----+----+----+----+----+
					* |         |  1 |  0 |  1 |  1 |  0 |  1 |  0 |  0 |
					* +---------+----+----+----+----+----+----+----+----+
					* | Color   |  W |  B |  W |  W |  B |  W |  B |  B | W=White, B=Black, N=Nothing
					* +---------+----+----+----+----+----+----+----+----+
					* | Stage 1 |  B |  W |  B |  B |  W |  B |  W |  W | Inverse
					* +---------+----+----+----+----+----+----+----+----+
					* | Input   | 11 | 10 | 11 | 11 | 10 | 11 | 10 | 10 | W=10, B=11, N=01
					* +---------+----+----+----+----+----+----+----+----+
					* |Even data| 11 |    | 11 |    | 10 |    | 10 |    | = 1111 1010
					* +---------+----+----+----+----+----+----+----+----+
					* |Odd data |    | 10 |    | 11 |    | 11 |    | 10 | = 1011 1110
					* +---------+----+----+----+----+----+----+----+----+ */
					break;				
					case Stage3: // New image
						data_line_odd[x]		 = ((temp_byte & 0x40) ? WHITE3  : BLACK3 );
						data_line_odd[x]		|= ((temp_byte & 0x10) ? WHITE2  : BLACK2 );
						data_line_odd[x]		|= ((temp_byte & 0x04) ? WHITE1  : BLACK1 );
						data_line_odd[x]		|= ((temp_byte & 0x01) ? WHITE0  : BLACK0 );

						data_line_even[k]		 = ((temp_byte & 0x80) ? WHITE0  : BLACK0 );
						data_line_even[k]		|= ((temp_byte & 0x20) ? WHITE1  : BLACK1 );
						data_line_even[k]		|= ((temp_byte & 0x08) ? WHITE2  : BLACK2 );
						data_line_even[k--]		|= ((temp_byte & 0x02) ? WHITE3  : BLACK3 );
					break;
				}
		}	
}


/**
* \brief The base function to handle the driving stages for Frame and Block type
*
* \note
* - There are 3 stages to complete an image update on COG_V230_G2 type EPD.
* - For more details on the driving stages, please refer to the COG G2 document Section 5.4
*
* \param EPD_type_index The defined EPD size
* \param image_ptr The pointer of image array that stores image that will send to COG
* \param image_data_address The address of memory that stores image
* \param stage_no The assigned stage number that will proceed
* \param lineoffset Line data offset
*/
void stage_handle_Base(uint8_t EPD_type_index, const uint8_t *image_ptr,long image_data_address,
						uint8_t stage_no,uint8_t lineoffset)
{	
	struct EPD_V230_G2_Struct S_epd_v230;
	uint16_t cycle,m,i; //m=number of steps
	uint8_t isLastframe = 0;	//If it is the last frame to send Nothing at the fist scan line
	uint8_t isLastBlock=0;		//If the beginning line of block is in active range of EPD
	//uint8_t isScanOn=0;
	long action_block_address;
	uint32_t line_time=8;
	uint8_t byte_array[LINE_BUFFER_DATA_SIZE];
	
	debug_printf_P(PSTR("stage_handle_Base: 1\n"));
								/** Stage 2: BLACK/WHITE image, Frame type */
	if (stage_no==Stage2)
	{
		for(i=0;i<action__Waveform_param->stage2_cycle;i++)
		{
			same_data_frame (EPD_type_index,ALL_BLACK,action__Waveform_param->stage2_t1);
			same_data_frame (EPD_type_index,ALL_WHITE,action__Waveform_param->stage2_t2);
		}
		return;
	}
	debug_printf_P(PSTR("stage_handle_Base: 2\n"));
	/** Stage 1 & 3, Block type */
	// The frame/block/step of Stage1 and Stage3 are default the same.
	stage_init(EPD_type_index,
				&S_epd_v230,
				action__Waveform_param->stage1_block1,
				action__Waveform_param->stage1_step1,
				action__Waveform_param->stage1_frame1);
	debug_printf_P(PSTR("stage_handle_Base: 3\n"));
	 /* Repeat number of frames */
   	 for (cycle = 0; cycle < (S_epd_v230.frame_cycle ); cycle++)
   	 {
	     if (cycle == (S_epd_v230.frame_cycle - 1)) isLastframe = 1;
		 
		 isLastBlock = 0;
		 
		 /* Move number of steps */
	   	 for (m = 0; m < S_epd_v230.number_of_steps; m++)	 
	   	 {
		   	 S_epd_v230.step_y0 = (S_epd_v230.step_size * m) + S_epd_v230.frame_y0;
		   	 S_epd_v230.step_y1 = (S_epd_v230.step_size * (m + 1)) + S_epd_v230.frame_y0;
		   	 S_epd_v230.block_y0 = S_epd_v230.step_y1 - S_epd_v230.block_size;
		   	 S_epd_v230.block_y1 = S_epd_v230.step_y1;
			
			/* reset block_y0=frame_y0 if block is not in active range of EPD */
		   	 if (S_epd_v230.block_y0 < S_epd_v230.frame_y0) S_epd_v230.block_y0 = S_epd_v230.frame_y0;
			
			/* if the beginning line of block is in active range of EPD */
			 if (S_epd_v230.block_y1 == S_epd_v230.block_size) 
				 isLastBlock = 1;
			 	
			const uint8_t *action_block_ptr;
			 if (image_ptr != NULL)
			 {
				 action_block_ptr = (image_ptr + (int) (S_epd_v230.block_y0 * lineoffset));	
			 }
			 else if (_On_EPD_read_flash!=NULL)	//Read line data in range of block, read first
			 {
				action_block_address = image_data_address+(int)(S_epd_v230.block_y0*lineoffset);
				_On_EPD_read_flash(action_block_address,(uint8_t *)&byte_array,
									COG_parameters[EPD_type_index].horizontal_size);
				action_block_ptr=byte_array;
			 }
			
			/* Update line data */
		   	 for (i = S_epd_v230.block_y0; i < S_epd_v230.block_y1; i++)
		   	 {
				if (i >= COG_parameters[EPD_type_index].vertical_size) 
				 break;
				if (  isLastBlock &&(i < (S_epd_v230.step_size + S_epd_v230.block_y0)))//isLastframe &&
				{
				  nothing_line(EPD_type_index);					
				}
				else	 
				{		
				  // Get line data of Stage 1 and 3
				  read_line_data_handle(EPD_type_index,action_block_ptr,stage_no);					
				}
			   		
				if (_On_EPD_read_flash!=NULL)	//Read line data in range of block
				{
					action_block_address += lineoffset;
					_On_EPD_read_flash(action_block_address,(uint8_t *)&byte_array,
					COG_parameters[EPD_type_index].horizontal_size);
					action_block_ptr=byte_array;
				}
				else 	
					action_block_ptr+=lineoffset;
				
				const int16_t scanline_no = (COG_parameters[EPD_type_index].vertical_size-1)-i;
				
				/* Scan byte shift per data line */
				data_line_scan[(scanline_no / 4)] = SCAN_TABLE[(scanline_no % 4)];
			   
				/*  the border uses the internal signal control byte. */
				*data_line_border_byte=0x00;
				   
				/* Sending data */
				epd_spi_send(0x0A, COG_Line.uint8, COG_parameters[EPD_type_index].data_line_size);
				
				 
				/* Turn on Output Enable */
				epd_spi_send_byte(0x02, 0x07);
				   
				data_line_scan[(scanline_no>>2)]=0;

				check_poweroff();
		   	 }
		check_poweroff();
	   	 }
   	 }		
	debug_printf_P(PSTR("stage_handle_Base: 4\n"));
}

/**
* \brief The driving stages from image array (image_data.h) to COG
*
* \param EPD_type_index The defined EPD size
* \param image_ptr The pointer of image array that stores image that will send to COG
* \param stage_no The assigned stage number that will proceed
* \param lineoffset Line data offset
*/
void stage_handle(uint8_t EPD_type_index, const uint8_t *image_ptr,uint8_t stage_no,uint8_t lineoffset)
{
	stage_handle_Base(EPD_type_index,image_ptr,ADDRESS_NULL,stage_no,lineoffset);	
}

/**
* \brief The driving stages from memory to COG
*
* \note
* - This function is additional added here for developer if the image data
*   is stored in Flash memory.
*
* \param EPD_type_index The defined EPD size
* \param image_data_address The address of flash memory that stores image
* \param stage_no The assigned stage number that will proceed
* \param lineoffset Line data offset
*/
static void stage_handle_ex(uint8_t EPD_type_index,long image_data_address,uint8_t stage_no,uint8_t lineoffset) {
	stage_handle_Base(EPD_type_index,NULL,image_data_address,stage_no,lineoffset);	
}

/**
* \brief Write image data from memory array (image_data.h) to the EPD
*
* \param EPD_type_index The defined EPD size
* \param previous_image_ptr The pointer of memory that stores previous image
* \param new_image_ptr The pointer of memory that stores new image
*/
void EPD_display_from_array_ptr (
	uint8_t EPD_type_index, 
	const uint8_t *previous_image_ptr,
	const uint8_t *new_image_ptr) 
{	
	_On_EPD_read_flash=NULL;		

	debug_printf_P(PSTR("EPD_display_from_array_ptr: 1\n"));
	stage_handle(EPD_type_index,new_image_ptr,Stage1,COG_parameters[EPD_type_index].horizontal_size);	
	debug_printf_P(PSTR("EPD_display_from_array_ptr: 2\n"));
	stage_handle(EPD_type_index,new_image_ptr,Stage2,COG_parameters[EPD_type_index].horizontal_size);	
	debug_printf_P(PSTR("EPD_display_from_array_ptr: 3\n"));
	stage_handle(EPD_type_index,new_image_ptr,Stage3,COG_parameters[EPD_type_index].horizontal_size);	
	debug_printf_P(PSTR("EPD_display_from_array_ptr: 4\n"));
}

/**
* \brief Write image data from Flash memory to the EPD
* \note This function is additional added here for developer if the image data
* is stored in Flash.
*
* \param EPD_type_index The defined EPD size
* \param previous_image_flash_address The start address of memory that stores previous image
* \param new_image_flash_address The start address of memory that stores new image
* \param On_EPD_read_flash Developer needs to create an external function to read flash
*/
void EPD_display_from_flash_prt (uint8_t EPD_type_index, long previous_image_flash_address,
    long new_image_flash_address,EPD_read_flash_handler On_EPD_read_flash) {
		
	uint8_t line_len=LINE_SIZE;
	if (line_len==0) line_len=COG_parameters[EPD_type_index].horizontal_size;
		
	_On_EPD_read_flash=On_EPD_read_flash;	
	stage_handle_ex(EPD_type_index,new_image_flash_address,Stage1,line_len);
	stage_handle_ex(EPD_type_index,new_image_flash_address,Stage2,line_len);
	stage_handle_ex(EPD_type_index,new_image_flash_address,Stage3,line_len);	
}


/**
* \brief Write Dummy Line to COG
* \note A line whose all Scan Bytes are 0x00
*
* \param EPD_type_index The defined EPD size
*/
static inline void dummy_line(uint8_t EPD_type_index) {
	uint8_t	i;
	for (i = 0; i < (COG_parameters[EPD_type_index].vertical_size/8); i++) {
		switch(EPD_type_index) {
			case EPD_144:
			COG_Line.line_data_by_size.line_data_for_144.scan[i]=0x00;
			break;
			case EPD_200:
			COG_Line.line_data_by_size.line_data_for_200.scan[i]=0x00;
			break;
			case EPD_270:
			COG_Line.line_data_by_size.line_data_for_270.scan[i]=0x00;
			break;
		}
	}
	/* Set charge pump voltage level reduce voltage shift */
	epd_spi_send_byte(0x04, COG_parameters[EPD_type_index].voltage_level);
	
	/* Sending data */
	epd_spi_send (0x0A, (uint8_t *)&COG_Line.uint8, COG_parameters[EPD_type_index].data_line_size);

	/* Turn on Output Enable */
	epd_spi_send_byte(0x02, 0x07);
}


/**
* \brief Write Border(Input) Dummy Line
* \note Set Border byte 0xFF to write Black and set 0xAA to write White
*
* \param EPD_type_index The defined EPD size
*/
static void border_dummy_line(uint8_t EPD_type_index)
{
	uint16_t	i;
	for (i = 0; i < COG_parameters[EPD_type_index].data_line_size; i++)
	{
		COG_Line.uint8[i] = 0x00;
	}
	
	*data_line_border_byte=BORDER_BYTE_B;
	//Write a Border(B) Dummy Line
	epd_spi_send (0x0a, (uint8_t *)&COG_Line.uint8, COG_parameters[EPD_type_index].data_line_size);
	//Turn on OE
	epd_spi_send_byte(0x02, 0x07);
	
	local_delay_ms_spool(40);
	
	*data_line_border_byte=BORDER_BYTE_W;
	//Write a Borde(B) Dummy Line
	epd_spi_send (0x0a, (uint8_t *)&COG_Line.uint8, COG_parameters[EPD_type_index].data_line_size);
	//Turn on OE
	epd_spi_send_byte(0x02, 0x07);

	local_delay_ms_spool(200);
	
	
}


/**
* \brief Power Off COG Driver
* \note For detailed flow and description, please refer to the COG G2 document Section 6.
*
* \param EPD_type_index The defined EPD size
*/
uint8_t EPD_power_off (uint8_t EPD_type_index) {

	if (EPD_type_index==EPD_144 || EPD_type_index==EPD_200) 	{
		border_dummy_line(EPD_type_index);
		dummy_line(EPD_type_index);
	}

	local_delay_ms_spool (25);
	if (EPD_type_index==EPD_270)	{
		EPD_border_low();
		local_delay_ms_spool (200);
		EPD_border_high();
	}
	//Check DC/DC
	if ((SPI_R(0x0F,0x00) & 0x40) == 0x00) return ERROR_DC;
	// Latch reset turn on
	epd_spi_send_byte(0x03, 0x01);
	
	// Output enable off
	epd_spi_send_byte(0x02, 0x05);
	
	// Power off charge pump Vcom
	epd_spi_send_byte(0x05, 0x0E);
	
	// Power off charge negative voltage
	epd_spi_send_byte(0x05, 0x02);
	
	// Discharge
	epd_spi_send_byte(0x04, 0x0C);
	local_delay_ms_spool (120);
	
	// Turn off all charge pumps
	epd_spi_send_byte(0x05, 0x00);
	
	// Turn off osc
	epd_spi_send_byte(0x07, 0x0D);
	
	// Discharge internal
	epd_spi_send_byte(0x04, 0x50);
	local_delay_ms_spool (40);
	
	// Discharge internal
	epd_spi_send_byte(0x04, 0xA0);
	local_delay_ms_spool (40);
	
	// Discharge internal
	epd_spi_send_byte(0x04, 0x00);
	
	// Set power and signals = 0
	EPD_rst_low ();
	////epd_spi_detach ();
	////EPD_cs_low ();
	EPD_Vcc_turn_off ();
	EPD_border_low();
	
	// External discharge = 1
	EPD_discharge_high ();
	local_delay_ms_spool (150);
	
	// External discharge = 0
	EPD_discharge_low ();
	
	return RES_OK;
}

/**
* \brief Power Off COG Driver
* \note For detailed flow and description, please refer to the COG G2 document Section 6.
*
* \param EPD_type_index The defined EPD size
*/
uint8_t EPD_power_off2 (uint8_t EPD_type_index) {
	uint8_t y;		

	if (EPD_type_index==EPD_144 || EPD_type_index==EPD_200) 	{
		border_dummy_line(EPD_type_index);
		dummy_line(EPD_type_index);
	}

	local_delay_ms_spool (25);
	if (EPD_type_index==EPD_270)	{
		EPD_border_low();
		local_delay_ms_spool (200);
		EPD_border_high();
	}

	//Check DC/DC
	if ((SPI_R(0x0F,0x00) & 0x40) == 0x00) return ERROR_DC;
	
	//Turn on Latch Reset
	epd_spi_send_byte(0x03, 0x01);
	//Turn off OE
	epd_spi_send_byte(0x02, 0x05);
	//Power off charge pump Vcom
	epd_spi_send_byte(0x05, 0x03);
	//Power off charge pump neg voltage
	epd_spi_send_byte(0x05, 0x01);
	local_delay_ms_spool(250);
	//Turn off all charge pump 
	epd_spi_send_byte(0x05, 0x00);
	local_delay_ms_spool(300);
	//Turn off OSC
	epd_spi_send_byte(0x07, 0x05);
	
	////epd_spi_detach ();
	////EPD_cs_low();
	EPD_rst_low();
	EPD_Vcc_turn_off ();
	EPD_border_low();
	local_delay_ms_spool (10);
		
	for(y=0;y<10;y++)
	{
		EPD_discharge_high ();		
		local_delay_ms_spool (10);		
		EPD_discharge_low ();	
		local_delay_ms_spool (10);	
	}
	return RES_OK;
}

#endif /* COG_V230_G2 */

/**
 * \brief Initialize the EPD hardware setting 
 */
void EPD_display_init(void) {
	EPD_init();
}

/**
 * \brief Show image from the pointer of memory array
 *
 * \param EPD_type_index The defined EPD size
 * \param previous_image_ptr The pointer of memory that stores previous image
 * \param new_image_ptr The pointer of memory that stores new image
 */
void EPD_display_from_pointer(
	uint8_t EPD_type_index, 
	const uint8_t *previous_image_ptr,
	const uint8_t *new_image_ptr) {
	/* Initialize EPD hardware */
	debug_printf_P(PSTR("EPD_display_from_pointer: 1\n"));
	EPD_init();
	
	/* Power on COG Driver */
	debug_printf_P(PSTR("EPD_display_from_pointer: 2\n"));
	EPD_power_on();
	
	/* Initialize COG Driver */
	debug_printf_P(PSTR("EPD_display_from_pointer: 3\n"));
	EPD_initialize_driver(EPD_type_index);
	
	/* Display image data on EPD from image array */
	debug_printf_P(PSTR("EPD_display_from_pointer: 4\n"));
	EPD_display_from_array_ptr(EPD_type_index,previous_image_ptr,new_image_ptr);
	
	/* Power off COG Driver */
	debug_printf_P(PSTR("EPD_display_from_pointer: 5\n"));
	EPD_power_off (EPD_type_index);
	debug_printf_P(PSTR("EPD_display_from_pointer: 6\n"));
}

/**
 * \brief Show image from Flash memory
 *
 * \param EPD_type_index The defined EPD size
 * \param previous_image_address The address of memory that stores previous image
 * \param new_image_address The address of memory that stores new image
 * \param On_EPD_read_flash Developer needs to create an external function to read flash
 */
void EPD_display_from_flash(uint8_t EPD_type_index,long previous_image_address,
long new_image_address,EPD_read_flash_handler On_EPD_read_flash) {
	/* Initialize EPD hardware */
	EPD_init();
	
	/* Power on COG Driver */
	EPD_power_on();
	
	/* Initialize COG Driver */
	EPD_initialize_driver(EPD_type_index);
	
	/* Display image data on EPD from Flash memory */
	EPD_display_from_flash_prt(EPD_type_index,previous_image_address,
	    new_image_address,On_EPD_read_flash);
	
	/* Power off COG Driver */
	EPD_power_off (EPD_type_index);
}
/**
 * \brief Initialize the EPD hardware setting and COG driver
 *
 * \param EPD_type_index The defined EPD size 
 */
void EPD_power_init(uint8_t EPD_type_index) {
	EPD_init();
	EPD_power_on ();
	EPD_initialize_driver (EPD_type_index);
}

/**
 * \brief Show image from Flash memory when SPI is common used with COG and Flash
 *
 * \note 
 * - This function must work with EPD_power_init when SPI is common used with 
 *   COG and Flash, or the charge pump doesn't work correctly.
 * - EPD_power_init -> write data to flash (switch SPI) -> EPD_display_from_flash_Ex
 *
 * \param EPD_type_index The defined EPD size
 * \param previous_image_address The address of memory that stores previous image
 * \param new_image_address The address of memory that stores new image
 * \param On_EPD_read_flash Developer needs to create an external function to read flash
 */
void EPD_display_from_flash_Ex(uint8_t EPD_type_index,long previous_image_address,
	long new_image_address,EPD_read_flash_handler On_EPD_read_flash) {
	
	/* Display image data on EPD from Flash memory */
	EPD_display_from_flash_prt(EPD_type_index,previous_image_address,
	    new_image_address,On_EPD_read_flash);
	
	/* Power off COG Driver */
	EPD_power_off (EPD_type_index);
}


#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */


#if ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED
// M9546 (PCF8576C) support functions

/**********************************************************************
*
*    Author:		shondll (shondll_yahoo.com)
*    Company:		Olimex Ltd.
*    Date:			07/02/2011
*    File Version:	1.00
*    Description:	LCD 1x9 drtiver
*
**********************************************************************/
//#include "Compiler.h"
//#include "GenericTypeDefs.h"
//#include "LCD1x9.h"
//#include "LCD1x9_mapping.h"

/* DEFINE LOCAL TYPES HERE */

/* DEFINE LOCAL CONSTANTS HERE */
#define LCD1x9_SDA_TRIS TRISCbits.TRISC4
#define LCD1x9_SDA_LAT LATCbits.LATC4
#define LCD1x9_SDA_PORT PORTCbits.RC4

#define LCD1x9_SCL_TRIS TRISCbits.TRISC3
#define LCD1x9_SCL_LAT LATCbits.LATC3
#define LCD1x9_SCL_PORT PORTCbits.RC3

#define LCD1x9_SLAVE_ADDR 0x70

#define ACK 0
#define NACK 1

/**********************************************************************
*
*    Author:		Energy Micro AS
*    Modified for the MOD-LCD1x9 by shondll (shondll_yahoo.com)
*    Company:		Olimex Ltd.
*    Date:		07/02/2011
*    File Version:	1.00
*    Description:	LCD mapping and font
*
**********************************************************************/

/**************************************************************************//**
 * @brief
 * Defines each text symbol's segment in terms of COM and BIT numbers,
 * in a way that we can enumerate each bit for each text segment in the
 * following bit pattern:
 * @verbatim
 *  -------0------
 *
 * |   \7  |8  /9 |
 * |5   \  |  /   |1
 *
 *  --6---  ---10--
 *
 * |    /  |  \11 |
 * |4  /13 |12 \  |2
 *
 *  -------3------  .(14)
 *  ------15------
 *
 * @endverbatim
 * E.g.: First text character bit pattern #3 (above) is
 *  Segment 1D for Display
 *  Location COM 3, BIT 0
 *****************************************************************************/
typedef struct
{
  uint8_t com[16]; /**< LCD COM line (for multiplexing) */
  uint8_t bit[16]; /**< LCD bit number */
} CHAR_TypeDef;

/**************************************************************************//**
 * @brief Defines prototype for all segments in display
 *****************************************************************************/
typedef struct
{
  CHAR_TypeDef			Text[9];
} MCU_DISPLAY;

/**************************************************************************//**
 * @brief Working instance of LCD display
 *****************************************************************************/
static const FLASHMEM MCU_DISPLAY LCD1x9 = {
  {
    { /* 1 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{  34 - 0,  32 - 0,  32 - 0,  34 - 0,  35 - 0,  35 - 0,  34 - 0,  35 - 0,  33 - 0,  33 - 0,  32 - 0,  32 - 0,  33 - 0,  34 - 0,  33 - 0,  35 - 0}  // bit    
    },
    { /* 2 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{  34 - 4,  32 - 4,  32 - 4,  34 - 4,  35 - 4,  35 - 4,  34 - 4,  35 - 4,  33 - 4,  33 - 4,  32 - 4,  32 - 4,  33 - 4,  34 - 4,  33 - 4,  35 - 4}  // bit    
    },
    { /* 3 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{  34 - 8,  32 - 8,  32 - 8,  34 - 8,  35 - 8,  35 - 8,  34 - 8,  35 - 8,  33 - 8,  33 - 8,  32 - 8,  32 - 8,  33 - 8,  34 - 8,  33 - 8,  35 - 8}  // bit    
    },
    { /* 4 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{ 34 - 12, 32 - 12, 32 - 12, 34 - 12, 35 - 12, 35 - 12, 34 - 12, 35 - 12, 33 - 12, 33 - 12, 32 - 12, 32 - 12, 33 - 12, 34 - 12, 33 - 12, 35 - 12}  // bit    
    },
    { /* 5 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{ 34 - 16, 32 - 16, 32 - 16, 34 - 16, 35 - 16, 35 - 16, 34 - 16, 35 - 16, 33 - 16, 33 - 16, 32 - 16, 32 - 16, 33 - 16, 34 - 16, 33 - 16, 35 - 16}  // bit    
    },
    { /* 6 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{ 34 - 20, 32 - 20, 32 - 20, 34 - 20, 35 - 20, 35 - 20, 34 - 20, 35 - 20, 33 - 20, 33 - 20, 32 - 20, 32 - 20, 33 - 20, 34 - 20, 33 - 20, 35 - 20}  // bit    
    },
    { /* 7 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{ 34 - 24, 32 - 24, 32 - 24, 34 - 24, 35 - 24, 35 - 24, 34 - 24, 35 - 24, 33 - 24, 33 - 24, 32 - 24, 32 - 24, 33 - 24, 34 - 24, 33 - 24, 35 - 24}  // bit    
    },
    { /* 8 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{ 34 - 28, 32 - 28, 32 - 28, 34 - 28, 35 - 28, 35 - 28, 34 - 28, 35 - 28, 33 - 28, 33 - 28, 32 - 28, 32 - 28, 33 - 28, 34 - 28, 33 - 28, 35 - 28}  // bit    
    },
    { /* 9 */
	{       3,       3,       0,       0,       2,       1,       1,       3,       1,       3,       1,       2,       2,       2,       0,       0}, // com
	{ 34 - 32, 32 - 32, 32 - 32, 34 - 32, 35 - 32, 35 - 32, 34 - 32, 35 - 32, 33 - 32, 33 - 32, 32 - 32, 32 - 32, 33 - 32, 34 - 32, 33 - 32, 35 - 32}  // bit    
    }
  }
};

/**************************************************************************//**
 * @brief
 * Defines higlighted segments for the alphabet, starting from "blank" (SPACE)
 * Uses bit pattern as defined for text segments above.
 * E.g. a capital O, would have bits 0 1 2 3 4 5 => 0x003f defined
 *****************************************************************************/
static const FLASHMEM uint16_t LCDAlphabet[] = {
  0x0000, /* space */
  0x1100, /* ! */
  0x0280, /* " */
  0x0000, /* # */
  0x0000, /* $ */
  0x0000, /* % */
  0x0000, /* & */
  0x0000, /* ? */
  0x0039, /* ( */
  0x000f, /* ) */
  0x0463, /* * ->> modified to a degree symbol */ 
  0x1540, /* + */
  0x0000, /* , */
  0x0440, /* - */
  0x1000, /* . */
  0x2200, /* / */

  0x003f, /* 0 */
  0x0006, /* 1 */
  0x045b, /* 2 */
  0x044f, /* 3 */
  0x0466, /* 4 */
  0x046d, /* 5 */
  0x047d, /* 6 */
  0x0007, /* 7 */
  0x047f, /* 8 */
  0x046f, /* 9 */

  0x0000, /* : */
  0x0000, /* ; */
  0x0a00, /* < */
  0x0000, /* = */
  0x2080, /* > */
  0x0000, /* ? */
  0xffff, /* @ */

  0x0477, /* A */
  0x0a79, /* B */
  0x0039, /* C */
  0x20b0, /* D */
  0x0079, /* E */
  0x0071, /* F */
  0x047d, /* G */
  0x0476, /* H */
//  0x0006, /* I */
  0x0030, /* I edit */
  0x000e, /* J */
  0x0a70, /* K */
  0x0038, /* L */
  0x02b6, /* M */
  0x08b6, /* N */
  0x003f, /* O */
  0x0473, /* P */
  0x083f, /* Q */
  0x0c73, /* R */
  0x046d, /* S */
  0x1101, /* T */
  0x003e, /* U */
  0x2230, /* V */
  0x2836, /* W */
  0x2a80, /* X */
  0x046e, /* Y */
  0x2209, /* Z */

  0x0039, /* [ */
  0x0880, /* backslash */
  0x000f, /* ] */
  0x0001, /* ^ */
  0x0008, /* _ */
  0x0100, /* ` */

  0x1058, /* a */
  0x047c, /* b */
  0x0058, /* c */
  0x045e, /* d */
  0x2058, /* e */
  0x0471, /* f */
  0x0c0c, /* g */
  0x0474, /* h */
  0x0004, /* i */
  0x000e, /* j */
  0x0c70, /* k */
  0x0038, /* l */
  0x1454, /* m */
  0x0454, /* n */
  0x045c, /* o */
  0x0473, /* p */
  0x0467, /* q */
  0x0450, /* r */
  0x0c08, /* s */
  0x0078, /* t */
  0x001c, /* u */
  0x2010, /* v */
  0x2814, /* w */
  0x2a80, /* x */
  0x080c, /* y */
  0x2048, /* z */

  0x0000,
};


/* DECLARE EXTERNAL VARIABLES HERE */

/* DEFINE LOCAL MACROS HERE */

/* DEFINE LOCAL VARIABLES HERE */
static uint8_t lcdBitmap[20]; // 40segments * 4 = 160px, 160 / 8 = 20bytes

/* DECLARE EXTERNAL VARIABLES HERE */


/* DEFINE FUNCTIONS HERE */

/******************************************************************************
* Description: LCD1x9_Initialize(..) - initializes pins and registers of the LCD1x9
*				Also lights up all segments
* Input: 	none
* Output: 	none
* Return:	0 if sucessfully initialized, -1 if error occured 
*******************************************************************************/
static void LCD1x9_Initialize(void)
{
	int i;

	i2c_start(LCD1x9_SLAVE_ADDR | 0x00);
	i2c_write(0b11001000); // 0xc8 mode register
	i2c_write(0b11110000); // 0xf0 blink register
	i2c_write(0b11100000); // 0xe0 device select register
	i2c_write(0b00000000); // 0x00 pointer register
	
	// light up all the segments, initialize the local display buffer as well
	for(i = 0; i < 20; i++) {
		i2c_write(0x00);
		lcdBitmap[i] = 0; 
	}	
	
	i2c_waitsend();
	i2c_stop();
}


/******************************************************************************
* Description: LCD1x9_enableSegment(..) - enables a segment in the display buffer
*		Note: Does not actually light up the segment, have to call the 'LCD1x9_Update(..)'
* Input: 	comIndex - backplate index
*			bitIndex - segment index
* Output: 	none
* Return:	none
*******************************************************************************/
static void LCD1x9_enableSegment(uint_fast8_t comIndex, uint_fast8_t bitIndex)
{
	if (bitIndex >= 40)
		return;
		
	comIndex &= 0x3;
	
	if (bitIndex & 0x1)
		comIndex |= 0x4;
		
	bitIndex >>= 1;
	
	lcdBitmap[bitIndex] |= 0x80 >> comIndex;
}

/******************************************************************************
* Description: LCD1x9_disableSegment(..) - disables a segment in the display buffer
*		Note: Does not actually lights off the segment, have to call the 'LCD1x9_Update(..)'
* Input: 	comIndex - backplate index
*			bitIndex - segment index
* Output: 	none
* Return:	none
*******************************************************************************/
static void LCD1x9_disableSegment(uint_fast8_t comIndex, uint_fast8_t bitIndex)
{
	if (bitIndex >= 40)
		return;
		
	comIndex &= 0x3;
	
	if (bitIndex & 0x1)
		comIndex |= 0x4;
		
	bitIndex >>= 1;
	
	lcdBitmap[bitIndex] &= ~(0x80 >> comIndex);
}

/******************************************************************************
* Description: LCD1x9_Update(..) - disables a segment in the display buffer
*		Note: Does not actually lights off the segment, have to call the 'LCD1x9_Update(..)'
* Input: 	comIndex - backplate index
*			bitIndex - segment index
* Output: 	none
* Return:	none
*******************************************************************************/
static void LCD1x9_Update(void)
{
	uint_fast8_t i;
	
	i2c_start(LCD1x9_SLAVE_ADDR | 0x00);
	i2c_write(0b11100000); // device select register
	i2c_write(0b00000000); // pointer register
	
	// send the local buffer to the device
	for(i = 0; i < 20; i++)
	{
		check_poweroff();
		i2c_write(lcdBitmap[i]);
	}
		
	i2c_waitsend();
	i2c_stop();
}

/******************************************************************************
* Description: LCD1x9_Write(..) - writes a string to the display
* Input: 	string - the string to write, no more than 9 characters
*			bitIndex - segment index
* Output: 	none
* Return:	none
*******************************************************************************/
static void LCD1x9_Write(const char *string)
{
	uint8_t data, length, index, i;
	uint16_t bitfield;
	uint8_t com, bit;
	
	length = strlen(string);
	if (length > 9)
		return;
	
	index  = 0;
	/* fill out all characters on display */
	for (index = 0; index < 9; index++) {
		if (index < length) {
			data = (uint8_t)string[index];
		} else {
			data = 0x20; // fill with spaces if string is shorter than display
		}

		data -= 0x20;
		bitfield = LCDAlphabet[data];
	
		for (i = 0; i < 16; i++) {
			bit = LCD1x9.Text[index].bit[i];
			com = LCD1x9.Text[index].com[i];
		
			if (bitfield & ((uint16_t)1 << i)) {
				LCD1x9_enableSegment(com, bit);
			} else {
				LCD1x9_disableSegment(com, bit);
			}
		}
	}

	LCD1x9_Update();
}

#define MAXSEGMENT 160
static void LCD1x9_clear(void)
{
	memset(lcdBitmap, 0, sizeof lcdBitmap);
	LCD1x9_Update();
}

static void LCD1x9_seg(int i, uint_fast8_t state)
{
	div_t place = div(i, 4);
	if (state)
		LCD1x9_enableSegment(place.rem, place.quot);
	else
		LCD1x9_disableSegment(place.rem, place.quot);
	LCD1x9_Update();
}

static void lcd_outarray(const uint8_t * a, uint_fast8_t n)
{
	memset(lcdBitmap, 0, sizeof lcdBitmap);
	while (n --)
		LCD1x9_seg(* a ++, 1);
	LCD1x9_Update();
}


static const uint8_t pe2014 [] =
{
	24, 25, 22, 21, 23,	// P
	29, 31, 32, 30, 35,	// E

	56, 57, 53, 54, 59,				// 2
	62, 60, 64, 65, 66, 67,			// 0
	73, 74,							// 1
	76, 77, 81, 82,					// 14

};


#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */

#if 1 && WITHDEBUG && WITHUSEAUDIOREC

struct fb
{
#if _USE_LFN
    char lfn [FF_MAX_LFN + 1];   /* Buffer to store the LFN */
#endif
	FILINFO fno;					/* File information object */
};

void fb_initialize(struct fb * p)
{
	//p->lfnamebuff [0] = '\0';
	//p->fno.lfname = p->lfnamebuff;
    //char *fn;   /* This function is assuming non-Unicode cfg. */
#if 0// _USE_LFN
    ///*static */char lfn[FF_MAX_LFN + 1];   /* Buffer to store the LFN */
    p->fno.lfname = p->lfn;
    p->fno.lfsize = sizeof p->lfn;
#endif
}

static RAMNOINIT_D1 FATFSALIGN_BEGIN uint8_t rbuff [FF_MAX_SS * 256] FATFSALIGN_END;		// буфер записи - при совпадении с _MAX_SS нельзя располагать в Cortex-M4 CCM


static void showprogress(
	unsigned long filepos,
	unsigned long total
	)
{
}

static void printtextfile(const char * filename)
{
	unsigned long filepos = 0;	// количество выданных байтов
	unsigned long fulllength = 0;	// размер файла
	UINT br = 0;		//  количество считанных байтов
	UINT i = 0;			// номер выводимого байта
	
	FRESULT rc;				/* Result code */
	static FATFSALIGN_BEGIN RAMNOINIT_D1 FIL Fil FATFSALIGN_END;			/* Описатель открытого файла - нельзя располагать в Cortex-M4 CCM */
	// чтение файла
	rc = f_open(& Fil, filename, FA_READ);
	if (rc) 
	{
		debug_printf_P(PSTR("Can not open file '%s'\n"), filename);
		debug_printf_P(PSTR("Failed with rc=%u.\n"), rc);
		return;
	}
	
	// печать тестового файла
	debug_printf_P(PSTR("Type the file content: '%s'\n"), filename);
	for (;;)
	{
		char kbch;

		if (dbg_getchar(& kbch) != 0)
		{
			if (kbch == 0x1b)
				break;
		}

		if (i >= br)
		{
			// если буфер не заполнен - читаем
			rc = f_read(& Fil, rbuff, sizeof rbuff, &br);	/* Read a chunk of file */
			if (rc || !br) 
				break;			/* Error or end of file */
			i = 0;		// начальное положение указателя в буфере для вывода данных
			showprogress(filepos, fulllength);
		}
		else if (0)	// "проглатываем" символы без отображения
		{
			++ i;
			showprogress(++ filepos, fulllength);
		}
		else if (dbg_putchar(rbuff[i]))
		{
			++ i;
			showprogress(++ filepos, fulllength);
		}
	}

	debug_printf_P(PSTR("read complete: %u bytes\n"), filepos);

	if (rc) 
	{
		TP();
		debug_printf_P(PSTR("Failed with rc=%u.\n"), rc);
		return;
	}

	//debug_printf_P("\nClose the file.\n");
	rc = f_close(& Fil);
	if (rc) 
	{
		TP();
		debug_printf_P(PSTR("Failed with rc=%u.\n"), rc);
		return;
	}
}

static void rxqclear(void)
{

}

static uint_fast8_t rxqpeek(char * ch)
{
	static int i = ' ';

	* ch = i;
	if (++ i == 0x80)
		i = ' ';
	return 1;
}

// сохранение потока данных с CNC на флэшке
static void dosaveserialport(const char * fname)
{
	static FATFSALIGN_BEGIN RAMNOINIT_D1 FIL Fil FATFSALIGN_END;			/* Описатель открытого файла - нельзя располагать в Cortex-M4 CCM */
	unsigned i;
	FRESULT rc;				/* Result code */

	rc = f_open(& Fil, fname, FA_WRITE | FA_CREATE_ALWAYS);
	if (rc)
	{
		debug_printf_P(PSTR("can not start recording\n"));
		return;	//die(rc);
	}

	rxqclear();	// очистить буфер принятых символов

	unsigned long filepos;	// количество сохранённых байтов
	filepos = 0;
	i = 0;
	showprogress(filepos, 0);
	for (;;)
	{
		char kbch;
		char c;

		if (dbg_getchar(& kbch) != 0)
		{
			if (kbch == 0x1b)
			{
				debug_printf_P(PSTR("break recording\n"));
				break;
			}
		}
		if (rxqpeek(& c) != 0)
		{
			// получен очередной символ из порта - сохраняем в буфер
			rbuff [i ++] = c;
			showprogress(++ filepos, 0);
			if (i >= (sizeof rbuff / sizeof rbuff [0]))
			{
				UINT bw;
				rc = f_write(& Fil, rbuff, i, & bw);
				if (rc != 0 || bw == 0)
					break;
				i = 0;
			}
		}
	}

	if (i != 0)
	{
		UINT bw;
		rc = f_write(& Fil, rbuff, i, & bw);
		if (rc != 0 || bw != i)
		{
			TP();
			debug_printf_P(PSTR("Failed with rc=%u.\n"), rc);
			return;
		}
	}
	rc = f_close(& Fil);
	if (rc) 
	{
		TP();
		debug_printf_P(PSTR("Failed with rc=%u.\n"), rc);
		return;
	}
}

static volatile unsigned long recticks;
static volatile int recstop;

static void test_recodspool(void * ctx)
{
	if (recticks < NTICKS(60000))
	{
		++ recticks;
	}
	else
	{
		recstop = 1;
	}
}

static void test_recodstart(void)
{
	system_disableIRQ();
	recticks = 0;
	recstop = 0;
	system_enableIRQ();
}

unsigned USBD_poke_u32(uint8_t * buff, uint_fast32_t v);

// сохранение потока данных большими блоками
static void dosaveblocks(const char * fname)
{
	unsigned long long kbs = 0;
	static FATFSALIGN_BEGIN RAMNOINIT_D1 FATFS Fatfs FATFSALIGN_END;		/* File system object  - нельзя располагать в Cortex-M4 CCM */
	static FATFSALIGN_BEGIN RAMNOINIT_D1 FIL Fil FATFSALIGN_END;			/* Описатель открытого файла - нельзя располагать в Cortex-M4 CCM */
	FRESULT rc;				/* Result code */

	debug_printf_P(PSTR("FAT FS test - write file '%s'.\n"), fname);
	f_mount(& Fatfs, "", 0);		/* Register volume work area (never fails) */
	memset(rbuff, 0xE5, sizeof rbuff);
	static int i;
	USBD_poke_u32(rbuff, ++ i);
	rc = f_open(& Fil, fname, FA_WRITE | FA_CREATE_ALWAYS);
	if (rc)
	{
		PRINTF("can not create file, rc=0x%02X\n", (unsigned) rc);
		return;	//die(rc);
	}

#if 1
	//409,337,856
	rc = f_expand(& Fil, 1uLL * 1024 * 1024 * 1024, 0);
	if (rc)
	{
		PRINTF("f_expand: rc=0x%02X\n", (unsigned) rc);
		return;	//die(rc);
	}
	else
	{
		PRINTF("f_expand: rc=0x%02X\n", (unsigned) rc);
	}
#endif

#if 0
	enum { SZ_TBL = 8192 };
	static DWORD clmt [SZ_TBL];                    /* Cluster link map table buffer */
	Fil.cltbl = clmt;
	clmt [0] = SZ_TBL;                      /* Set table size */
	rc = f_lseek(& Fil, CREATE_LINKMAP);     /* Create CLMT */
	if (rc)
	{
		PRINTF("can set clusters map recording, rc=0x%02X\n", (unsigned) rc);
		return;	//die(rc);
	}
	else
	{
		PRINTF("f_lseek info, clmt [0]=%u\n", (unsigned) clmt [0]);
	}
#endif

	test_recodstart();

	for (;;)
	{
		char kbch;
		char c;

		if (recstop != 0)
		{
			PRINTF("end of timed recording\n");
			break;
		}
		if (dbg_getchar(& kbch) != 0)
		{
			if (kbch == 0x1b)
			{
				PRINTF("break recording\n");
				break;
			}
		}
		UINT bw;
		rc = f_write(& Fil, rbuff, sizeof rbuff, & bw);
		if (rc != 0 || bw != sizeof rbuff)
		{
			PRINTF("write fail, rc=0x%02X\n", (unsigned) rc);
			break;
		}
		kbs += bw;
	}
	rc = f_truncate(& Fil);
	if (rc)
	{
		PRINTF("f_truncate: rc=0x%02X\n", (unsigned) rc);
	}
	rc = f_close(& Fil);
	f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
	if (rc)
	{
		TP();
		PRINTF("f_close failed, rc=0x%02X\n", (unsigned) rc);
		return;
	}
	else
	{
		PRINTF("Write speed %ld kB/S\n", (long) (kbs / 1000 / 60));
	}
}

#if 0

static const char * fb_getname(const struct fb * p)
{
	const char * fn;
	const FILINFO * pfno = & p->fno;
	#if _USE_LFN
		fn = *pfno->lfname ? pfno->lfname : pfno->fname;
	#else
		fn = pfno->fname;
	#endif

	return fn;
}

static void fb_print(const struct fb * p, int x, int y, int selected)
{
	char buff [100 + FF_MAX_LFN + 1];
	const char * fn = fb_getname(p);
	if (p->fno.fattrib & AM_DIR)
	{
		colmain_setcolors(COLOR_GOLD, selected ? COLOR_BLUE: COLOR_BLACK);
		local_snprintf_P(buff, sizeof buff / sizeof buff [0], "%c   <dir>  %s", selected ? 'X' : ' ',
			fn);
		debug_printf_P(PSTR("   <dir>  %s\n"), p->fno.fname);
	}
	else
	{
		colmain_setcolors(COLOR_GREEN, selected ? COLOR_BLUE: COLOR_BLACK);
		local_snprintf_P(
			buff,						// куда форматировать строку
			sizeof buff / sizeof buff [0],	// размер буфера
			"%c%8lu  %s", selected ? '>' : ' ',
			p->fno.fsize, fn);
		debug_printf_P(PSTR("%8lu  %s\n"), p->fno.fsize, p->fno.fname);
	}

	//uint_fast8_t lowhalf = HALFCOUNT_SMALL2 - 1;
	//do
	//{
	//	display_gotoxy(x, y + lowhalf);
	//	display_string2(buff, lowhalf);		// печать буфера - маленьким шрифтом. 0=всегда для данного дисплея
	//} while (lowhalf --);
}
#endif

// Печать имен файлов корневого каталога.
void displfiles_buff(const char* path)
{
    FRESULT res;
    //FILINFO fno;
    DIR dir;
#if _USE_LFN
    ///*static */char lfn[FF_MAX_LFN + 1];   /* Buffer to store the LFN */
    //fno.lfname = lfn;
    //fno.lfsize = sizeof lfn;
#endif

	debug_printf_P(PSTR("Open root directory.\n"));
    res = f_opendir(& dir, path);                       /* Open the directory */
    if (res == FR_OK) 
	{
		for (;;)
		{
			char *fn;   /* This function is assuming non-Unicode cfg. */
			struct fb fbt;
			FILINFO * pfno = & fbt.fno;
 			fb_initialize(& fbt);		// подготовка к использованию элемента буфера
            res = f_readdir(& dir, pfno);                   /* Read a directory item */
            if (res != FR_OK || pfno->fname[0] == 0) break;  /* Break on error or end of dir */
            if (pfno->fname[0] == '.') continue;             /* Ignore dot entry */
#if 0//_USE_LFN
            fn = *pfno->lfname ? pfno->lfname : pfno->fname;
#else
            fn = pfno->fname;
#endif
            if (pfno->fattrib & AM_DIR)                    /* It is a directory */
			{
                //sprintf(&path[i], "/%s", fn);
                //res = scan_files(path);
                //if (res != FR_OK) break;
                //path[i] = 0;
            } 
			else                                        /* It is a file. */
			{
                //printf("%s/%s\n", path, fn);
 				debug_printf_P(PSTR("displfiles_buff: %9lu '%s'\n"), (unsigned long) pfno->fsize,  fn);
			}
        }
        //f_closedir(&dir);
    }
}

static BYTE targetdrv = 0;

static char mmcInitialize(void)
{
	DSTATUS st = disk_initialize (targetdrv);				/* Physical drive nmuber (0..) */
	//debug_printf_P(PSTR("disk_initialize code=%02X\n"), st);
	return st != RES_OK;
}

// read a size Byte big block beginning at the address.
//char mmcReadBlock(uint_fast32_t address, unsigned long count, unsigned char *pBuffer);
static char mmcReadSector(uint_fast32_t sector, unsigned char *pBuffer)
{
	DSTATUS st = disk_read(targetdrv, pBuffer, sector, 1);
	//debug_printf_P(PSTR("disk_read code=%02X\n"), st);
	return st != RES_OK;
}
//#define 

// write a 512 Byte big block beginning at the (aligned) address
//char mmcWriteBlock (uint_fast32_t address, unsigned long count, const unsigned char *pBuffer);
static char mmcWriteSector(uint_fast32_t sector, const unsigned char *pBuffer)
{
	DSTATUS st = disk_write(targetdrv, pBuffer, sector, 1);
	//debug_printf_P(PSTR("disk_write code=%02X\n"), st);
	return st != RES_OK;
}

static uint_fast64_t mmcCardSize(void)
{
	DWORD v;
	DSTATUS st = disk_ioctl(targetdrv, GET_SECTOR_COUNT, & v);
	return st != RES_OK ? 0 : (uint_fast64_t) v * MMC_SECTORSIZE;
}

static void fatfs_test(void)
{
	const unsigned long MMC_SUCCESS2 = 0x00;
	unsigned long lba_sector = 0;
	static RAMNOINIT_D1 FATFSALIGN_BEGIN unsigned char sectbuffr [MMC_SECTORSIZE] FATFSALIGN_END;
	static RAMNOINIT_D1 FATFSALIGN_BEGIN unsigned char sectbuffw [MMC_SECTORSIZE] FATFSALIGN_END;

	debug_printf_P(PSTR("Test SD card\n"));
	mmcInitialize();

	debug_printf_P(PSTR("Enter command:\n"));
//test_disk();
//print_opened_files();
// SD CARD initializations done.
// тест записи/чтения на SD CARD

	for (;;)
	{
		static int testdataval;
		int i;

		char c;
		if (dbg_getchar(& c))
		{
			switch (c)
			{
			default:
				debug_printf_P(PSTR("Undefined command letter with code 0x%02X\n"), (unsigned char) c);
				break;

			case 'x':
				debug_printf_P(PSTR("SD CARD test done.\n"));
				return;

			case '1':
				/* подготовка тестовых данных */
				debug_printf_P(PSTR("Fill write buffer by 0xff\n"));
				memset(sectbuffw, 0xff, MMC_SECTORSIZE);
				break;

			case '2':
				/* подготовка тестовых данных */
				debug_printf_P(PSTR("Fill write buffer by 0x00\n"));
				memset(sectbuffw, 0x00, MMC_SECTORSIZE);
				break;

			case '3':
				/* подготовка тестовых данных */
				debug_printf_P(PSTR("Fill write buffer by 0x55\n"));
				memset(sectbuffw, 0x55, MMC_SECTORSIZE);
				break;

			case '4':
				/* подготовка тестовых данных */
				debug_printf_P(PSTR("Fill write buffer by 0xaa\n"));
				memset(sectbuffw, 0xaa, MMC_SECTORSIZE);
				break;

			case 'c':
				/* копирование данных */
				debug_printf_P(PSTR("Copy read buffer to write buffer\n"));
				memcpy(sectbuffw, sectbuffr, MMC_SECTORSIZE);
				break;

			case '5':
				/* подготовка тестовых данных */
				debug_printf_P(PSTR("Fill write buffer by text data\n"));
				for (i = 0; i < 16; ++ i)
				{
					local_snprintf_P((char *) sectbuffw + i * 32, 32, PSTR("TEST DATA %9d"), testdataval ++);
				}
				local_snprintf_P((char *) sectbuffw, MMC_SECTORSIZE, PSTR("Sector %9lu " __TIME__ " " __DATE__ "  "), lba_sector);
				break;

			case 'r':
				debug_printf_P(PSTR("Read SD card, sector = %lu\n"), lba_sector);
				if (mmcReadSector(lba_sector, sectbuffr) != MMC_SUCCESS2)
					debug_printf_P("Read error\n");
				else
					printhex(0, sectbuffr, MMC_SECTORSIZE);
				break;

			case 'w':
				/* запись тестовых данных */
				debug_printf_P(PSTR("Write SD card, sector = %lu\n"), lba_sector);
				if (mmcWriteSector(lba_sector, sectbuffw) != MMC_SUCCESS2)
					debug_printf_P(PSTR("Write error\n"));
				else
					debug_printf_P(PSTR("Write Okay\n"));
				break;

			case 'v':
				debug_printf_P(PSTR("Verify SD card, sector = %lu\n"), lba_sector);
				if (mmcReadSector(lba_sector, sectbuffr) != MMC_SUCCESS2)
					debug_printf_P(PSTR("Read error\n"));
				else if (memcmp(sectbuffr, sectbuffw, MMC_SECTORSIZE) == 0)
					debug_printf_P(PSTR("No errors\n"));
				else
					debug_printf_P(PSTR("Different data\n"));
				break;

			case 'n':
				debug_printf_P(PSTR("Next sector (%lu) on SD card\n"), ++ lba_sector);
				break;

			case 'p':
				debug_printf_P(PSTR("Previous sector (%lu) on SD card\n"), -- lba_sector);
				break;

			//case 'Q':
			//	debug_printf_P(PSTR("Wait for ready\n"));
			//	while (SD_ReadCardSize() == 0 && dbg_getchar(& c) == 0)
					;
			case 'q':
				{
					uint_fast64_t v = mmcCardSize();
					debug_printf_P(PSTR("SD Card size = %lu KB (%lu MB) (%08lx:%08lx bytes)\n"), 
						(unsigned long) (v / 1024), 
						(unsigned long) (v / 1024 / 1024), 
						(unsigned long) (v >> 32), 
						(unsigned long) (v >> 0));

				}
				break;
			//case 'D':
			//	debug_printf_P(PSTR("Wait for ready\n"));
			//	while (mmcCardSize() == 0 && dbg_getchar(& c) == 0)
			//		;
			case 'd':
				{
					uint_fast64_t pos;
					const uint_fast64_t v = mmcCardSize();
					debug_printf_P(PSTR("Dump SD Card with size = %lu KB (%lu MB) (%08lx:%08lx bytes)\n"), 
						(unsigned long) (v / 1024), 
						(unsigned long) (v / 1024 / 1024), 
						(unsigned long) (v >> 32), 
						(unsigned long) (v >> 0));

					for (pos = 0; pos < v; )
					{
						// проверка прерывания работы с клавиатуры
						char c;
						if (dbg_getchar(& c))
						{
							dbg_putchar(c);
							if (c == 0x1b)
								break;
						}
						// работа
						const unsigned long sector = pos / MMC_SECTORSIZE;
						if (mmcReadSector(sector, sectbuffr) != MMC_SUCCESS2)
						{
							debug_printf_P(PSTR("Read error\n"));
						}
						else
						{
							printhex(pos, sectbuffr, MMC_SECTORSIZE);
							pos += MMC_SECTORSIZE;
						}
					}
					debug_printf_P(PSTR("Done dumping.\n"));
				}
				break;

			case 'z':
				mmcInitialize();
				break;
				
			//case 't':
			//	debug_printf_P("Card %s\n", mmcPing() ? "present" : "missing");
			//	break;
			}
		}
	}
}

static void fatfs_filesystest(void)
{
	FATFSALIGN_BEGIN BYTE work [FF_MAX_SS] FATFSALIGN_END;
	FRESULT rc;  
	static FATFSALIGN_BEGIN RAMNOINIT_D1 FATFS Fatfs FATFSALIGN_END;		/* File system object  - нельзя располагать в Cortex-M4 CCM */
	static const char testfile [] = "readme.txt";
	char testlog [FF_MAX_LFN + 1];
	//int nlog = 0;

	mmcInitialize();
	debug_printf_P(PSTR("FAT FS test.\n"));
	f_mount(& Fatfs, "", 0);		/* Register volume work area (never fails) */

	for (;;)
	{
		char c;
		if (dbg_getchar(& c))
		{
			switch (c)
			{
			default:
				debug_printf_P(PSTR("Undefined command letter with code 0x%02X\n"), (unsigned char) c);
				break;

			case 'q':
				{
					uint_fast64_t v = mmcCardSize();
					debug_printf_P(PSTR("SD Card size = %lu KB (%lu MB) (%08lx:%08lx bytes)\n"), 
						(unsigned long) (v / 1024), 
						(unsigned long) (v / 1024 / 1024), 
						(unsigned long) (v >> 32), 
						(unsigned long) (v >> 0));

				}
				break;

			case 'z':
				mmcInitialize();
				break;
				
			case 'x':
				f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
				debug_printf_P(PSTR("FAT FS test done.\n"));
				return;

			case 'd':
				debug_printf_P(PSTR("FAT FS test - display root directory.\n"));
				f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
				f_mount(& Fatfs, "", 0);		/* Register volume work area (never fails) */
				displfiles_buff("");	// Заполнение буфера имён файлов в памяти
				break;

			case 't':
				debug_printf_P(PSTR("FAT FS test - print file '%s'.\n"), testfile);
				f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
				f_mount(& Fatfs, "", 0);		/* Register volume work area (never fails) */
				printtextfile(testfile);
				break;

			case 'F':
				debug_printf_P(PSTR("FAT FS formatting.\n"));
				f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
				rc = f_mkfs("0:", NULL, work, sizeof (work));
				if (rc != FR_OK)
				{
					debug_printf_P(PSTR("sdcardformat: f_mkfs failure\n"));
				}
				else
				{
					debug_printf_P(PSTR("sdcardformat: f_mkfs okay\n"));
				}
				f_mount(& Fatfs, "", 0);		/* Register volume work area (never fails) */
				break;

			case 'w':
				{
					uint_fast16_t year;
					uint_fast8_t month, day;
					uint_fast8_t hour, minute, secounds;
					board_rtc_getdatetime(& year, & month, & day, & hour, & minute, & secounds);
					static unsigned ser;
					local_snprintf_P(testlog, sizeof testlog / sizeof testlog [0],
						PSTR("rec_%04d-%02d-%02d_%02d%02d%02d_%08lX_%u.txt"),
						year, month, day,
						hour, minute, secounds,
						hardware_get_random(),
						++ ser
						);
					debug_printf_P(PSTR("FAT FS test - write file '%s'.\n"), testlog);
					f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
					f_mount(& Fatfs, "", 0);		/* Register volume work area (never fails) */
					dosaveserialport(testlog);
				}
				break;

			case 'W':
				{
					uint_fast16_t year;
					uint_fast8_t month, day;
					uint_fast8_t hour, minute, secounds;
					board_rtc_getdatetime(& year, & month, & day, & hour, & minute, & secounds);
					static unsigned ser;
					local_snprintf_P(testlog, sizeof testlog / sizeof testlog [0],
						PSTR("rec_%04d-%02d-%02d_%02d%02d%02d_%08lX_%u.txt"),
						year, month, day,
						hour, minute, secounds,
						hardware_get_random(),
						++ ser
						);
					f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
					dosaveblocks(testlog);
				}
				break;
			}
		}
	}
}

static void fatfs_filesyspeedstest(void)
{
	uint_fast16_t year;
	uint_fast8_t month, day;
	uint_fast8_t hour, minute, secounds;
	board_rtc_getdatetime(& year, & month, & day, & hour, & minute, & secounds);
	static unsigned ser;
	static const char testfile [] = "readme.txt";
	char testlog [FF_MAX_LFN + 1];
	//int nlog = 0;


	mmcInitialize();
	local_snprintf_P(testlog, sizeof testlog / sizeof testlog [0],
		PSTR("rec_%04d-%02d-%02d_%02d%02d%02d_%08lX_%u.txt"),
		year, month, day,
		hour, minute, secounds,
		hardware_get_random(),
		++ ser
		);
	dosaveblocks(testlog);
}

#endif /* WITHDEBUG && WITHUSEAUDIOREC */

//HARDWARE_SPI_HANGON()	- поддержка SPI программатора - подключение к программируемому устройству
//HARDWARE_SPI_HANGOFF() - поддержка SPI программатора - отключение от программируемого устройства

#if 0 && defined(targetdataflash)

static void spi_hangon(void)
{
	HARDWARE_SPI_HANGON();
	local_delay_ms(200);
}

static void spi_hangoff(void)
{
	HARDWARE_SPI_HANGOFF();
}

/////////

#define SPIMODE_AT26DF081A	SPIC_MODE3

static unsigned char dataflash_read_status(
	spitarget_t target	/* addressing to chip */
	)
{
	unsigned char v;

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x05);		/* read status register */

	spi_to_read(target);
	v = spi_read_byte(target, 0xff);
	spi_to_write(target);

	spi_unselect(target);	/* done sending data to target chip */

	return v;
}

static int timed_dataflash_read_status(
	spitarget_t target
	)
{
	unsigned long w = 40000;
	while (w --)
	{
		if ((dataflash_read_status(target) & 0x01) == 0)
			return 0;
	}
	debug_printf_P(PSTR("DATAFLASH timeout error\n"));
	return 1;
}

static int largetimed_dataflash_read_status(
	spitarget_t target
	)
{
	unsigned long w = 40000000;
	while (w --)
	{
		if ((dataflash_read_status(target) & 0x01) == 0)
			return 0;
	}
	debug_printf_P(PSTR("DATAFLASH erase timeout error\n"));
	return 1;
}

static int testchipDATAFLASH(void)
{
	spitarget_t target = targetdataflash;	/* addressing to chip */

	unsigned char mf_id;	// Manufacturer ID
	unsigned char mf_devid1;	// device ID (part 1)
	unsigned char mf_devid2;	// device ID (part 2)
	unsigned char mf_dlen;	// Extended Device Information String Length


	/* Ожидание бита ~RDY в слове состояния. Для FRAM не имеет смысла.
	Вставлено для возможности использования DATAFLASH */

	if (timed_dataflash_read_status(target))
		return 1;

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x9f);		/* read id register */

	spi_to_read(target);

	//prog_spi_to_read();
	mf_id = spi_read_byte(target, 0xff);
	mf_devid1 = spi_read_byte(target, 0xff);
	mf_devid2 = spi_read_byte(target, 0xff);
	mf_dlen = spi_read_byte(target, 0xff);

	spi_to_write(target);

	spi_unselect(target);	/* done sending data to target chip */

	debug_printf_P(PSTR("Read: ID = 0x%02X devId = 0x%02X%02X, mf_dlen=0x%02X\n"), mf_id, mf_devid1, mf_devid2, mf_dlen);
	//debug_printf_P(PSTR("Need: ID = 0x%02X devId = 0x%02X%02X, mf_dlen=0x%02X\n"), 0x1f, 0x45, 0x01, 0x00);
	return mf_id != 0x1f || mf_devid1 != 0x45 || mf_devid2 != 0x01 || mf_dlen != 0;
}

static int eraseDATAFLASH(void)
{
	spitarget_t target = targetdataflash;	/* addressing to chip */

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x06);		/* write enable */
	spi_unselect(target);	/* done sending data to target chip */

	if (timed_dataflash_read_status(target))
		return 1;

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x60);		/* chip erase */
	spi_unselect(target);	/* done sending data to target chip */

	if (largetimed_dataflash_read_status(target))
		return 1;

	if ((dataflash_read_status(target) & (0x01 << 5)) != 0)	// write error
	{
		debug_printf_P(PSTR("Erase error\n"));
		return 1;
	}
	return 0;
}

static int prepareDATAFLASH(void)
{
	spitarget_t target = targetdataflash;	/* addressing to chip */

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x06);		/* write enable */
	spi_unselect(target);	/* done sending data to target chip */

	// Write Status Register
	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x01);		/* write status register */
	spi_progval8(target, 0x00);		/* write status register */
	spi_unselect(target);	/* done sending data to target chip */

	return 0;
}

static int writeEnableDATAFLASH(void)
{
	spitarget_t target = targetdataflash;	/* addressing to chip */

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x06);		/* write enable */
	spi_unselect(target);	/* done sending data to target chip */

	return 0;
}

static int writeDisableDATAFLASH(void)
{
	spitarget_t target = targetdataflash;	/* addressing to chip */

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x04);		/* write disable */
	spi_unselect(target);	/* done sending data to target chip */

	return 0;
}


static int writesinglepageDATAFLASH(unsigned long flashoffset, const unsigned char * data, unsigned long len)
{
	spitarget_t target = targetdataflash;	/* addressing to chip */

	//debug_printf_P(PSTR(" Prog to address %08lX %02X\n"), flashoffset, len);

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x06);		/* write enable */
	spi_unselect(target);	/* done sending data to target chip */

	// start byte programm
	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8_p1(target, 0x02);				/* Page Program */

	spi_progval8_p2(target, flashoffset >> 16);
	spi_progval8_p2(target, flashoffset >> 8);
	spi_progval8_p2(target, flashoffset >> 0);

	while (len --)
		spi_progval8_p2(target, (unsigned char) * data ++);	// data

	spi_complete(target);	/* done sending data to target chip */

	spi_unselect(target);	/* done sending data to target chip */

	/* Ожидание бита ~RDY в слове состояния. Для FRAM не имеет смысла.
	Вставлено для возможности использования DATAFLASH */

	if (timed_dataflash_read_status(target))
		return 1;

	//debug_printf_P(PSTR("Done programming\n"));
	return 0;
}

static unsigned long ulmin(
	unsigned long a,
	unsigned long b)
{
	return a < b ? a : b;
}

static int writeDATAFLASH(unsigned long flashoffset, const unsigned char * data, unsigned long len)
{
	//debug_printf_P(PSTR("Write to address %08lX %02X\n"), flashoffset, len);
	while (len != 0)
	{
		unsigned long offset = flashoffset & 0xFF;
		unsigned long part = ulmin(len, ulmin(256, 256 - offset));

		int status = writesinglepageDATAFLASH(flashoffset, data, part);
		if (status != 0)
			return status;
		len -= part;
		flashoffset += part;
		data += part;
	}
	return 0;
}

static int verifyDATAFLASH(unsigned long flashoffset, const unsigned char * data, unsigned long len)
{
	unsigned long count;
	unsigned long err = 0;
	unsigned char v;
	spitarget_t target = targetdataflash;	/* addressing to chip */

	//debug_printf_P(PSTR("Compare from address %08lX\n"), flashoffset);

	spi_select(target, SPIMODE_AT26DF081A);	/* start sending data to target chip */
	spi_progval8(target, 0x03);		/* sequential read block */

	spi_progval8(target, flashoffset >> 16);
	spi_progval8(target, flashoffset >> 8);
	spi_progval8(target, flashoffset >> 0);

	spi_to_read(target);

	for (count = 0; count < len; ++ count)
	{
		v = spi_read_byte(target, 0xff);
		if (v != data [count])
		{
			debug_printf_P(PSTR("Data mismatch at %08lx: read=%02x, expected=%02x\n"), flashoffset + count, v, data [count]);
			err = 1;
			break;
		}
	}

	spi_to_write(target);

	spi_unselect(target);	/* done sending data to target chip */

	if (err)
		debug_printf_P(PSTR("Done compare, have errors\n"));

	return err;
}



/////////
static int
toprintcFLASH(int c)
{
	if (c < 0x20 || c >= 0x7f)
		return '.';
	return c;
}

static int
printhexDATAFLASH(unsigned long voffs, const unsigned char * buff, unsigned long length)
{
	unsigned i, j;
	unsigned rows = (length + 15) / 16;

	for (i = 0; i < rows; ++ i)
	{
		const int trl = ((length - 1) - i * 16) % 16 + 1;
		debug_printf_P(PSTR("%08lX "), voffs + i * 16);
		for (j = 0; j < trl; ++ j)
			debug_printf_P(PSTR(" %02X"), buff [i * 16 + j]);

		debug_printf_P(PSTR("%*s"), (16 - trl) * 3, "");

		debug_printf_P(PSTR("  "));
		for (j = 0; j < trl; ++ j)
			debug_printf_P(PSTR("%c"), toprintcFLASH(buff [i * 16 + j]));

		debug_printf_P(PSTR("\n"));
	}
	return 0;
}

//static unsigned long flashbase = 0x18000000ul;

enum
{
	HSINIT,
	HSPARSEADDR1, HSPARSEADDR2, HSPARSEADDR3, HSPARSEADDR4,
	HSPARSELEN1, HSPARSELEN2,
	HSPARSETYPE1, HSPARSETYPE2,
	HSPARSEDATA1, HSPARSEDATA2,
	HSPARSEBODY1, HSPARSEBODY2,
	HSPARSECKS1, HSPARSECKS2,
};

static int ascii2nibble(int c)
{
	if (isdigit(c))
		return c - '0';
	if (isupper(c))
		return c - 'A' + 10;
	if (islower(c))
		return c - 'a' + 10;
	return 0;
}

static int parsehex(const TCHAR * filename, int (* usedata)(unsigned long addr, const unsigned char * data, unsigned long length))
{
	int hexstate = HSINIT;
	unsigned long rowaddress = 0;
	unsigned long segaddress = 0;
	unsigned long length;
	unsigned long address;
	unsigned long type;
	unsigned long body2, body32;
	unsigned long count;
	unsigned long cksread;
	unsigned long ckscalc;
	unsigned char body [256];

	//unsigned long filepos = 0;	// количество выданных байтов
	UINT br = 0;		//  количество считанных байтов
	UINT i = 0;			// номер выводимого байта
	
	FRESULT rc;				/* Result code */
	static FATFSALIGN_BEGIN RAMNOINIT_D1 FIL Fil FATFSALIGN_END;			/* Описатель открытого файла - нельзя располагать в Cortex-M4 CCM */
	// чтение файла
	rc = f_open(& Fil, filename, FA_READ);
	if (rc) 
	{
		debug_printf_P(PSTR("Can not open file '%s'\n"), filename);
		debug_printf_P(PSTR("Failed with rc=%u.\n"), rc);
		return 1;
	}
	for (;;)
	{
		if (i >= br)
		{
			// если буфер не заполнен - читаем
			rc = f_read(& Fil, rbuff, sizeof rbuff, &br);	/* Read a chunk of file */
			if (rc || !br) 
				break;			/* Error or end of file */
			i = 0;		// начальное положение указателя в буфере для вывода данных
			//showprogress(filepos, fulllength);
		}
		else 
		{
			int c = rbuff [i ++];
			if (c == EOF)
			{
				if (hexstate != HSINIT)
					debug_printf_P(PSTR("Incomplete file '%s'\n"), filename);
				break;
			}
			if (c == '\n' || c == '\r')
			{
				if (hexstate != HSINIT)
				{
					debug_printf_P(PSTR("Incomplete file '%s'\n"), filename);
					break;
				}
				continue;
			}

			switch (hexstate)
			{
			case HSINIT:
				if (c != ':')
				{
					debug_printf_P(PSTR("Incomplete file '%s'\n"), filename);
					break;
				}
				hexstate = HSPARSELEN1;
				address = 0;
				type = 0;
				count = 0;
				ckscalc = 0;
				length = 0;
				continue;

			case HSPARSELEN1:
				body2 = body2 * 16 + ascii2nibble(c);
				hexstate = HSPARSELEN2;
				continue;

			case HSPARSELEN2:
				body2 = body2 * 16 + ascii2nibble(c);
				ckscalc += (body2 & 0xff);
				length = body2 & 0x00ff;
				hexstate = HSPARSEADDR1;
				continue;

			case HSPARSEADDR1:
				body2 = body2 * 16 + ascii2nibble(c);
				hexstate = HSPARSEADDR2;
				continue;

			case HSPARSEADDR2:
				body2 = body2 * 16 + ascii2nibble(c);
				ckscalc += (body2 & 0xff);
				hexstate = HSPARSEADDR3;
				continue;

			case HSPARSEADDR3:
				body2 = body2 * 16 + ascii2nibble(c);
				hexstate = HSPARSEADDR4;
				continue;

			case HSPARSEADDR4:
				body2 = body2 * 16 + ascii2nibble(c);
				ckscalc += (body2 & 0xff);
				address = body2 & 0xffff;
				hexstate = HSPARSETYPE1;
				continue;

			case HSPARSETYPE1:
				body2 = body2 * 16 + ascii2nibble(c);
				hexstate = HSPARSETYPE2;
				continue;

			case HSPARSETYPE2:
				body2 = body2 * 16 + ascii2nibble(c);
				ckscalc += (body2 & 0xff);
				type = body2 & 0x00ff;

				if (length != 0)
				{
					hexstate = HSPARSEBODY1;
				}
				else
				{
					hexstate = HSPARSECKS1;
				}
				continue;

			case HSPARSEBODY1:
				body2 = body2 * 16 + ascii2nibble(c);
				hexstate = HSPARSEBODY2;
				continue;

			case HSPARSEBODY2:
				body2 = body2 * 16 + ascii2nibble(c);
				ckscalc += (body2 & 0xff);

				if (count < (sizeof body / sizeof body [0]))
					body [count ++] = body2 & 0xff;

				if (count >= length)
				{
					// last byte in body
					hexstate = HSPARSECKS1;
					body32 = body2;
				}
				else
					hexstate = HSPARSEBODY1;
				continue;

			case HSPARSECKS1:
				cksread = cksread * 16 + ascii2nibble(c);
				hexstate = HSPARSECKS2;
				continue;

			case HSPARSECKS2:
				cksread = cksread * 16 + ascii2nibble(c);
				ckscalc += (cksread & 0xff);
				hexstate = HSINIT;

				if ((ckscalc & 0xff) != 0)
				{
					debug_printf_P(PSTR("Wrong checksum in file '%s'\n"), filename);
					break;
				}
				// Use data
				switch (type)
				{
				case 0:
					// Data
					if (usedata(segaddress + address, body, count))
						break;
					continue;

				case 4:
					// Extended Linear Address
					segaddress = (0xffff & body32) << 16;
					continue;

				case 5:
					// Start Linear Address
					debug_printf_P(PSTR("Start Linear Address: %08lX\n"), body32);
					continue;

				case 1:
					//printf("End of file record\n");
					continue;

				default:
					debug_printf_P(PSTR("record with code %02X\n"), (unsigned) type);
					break;
				}
				break;
			}
			break;
		}
	} // for each char in file

	if (rc) 
	{
		rc = f_close(& Fil);
		return 1;
	}

	//debug_printf_P("\nClose the file.\n");
	rc = f_close(& Fil);
	if (rc) 
	{
		return 1;
	}
	return 0;
}

static void
fatfs_proghexfile(const char * hexfile)
{
	spi_hangon();
	debug_printf_P(PSTR("SPI FLASH programmer\n"));
	//parsehex(hexfile, printhexDATAFLASH);

	// AT26DF081A chip write
	if (testchipDATAFLASH() == 0)
	{
		//testchipDATAFLASH();
		//parsehex(hexfile, printhexDATAFLASH);

		do 
		{
			debug_printf_P(PSTR("Prepare...\n"));
			if (prepareDATAFLASH()) break;
			debug_printf_P(PSTR("Erase...\n"));
			if (eraseDATAFLASH()) break;
			if (writeEnableDATAFLASH()) break;
			if (parsehex(hexfile, writeDATAFLASH)) break;
			debug_printf_P(PSTR("Programming...\n"));
			if (writeDisableDATAFLASH()) break;
			debug_printf_P(PSTR("Verify...\n"));
			if (parsehex(hexfile, verifyDATAFLASH)) break;
		} while (0);
		debug_printf_P(PSTR("SPI FLASH programmer done\n"));
	}
	spi_hangoff();	// после этого ничего не делаем - так как может опять включиться SPI - для работы с SD картой
	for (;;)
		;
}

static void
fatfs_progspi(void)
{
	static FATFSALIGN_BEGIN RAMNOINIT_D1 FATFS Fatfs FATFSALIGN_END;		/* File system object  - нельзя располагать в Cortex-M4 CCM */
	f_mount(& Fatfs, "", 0);		/* Register volume work area (never fails) */
	fatfs_proghexfile("tc1_r7s721_rom.hex");
	f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */

	for (;;)
		;
}
#endif /* defined(targetdataflash) */

#if 0

// показ цифровых значений параметров.
static void 
display_debug_digit(
	uint_fast32_t value,
	uint_fast8_t width,
	uint_fast8_t comma,
	uint_fast8_t rj
	)
{
	enum { col = 0, row = 0 };
	uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;

	colmain_setcolors(MNUVALCOLOR, BGCOLOR);
	do
	{
		display_gotoxy(col, row + lowhalf);		// курсор в начало первой строки
		display2_menu_value(value, width, comma, rj, lowhalf);
	} while (lowhalf --);
}

#endif

#if 0 && CPUSTYLE_R7S721

/////////////////////
static void leds(uint_fast8_t v)
{
	i2c_start(0x40);	// CAT9554 address
	i2c_write(0x01);	// #1 - output port address
	i2c_write(0x07 & ~ v);
	i2c_waitsend();
	i2c_stop();
}

static void ledsinit(void)
{
	i2c_start(0x40);	// CAT9554 address
	i2c_write(0x03);	// #3 - Configuration register
	i2c_write(~ 0x07);	// "0" - output, "1" - input
	i2c_waitsend();
	i2c_stop();
}

#endif

#define LED_TARGET_PORT_S(v) do { R7S721_TARGET_PORT_S(7, v); } while (0)
#define LED_TARGET_PORT_C(v) do { R7S721_TARGET_PORT_C(7, v); } while (0)

enum { LEDBIT = 1U << 1 }; // P7_1
enum { SW1BIT = 1U << 9 }; // P1_9

#if 0 && WITHDEBUG && WITHUART1HW
// "трассировка" с помощью выдачи на SPI порт информации о сработавших прерываниях
static void test_spi_trace(uint_fast8_t v)
{
	const spitarget_t target = targetctl1;
	//
	spi_select(target, SPIC_MODE3);
	spi_progval8_p1(target, v);
	spi_complete(target);
	spi_unselect(target);
}
//++++++++++++++++

enum { qSZ = 8 };
static volatile uint_fast8_t queue [qSZ];
static volatile uint_fast8_t qp, qg;
static void	qput(uint_fast8_t c)
{
	uint_fast8_t next = (qp + 1) % qSZ;
	if (next != qg)
	{
		queue [qp] = c;
		qp = next;
	}
}

static uint_fast8_t qget(uint_fast8_t * pc)
{
	if (qp != qg)
	{
		* pc = queue [qg];
		qg = (qg + 1) % qSZ;
		return 1;
	}
	return 0;
}

static uint_fast8_t qempty(void)
{
	return qp == qg;
}

// ---------
static volatile uint_fast8_t rxcount, txcount, rxerrcount;

static int cat3_puts_impl_P(const FLASHMEM char * s)
{
	char c;
	while ((c = * s ++) != '\0')
	{
		while (HARDWARE_DEBUGSIRQ_PUTCHAR(c) == 0)
			;
	}
	return 0;
}

/* вызывается из обработчика прерываний */
// произошла потеря символа (символов) при получении данных с CAT компорта
void cat3_rxoverflow(void)
{
	++ rxerrcount;
}

/* вызывается из обработчика прерываний */
void cat3_disconnect(void)
{
}

void cat3_parsechar(uint_fast8_t c)
{
	//while (hardware_usart1_putchar(c) == 0)
	//	;
	//return;
	++ rxcount;
	//test_spi_trace((rxcount & 0x0f) * 16 + (txcount & 0x0f));

	if (c == 0x1b)
	{
		qput('<');
		qput('e');
		qput('s');
		qput('c');
		qput('>');
	}
	else if (c == 0x0d)
	{
		qput('<');
		qput('c');
		qput('r');
		qput('>');
	}
	else if (c == 0x0a)
	{
		qput('<');
		qput('l');
		qput('f');
		qput('>');
	}
	else
		qput(c);
	if (! qempty())
		HARDWARE_DEBUGSIRQ_ENABLETX(1);
}

void cat3_sendchar(void * ctx)
{
	++ txcount;
	//test_spi_trace((rxcount & 0x0f) * 16 + (txcount & 0x0f));

	uint_fast8_t c;
	if (qget(& c))
	{
		HARDWARE_DEBUGSIRQ_TX(ctx, c);
		if (qempty())
			HARDWARE_DEBUGSIRQ_ENABLETX(0);
	}
	else
	{
		HARDWARE_DEBUGSIRQ_ENABLETX(0);
	}
}

static void serial_irq_loopback_test(void)
{
	//test_spi_trace((rxcount & 0x0f) * 16 + (txcount & 0x0f));

	system_disableIRQ();
	HARDWARE_DEBUGSIRQ_INITIALIZE();
	HARDWARE_DEBUGSIRQ_SET_SPEED(DEBUGSPEED);
	HARDWARE_DEBUGSIRQ_ENABLERX(1);
	system_enableIRQ();
	cat3_puts_impl_P(PSTR("Serial port ECHO test (with IRQ).\r\n"));
	for (;;)
	{
	}

}

#endif /* WITHDEBUG && WITHUART1HW */

// Периодически вызывается в главном цикле
void looptests(void)
{
#if WITHDTMFPROCESSING
	dtmftest();
#endif
#if 0 && WITHINTEGRATEDDSP
	{
		dsp_speed_diagnostics();	// печать в последовательный порт результатов диагностики
	}
#endif
#if 0 && WITHINTEGRATEDDSP
	{
		// See buffers.c - WITHBUFFERSDEBUG
		buffers_diagnostics();
	}
#endif
#if 0 && WITHCURRLEVEL
	{
		// Тестирование датчика тока
		(void) hamradio_get_pacurrent_value();
	}
#endif
#if 0 && WITHVOLTLEVEL
	{
		// Тестирование датчика напряжния
		(void) hamradio_get_volt_value();
	}
#endif
#if 0 && WITHTEMPSENSOR
	{
		// Тестирование датчика температуры
		// TODO: пока не показывает температуру!
		const uint_fast8_t tempi = TEMPIX;
		const adcvalholder_t v = board_getadc_unfiltered_truevalue(tempi);
		// Измерение опрного напряжения
		const uint_fast8_t vrefi = VREFIX;
		const adcvalholder_t ref = board_getadc_unfiltered_truevalue(vrefi);	// текущее значение данного АЦП
		if (ref != 0)
		{
			const long Vref_mV = (uint_fast32_t) board_getadc_fsval(vrefi) * WITHREFSENSORVAL / ref;
			// Temperature (in °C) = {(V25 - VSENSE) / Avg_Slope} + 25.
			// Average slope = 4.3
			// Voltage at 25 °C = 1.43 V
			const long celsius = (1430 - (v * Vref_mV / board_getadc_fsval(tempi))) / 430 + 2500;
			debug_printf_P(PSTR("celsius=%3ld.%02ld\n"), celsius / 100, celsius % 100);
		}
	}
#endif
}

#if 0 && CTLSTYLE_V1V
// "прерыватель"

static void showstate(
	unsigned offtime,
	unsigned ontime
	)
{
	char buff [32];


	local_snprintf_P(buff, 32, PSTR(" ON: %4u0 mS"), ontime);
	display_gotoxy(0, 0);
	display_at(buff, 0);


	local_snprintf_P(buff, 32, PSTR("OFF: %4u0 mS"), offtime);
	display_gotoxy(0, 1);
	display_at(buff, 0);

}


static unsigned modif (unsigned v, unsigned pos, unsigned dd, unsigned width)
{
	unsigned d = (dd % width);
	unsigned leftpos = pos * width;
	unsigned left = v / leftpos;
	unsigned right = v % pos;
	return left * leftpos + (((v / pos) + d) % width) * pos + right;

}

#endif /* 1 && CTLSTYLE_V1V */

#if 0

// PG7: fpga ok
// PG6: sys ok
// PG3: dsp ok
// PG2: res ok
enum { MFPGA = 1ul << 7 };
enum { MSYS = 1ul << 6 };
enum { MDSP = 1ul << 3 };
enum { MRES = 1ul << 2 };

static void sdfault(void)
{
	debug_printf_P(PSTR("sdfault\n"));
	arm_hardware_piog_outputs(MRES, MRES);
	for (;;)
		;
}

static void sdtick(void)
{
	GPIOG->ODR ^= MDSP;	// Debug LEDs
}
#endif

#if LCDMODE_COLORED && ! DSTYLE_G_DUMMY && 0



// Рисуем на основном экране цветной прямоугольник.
// x2, y2 - координаты второго угла (не входящие в закрашиваемый прямоугольник)
static void display_solidbar(
	uint_fast16_t x,
	uint_fast16_t y,
	uint_fast16_t x2,
	uint_fast16_t y2,
	COLORMAIN_T color
	)
{
	if (x2 < x)
	{
		const uint_fast16_t t = x;
		x = x2, x2 = t;
	}
	if (y2 < y)
	{
		const uint_fast16_t t = y;
		y = y2, y2 = t;
	}
	display_fillrect(x, y, x2 - x, y2 - y, color);
}


// Получение псевдослучайныз чисел.
// 0 .. num-1
static int local_randomgr( int num )
{

	static unsigned long rand_val = 123456UL;

	if (rand_val & 0x80000000UL)
		rand_val = (rand_val << 1);
	else	rand_val = (rand_val << 1) ^0x201051UL;

	return (rand_val % num);

}


/*                                                                      */
/*      RANDOMBARS: Display random bars                                 */
/*                                                                      */

static void BarTest(void)
{
	unsigned n = 20000;
	for (;n --;)
	{                    /* Until user enters a key...   */
		const int r = local_randomgr(256);
		const int g = local_randomgr(256);
		const int b = local_randomgr(256);

		const COLORMAIN_T color = TFTRGB(r, g, b);

		int x = local_randomgr(DIM_X);
		int y = local_randomgr(DIM_Y);
		int x2 = local_randomgr(DIM_X);
		int y2 = local_randomgr(DIM_Y);

		display_solidbar(x, y, x2, y2, color);
		//local_delay_ms(50);
	}

	//getch();             /* Pause for user's response    */
}



static  void
GrideTest(void)
{
	int     xm, ym, xm4, ym4;
	int xm1, ym1;
	unsigned long col1, col20, col21, col22, col23, col3;
	int     n, k;

	col1 = TFTRGB(192,192,192);

	col20 = TFTRGB(64,128,128);
	col21 = TFTRGB(128,64,128);
	col22 = TFTRGB(128,128,64);
	col23 = TFTRGB(64,64,64);

	col3 = TFTRGB(0,192,192);


	xm = DIM_X - 1;
	ym = DIM_Y - 1;
	xm4 = xm / 4;
	ym4 = ym / 4;
	xm1 = xm / 40;
	ym1 = ym / 40;

	/* Filled rectangle - all screen. */
	display_solidbar(0, 0, xm, ym, col1);

	/* Filled rectangle at right-down corner. */
	display_solidbar(xm4 * 3 + xm1, ym4 * 3 + ym1, xm4 * 4 - xm1, ym4 * 4 - ym1, col20);
	/* Filled rectangle at right-upper corner. */
	display_solidbar(xm4 * 3 + xm1, ym1, xm4 * 4 - xm1, ym4 - ym1, col21);
	/* Filled rectangle at left - down corner. */
	display_solidbar(xm1, ym4 * 3 + ym1, xm4 - xm1, ym4 * 4 - ym1, col22);
	/* Filled rectangle at center. */
	display_solidbar(xm4 + xm1, ym4 + ym1, xm4 * 3 - xm1, ym4 * 3 - ym1, col23);

	for (k = 0; k < 16; ++ k)
		for (n = 0; n < 16; ++ n)
			display_solidbar(n * 18 + 1,
				 k * 10 + 3,
				 n * 18 + 16,
				 k * 10 + 9,
				 TFTRGB(n * 16, k * 16, 255 - (n * 8 + k * 8) )
				 );

	/* Interlase test.	*/
	display_line(0,  0,  xm, 1,  col3);
	display_line(0,  0,  xm, 3,  col3);
	display_line(0,  0,  xm, 5,  col3);

	/* diagonales test.	*/
	display_line(xm, 0,  xm, ym, col3);
	display_line(xm, ym, 0,  ym, col3);
	display_line(0,  ym, 0,  0,  col3);
	display_line(0,  0,  xm, ym, col3);
	display_line(0,  ym, xm, 0,  col3);

	//getch();

}

#endif /* LCDMODE_COLORED && ! DSTYLE_G_DUMMY */

#if 0
// MCU_AHB_SRAM - 96k

static void memfill(unsigned k)
{
	unsigned long offset = k * 1024uL;

	((volatile uint8_t *) 0x20000000) [offset + 4] = 0xAA;
	((volatile uint8_t *) 0x20000000) [offset + 5] = 0x55;
	((volatile uint32_t *) 0x20000000) [offset + 0] = offset;
}

static int memprobe(unsigned k)
{
	unsigned long offset = k * 1024uL;

	const uint_fast8_t ok1 = ((volatile uint8_t *) 0x20000000) [offset + 4] == 0xAA;
	const uint_fast8_t ok2 = ((volatile uint8_t *) 0x20000000) [offset + 5] == 0x55;
	const uint_fast8_t ok3 = ((volatile uint32_t *) 0x20000000) [offset + 0] == offset;
	return ok1 && ok2 && ok3;
}
#endif


#if 0 && WITHDEBUG
// FPU speed test

#define FFTZS 8192
typedef struct
{
	float r;
	float i;
} cplxf;

static RAMFRAMEBUFF ALIGNX_BEGIN cplxf src [FFTZS] ALIGNX_END;
static RAMFRAMEBUFF ALIGNX_BEGIN cplxf dst [FFTZS] ALIGNX_END;
static RAMDTCM ALIGNX_BEGIN cplxf refv [FFTZS] ALIGNX_END;

static void RAMFUNC_NONILINE cplxmla(cplxf *s, cplxf *d, cplxf *ref, int len) {
	while (len--) {
		d->r += s->r * ref->r - s->i * ref->i;
		d->i += s->i * ref->r + s->r * ref->i;
		++s;  ++d; ++ref;
	}
}

static void RAMFUNC_NONILINE cplxmlafast(cplxf *s, cplxf *d, cplxf *ref, int len) {
	int i;
	for (i = 0; i < len; ++ i) {
		d [i].r += s [i].r * ref [i].r - s [i].i * ref [i].i;
		d [i].i += s [i].i * ref [i].r + s [i].r * ref [i].i;
	}
}

static void RAMFUNC_NONILINE cplxmlasave(cplxf *d, int len) {
	while (len--) {
		volatile float t;
		t = d->r;
		t = d->i;
	}
}

#endif

void hightests(void)
{
#if WITHLTDCHW && LCDMODE_LTDC
	arm_hardware_ltdc_main_set((uintptr_t) colmain_fb_draw());
#endif /* WITHLTDCHW && LCDMODE_LTDC */

#if 1 && defined (__GNUC__)
	{

		debug_printf_P(PSTR("__GNUC__=%d, __GNUC_MINOR__=%d\n"), (int) __GNUC__, (int) __GNUC_MINOR__);
	}
#endif
#if 0 && WITHDEBUG
	{
		// FPU speed test
		uint_fast8_t state = 0;
#if CPUSTYLE_R7S721
		const uint_fast32_t mask = (1uL << 10);	// P7_10: RXD0: RX DATA line
		arm_hardware_pio7_outputs(mask, mask);
#else /* CPUSTYLE_R7S721 */
		const uint_fast32_t mask = (1uL << 13);	// PA13
		arm_hardware_pioa_outputs(mask, 1 * mask);
#endif /* CPUSTYLE_R7S721 */
		PRINTF("cplxmla @%p, src @%p, dst @%p. refv @%p, CPU_FREQ=%lu MHz\n", cplxmla, src, dst, refv, CPU_FREQ / 1000000uL);
		global_disableIRQ();
		for (;;)
		{
			//	__GNUC__=9, __GNUC_MINOR__=3
			//	cplxmla @2FFC5698, src @C0114100, dst @C0104100. refv @2FFCC340, CPU_FREQ=793 MHz
			// stm32mp1 @800 MHz w/o NEON:
			// cplxmla: 2 kHz
			// cplxmla & cplxmlasave: 1.85 kHz
			// stm32mp1 @800 MHz with NEON:
			// cplxmla: 3 kHz
			// cplxmla & cplxmlasave: 2.65 kHz
			// __GNUC__=9, __GNUC_MINOR__=3
			// cplxmla @20042D08, src @20206040, dst @201F6040. refv @20123080, CPU_FREQ=360 MHz
			// R7S721 @360 MHz w/o NEON:
			// cplxmla & cplxmlasave: 0.7 kHz
			// R7S721 @360 MHz with NEON:
			// cplxmla & cplxmlasave: 0.7 kHz

			cplxmla(src, dst, refv,  FFTZS);
			cplxmlasave(dst, FFTZS);

			if (state)
			{
				state = 0;
	#if CPUSTYLE_R7S721
				R7S721_TARGET_PORT_S(7, mask);
	#else /* CPUSTYLE_R7S721 */
				(GPIOA)->BSRR = BSRR_S(mask);
	#endif /* CPUSTYLE_R7S721 */
			}
			else
			{
				state = 1;
		#if CPUSTYLE_R7S721
					R7S721_TARGET_PORT_C(7, mask);
		#else /* CPUSTYLE_R7S721 */
					(GPIOA)->BSRR = BSRR_C(mask);
		#endif /* CPUSTYLE_R7S721 */
			}
		}

	}
#endif
#if 0
	{
	#if 0
		unsigned k;
		TP();
		for (k = 0; k < 1024; ++ k)
		{
			memfill(k);
		}
		TP();
		for (k = 0; k < 1024; ++ k)
		{
			PRINTF("\r%4d ", k);
			if (!memprobe(k))
				break;
		}
		PRINTF("\n");
		PRINTF("MCU_AHB_SRAM size = %uK\n", k);
		printhex(MCU_AHB_SRAM, (const uint8_t *) MCU_AHB_SRAM, 256);	// /* Cortex-M4 memories */
	#endif
	#if WITHSDRAMHW
		printhex(DRAM_MEM_BASE, (const uint8_t *) DRAM_MEM_BASE, 256);	// DDR3
	#endif /* WITHSDRAMHW */
		//printhex(QSPI_MEM_BASE, (const uint8_t *) QSPI_MEM_BASE, 256);	// QSPI
		//arm_hardware_sdram_initialize();
	}
#endif
#if 0
	{
		debug_printf_P(PSTR("PLL_FREQ=%lu Hz (%lu MHz)\n"), (unsigned long) PLL_FREQ, (unsigned long) PLL_FREQ / 1000000);
	}
#endif
#if 0
	{
		#define WORKMASK (MFPGA | MSYS | MDSP | MRES)

		arm_hardware_piog_outputs(WORKMASK, 0);

		static RAMNOINIT_D1 FATFSALIGN_BEGIN float Etalon [2048] FATFSALIGN_END;
		static RAMNOINIT_D1 FATFSALIGN_BEGIN float TM [2048] FATFSALIGN_END;
		static FATFSALIGN_BEGIN RAMNOINIT_D1 FIL WPFile FATFSALIGN_END;			/* Описатель открытого файла - нельзя располагать в Cortex-M4 CCM */
		static const char fmname [] = "tstdata.dat";
		static FATFSALIGN_BEGIN RAMNOINIT_D1 FATFS wave_Fatfs FATFSALIGN_END;		/* File system object  - нельзя располагать в Cortex-M4 CCM */
	
		int CountZap=0;
		int LC=2048;
		for (CountZap = 0; CountZap < 5; ++ CountZap)
		{
			GPIOG->ODR ^= WORKMASK;	// Debug LEDs
			hardware_spi_io_delay();
			local_delay_ms(500);
		}
		arm_hardware_piog_outputs(WORKMASK, 0);

		f_mount(& wave_Fatfs, "", 0);
		for (CountZap = 0; CountZap < 1000; ++ CountZap, sdtick())
		{
			debug_printf_P(PSTR("CountZap %d\n"), CountZap);
			int i;
			FRESULT rc;
			UINT ByteWrite;
			for (i=0;i<LC;i++)
			{
				Etalon[i]=i;
				TM[i]=0;
			}
			rc=f_open(&WPFile, fmname, FA_CREATE_ALWAYS | FA_WRITE);
			if (rc!=FR_OK)
				sdfault();

			rc=f_write (&WPFile, Etalon,LC*4,&ByteWrite );

			if (rc!=FR_OK)
				sdfault();
			rc=f_close (&WPFile);
			if (rc!=FR_OK)
				sdfault();
			rc=f_open(&WPFile, fmname, FA_OPEN_EXISTING | FA_READ);
			if (rc!=FR_OK)
				sdfault();
			rc=f_read (&WPFile, TM,LC*4,&ByteWrite );
			f_sync (&WPFile);
			if (rc!=FR_OK)
				sdfault();
			rc=f_close (&WPFile);
			if (rc!=FR_OK)
				sdfault();
			for (i=0;i<LC;i++)
			{
				if (TM[i]!=Etalon[i])
					sdfault();

			}
		}
		f_mount(NULL, "", 0);

		for (;;)
		{
			GPIOG->ODR ^= WORKMASK;	// Debug LEDs
			hardware_spi_io_delay();
			local_delay_ms(500);
		}
	}
#endif
#if 0 && __MPU_PRESENT
	{
		// Cortex Memory Protection Unit (MPU)
		debug_printf_P(PSTR("MPU=%p\n"), MPU);
		debug_printf_P(PSTR("MPU->TYPE=%08lX, MPU->CTRL=%08lX\n"), MPU->TYPE, MPU->CTRL);
		const uint_fast8_t n = (MPU->TYPE & MPU_TYPE_DREGION_Msk) >>MPU_TYPE_DREGION_Pos;
		uint_fast8_t i;
		for (i = 0; i < n; ++ i)
		{
			MPU->RNR = i;
			debug_printf_P(PSTR("MPU->RNR=%08lX, MPU->RBAR=%08lX, MPU->RASR=%08lX "), MPU->RNR, MPU->RBAR, MPU->RASR);
			const uint_fast32_t rasr = MPU->RASR;
			debug_printf_P(PSTR("XN=%u,AP=%u,TEX=%u,S=%u,C=%u,B=%u,SRD=%u,SIZE=%u,ENABLE=%u\n"),
				((rasr & MPU_RASR_XN_Msk) >> MPU_RASR_XN_Pos),   	// DisableExec
				((rasr & MPU_RASR_AP_Msk) >> MPU_RASR_AP_Pos),   	// AccessPermission
				((rasr & MPU_RASR_TEX_Msk) >> MPU_RASR_TEX_Pos),  	// TypeExtField
				((rasr & MPU_RASR_S_Msk) >> MPU_RASR_S_Pos),    	// IsShareable
				((rasr & MPU_RASR_C_Msk) >> MPU_RASR_C_Pos),    	// IsCacheable
				((rasr & MPU_RASR_B_Msk) >> MPU_RASR_B_Pos),    	// IsBufferable
				((rasr & MPU_RASR_SRD_Msk) >> MPU_RASR_SRD_Pos),  	// SubRegionDisable
				((rasr & MPU_RASR_SIZE_Msk) >> MPU_RASR_SIZE_Pos), 	// Size 512 kB
				((rasr & MPU_RASR_ENABLE_Msk) >> MPU_RASR_ENABLE_Pos)// Enable
				);
		}
	}
#endif
#if 0
	{
		// Сигналы управления HD44780
		for (;;)
		{
			// Установить
			//LCD_STROBE_PORT_S(LCD_STROBE_BIT);
			LCD_RS_PORT_S(ADDRES_BIT);
			//LCD_WE_PORT_S(WRITEE_BIT);
			local_delay_ms(20);

			// Сбросить
			//LCD_STROBE_PORT_C(LCD_STROBE_BIT);
			LCD_RS_PORT_C(ADDRES_BIT);
			//LCD_WE_PORT_C(WRITEE_BIT);
			local_delay_ms(20);
		}
	}
#endif
#if 0
	{
		// вычисления с плавающей точкой
		//
		//				   1.4142135623730950488016887242096981L
		// #define M_SQRT2  1.41421356237309504880

		//original: sqrt(2)=1.41421356237309514547462
		//double:   sqrt(2)=1.41421356237309514547462
		//float:    sqrt(2)=1.41421353816986083984375
		char b [64];
		
		//snprintf(b, sizeof b / sizeof b [0], "%u\n", (unsigned) SCB_GetFPUType());
		//debug_printf_P(PSTR("SCB_GetFPUType: %s"), b);

		snprintf(b, sizeof b / sizeof b [0], "sqrt(2)=%1.23f\n", (double) 1.41421356237309504880);
		debug_printf_P(PSTR("original: %s"), b);

		double d = sqrt(2);
		snprintf(b, sizeof b / sizeof b [0], "sqrt(2)=%1.23f\n", d);
		debug_printf_P(PSTR("double: %s"), b);

		float f = sqrtf(2);
		snprintf(b, sizeof b / sizeof b [0], "sqrt(2)=%1.23f\n", f);
		debug_printf_P(PSTR("float:  %s"), b);
	}
#endif
#if 0 && CTLSTYLE_V1V
	{
		// "прерыватель"

		#define RELAY_PORT PORTD	// выходы процессора - управление трактом ппередачи и манипуляцией
		#define RELAY_DDR DDRD		// переключение на вывод - управление трактом передачи и манипуляцией

		// Управление передатчиком - сигналы TXPATH_ENABLE (PA11) и TXPATH_ENABLE_CW (PA10) - активны при нуле на выходе.
		#define RELAY_BIT		(1U << PD5)

		RELAY_DDR |= RELAY_BIT;
		unsigned offtime = 100;
		unsigned ontime = 100;
		showstate(offtime, ontime);
		unsigned offt = offtime;
		unsigned ont = ontime;
		unsigned offphase = 0;
		for (;;)
		{
			uint_fast8_t kbch, repeat;

			if ((repeat = kbd_scan(& kbch)) != 0)
			{
				switch (kbch)
				{
				case KBD_CODE_8:
					ontime = modif (ontime, 100, 1, 100);
					break;
				case KBD_CODE_9:
					ontime = modif (ontime, 100, 99, 100);
					break;

				case KBD_CODE_4:
					ontime = modif (ontime, 10, 1, 10);
					break;
				case KBD_CODE_5:
					ontime = modif (ontime, 10, 99, 10);
					break;

				case KBD_CODE_0:
					ontime = modif (ontime, 1, 1, 10);
					break;
				case KBD_CODE_1:
					ontime = modif (ontime, 1, 99, 10);
					break;
				//
				case KBD_CODE_10:
					offtime = modif (offtime, 100, 1, 100);
					break;
				case KBD_CODE_11:
					offtime = modif (offtime, 100, 99, 100);
					break;

				case KBD_CODE_6:
					offtime = modif (offtime, 10, 1, 10);
					break;
				case KBD_CODE_7:
					offtime = modif (offtime, 10, 99, 10);
					break;

				case KBD_CODE_2:
					offtime = modif (offtime, 1, 1, 10);
					break;
				case KBD_CODE_3:
					offtime = modif (offtime, 1, 99, 10);
					break;


				}
				// Update times with new parameters
				offt = offtime;
				ont = ontime;
				showstate(offtime, ontime);
			}
			{
				if (offphase)
				{
					RELAY_PORT &= ~ RELAY_BIT;
					local_delay_ms(10);
					if (-- offt == 0)
					{
						offphase = 0;
						ont = ontime;
						if (ont == 0)
						{
							offphase = 1;
							offt = offtime;
						}
					}
				}
				else
				{
					RELAY_PORT |= RELAY_BIT;
					local_delay_ms(10);
					if (-- ont == 0)
					{
						offphase = 1;
						offt = offtime;
						if (offt == 0)
						{
							offphase = 0;
							ont = ontime;
						}
					}
				}
			}
		}


	}
#endif /* 1 && CTLSTYLE_V1V */
#if 0
	{
		colmain_setcolors(COLOR_GREEN, COLOR_BLACK);
		display_at_P(5, 0, PSTR("PT-Electronics 2015"));

		colmain_setcolors(COLOR_RED, COLOR_BLACK);
		display_at_P(7, 3, PSTR("RENESAS"));

		colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
		display_at_P(9, 6, PSTR("2.7 inch TFT"));
		
		for (;;)
			;
	}
#endif
#if 0
	{
		// Движущиеся картинки
		enum 
		{ 
			topreserved = 6,
			bufY = DIM_Y - GRID2Y(ROWS2GRID(topreserved)), 
			dx = DIM_X, dy = bufY, 
			// куда выводить
			DBX_0 = CHARS2GRID(0), 
			DBY_1 = ROWS2GRID(topreserved)
		};
		debug_printf_P(PSTR("test: dx=%d, dy=%d\n"), dx, dy);


		/* отображение надписей самым маленьким шрифтом (8 точек) */
		colmain_setcolors(COLOR_GREEN, COLOR_BLACK);
		uint_fast8_t lowhalf2 = HALFCOUNT_SMALL2 - 1;
		do
		{
		
			display_gotoxy(CHARS2GRID(0), ROWS2GRID(0) + lowhalf2);
			display_string2_P(PSTR("PT-Electronics 2017"), lowhalf2);
			//display_string2_P(PSTR("PT-Electronics 2015 RENESAS 2.7 inch TFT"), lowhalf2);

			//display_gotoxy(CHARS2GRID(0), CHARS2GRID(1) + lowhalf2);
			//display_string2_P(PSTR("PT-Electronics 2014"), lowhalf2);

		} while (lowhalf2 --);
	#if 1
		/* отображение надписей маленьким шрифтом (16 точек) */
		colmain_setcolors(COLOR_GREEN, COLOR_BLACK);
		
		display_at_P(CHARS2GRID(0), ROWS2GRID(1), PSTR("Start "));

		display_at_P(CHARS2GRID(0), ROWS2GRID(2), PSTR("Stop "));

	#endif

	#if 0//LCDMODE_COLORED

		static ALIGNX_BEGIN volatile PACKEDCOLOR565_T scr [GXSIZE(dx, dy)] ALIGNX_END;

		colpip_fill(scr, dx, dy, COLOR_WHITE);
		colpip_to_main(scr, dx, dy, 0, GRID2Y(topreserved));
		//for (;;)
		//	;
		int phase = 0;
		int count = 0;
		const int top = (DIM_X - bufY);
		unsigned loop;
		for (loop = 0; ;loop = loop < top ? loop + 1 : 0)
		{
		
			// рисование линии
			unsigned i;
			for (i = 0; i < bufY; ++ i)
				colpip_point(scr, dx, dy, i + loop, i, COLOR_BLUE);		// поставить точку

			colpip_to_main(scr, dx, dy, 0, GRID2Y(topreserved));
			//local_delay_ms(25);
			if (++ count > top)
			{
				count = 0;
				phase = ! phase;
				if (phase)
					colpip_fill(scr, dx, dy, COLOR_YELLOW);
				else
					colpip_fill(scr, dx, dy, COLOR_RED);
			}
			
		}
	#else /* LCDMODE_COLORED */

		static FATFSALIGN_BEGIN GX_t scr [MGSIZE(dx, dy)] FATFSALIGN_END;

		colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
		
		memset(scr, 0xFF, sizeof scr);
		display_showbuffer(scr, dx, dy, DBX_0, DBY_1);
		int phase = 0;
		int count = 0;
		const int top = (DIM_X - bufY);
		unsigned loop;
		for (loop = 0; ;loop = loop < top ? loop + 1 : 0)
		{
		
			// рисование линии
			unsigned i;
			for (i = 0; i < bufY; ++ i)
				display_pixelbuffer(scr, dx, dy, i + loop, i);		// погасить точку

			display_showbuffer(scr, dx, dy, DBX_0, DBY_1);
			//local_delay_ms(25);
			if (++ count > top)
			{
				count = 0;
				phase = ! phase;
				if (phase)
					colmain_setcolors(COLOR_YELLOW, COLOR_BLACK);
				else
					colmain_setcolors(COLOR_RED, COLOR_BLACK);
				memset(scr, 0xFF, sizeof scr);
			}
			
		}
	#endif /* LCDMODE_COLORED */
	}
#endif
#if 0 && WITHDEBUG
	{
		// тестирование приёма и передачи символов
		debug_printf_P(PSTR("Serial port ECHO test.\n"));
		for (;;)
		{
			char c;
			if (dbg_getchar(& c))
			{
				dbg_putchar(c);
				if (c == 0x1b)
					break;
			}
		}
}
#endif
#if 0
	// Тест для проверки корректности работы последовательного порта с прерываниями.
	// Должно работать просто "эхо" вводимых символов.
	{
		serial_irq_loopback_test();
	}
#endif
#if 0
	{
		debug_printf_P(PSTR("FPU tests start.\n"));
		local_delay_ms(300);
		//volatile int a = 10, b = 0;
		//volatile int c = a / b;
		unsigned long i;
		for (i = 0x8000000;; ++ i)
		{
			const double a = i ? i : 1;
			//const int ai = (int) (sin(a) * 1000);
			debug_printf_P(PSTR("Hello! %lu, sqrt(%lu)=%lu\n"), i, (unsigned) a, (unsigned)( sqrt(a)*10));
		}
	}
#endif
#if 0 && defined (RTC1_TYPE)
	{
		board_rtc_settime(10, 8, 0);
		board_rtc_setdate(2015, 9, 14);
	}
#endif
#if 0 && WITHDEBUG && WITHSDHCHW
	{
		// SD card control lines test
		HARDWARE_SDIOPOWER_INITIALIZE();
		HARDWARE_SDIOPOWER_SET(1);

		arm_hardware_piod_outputs((1U << 2), 1 * (1U << 2));	/* PD2 - SDIO_CMD	*/
		arm_hardware_pioc_outputs((1U << 12), 1 * (1U << 12));	/* PC12 - SDIO_CK	*/
		arm_hardware_pioc_outputs((1U << 8), 1 * (1U << 8));	/* PC8 - SDIO_D0	*/
		arm_hardware_pioc_outputs((1U << 9), 1 * (1U << 9));	/* PC9 - SDIO_D1	*/
		arm_hardware_pioc_outputs((1U << 10), 1 * (1U << 10));	/* PC10 - SDIO_D2	*/
		arm_hardware_pioc_outputs((1U << 11), 1 * (1U << 11));	/* PC11 - SDIO_D3	*/

		int i;
		for (i = 0;; ++ i)
		{
			int f0 = (i & (1 << 0)) != 0;
			int f1 = (i & (1 << 1)) != 0;
			int f2 = (i & (1 << 2)) != 0;
			int f3 = (i & (1 << 3)) != 0;
			int f4 = (i & (1 << 4)) != 0;
			int f5 = (i & (1 << 5)) != 0;

			arm_hardware_piod_outputs((1U << 2), f0 * (1U << 2));	/* PD2 - SDIO_CMD	*/
			arm_hardware_pioc_outputs((1U << 12), f1 * (1U << 12));	/* PC12 - SDIO_CK	*/
			arm_hardware_pioc_outputs((1U << 8), f2 * (1U << 8));	/* PC8 - SDIO_D0	*/
			arm_hardware_pioc_outputs((1U << 9), f3 * (1U << 9));	/* PC9 - SDIO_D1	*/
			arm_hardware_pioc_outputs((1U << 10), f4 * (1U << 10));	/* PC10 - SDIO_D2	*/
			arm_hardware_pioc_outputs((1U << 11), f5 * (1U << 11));	/* PC11 - SDIO_D3	*/

		}
	}
#endif
#if 0 && WITHDEBUG
	{
		debug_printf_P(PSTR("SD sensors test\n"));
		// SD card sensors test
		HARDWARE_SDIOSENSE_INITIALIZE();
		for (;;)
		{
			debug_printf_P(PSTR("SD sensors: CD=%d, WP=%d\n"), HARDWARE_SDIOSENSE_CD(), HARDWARE_SDIOSENSE_WP());
			local_delay_ms(50);
		}
	}
#endif
#if 0 && WITHDEBUG && WITHUSEAUDIOREC
	// SD CARD low level functions test
	{
		fatfs_test();
	}
#endif
#if 0 && WITHDEBUG && WITHUSEAUDIOREC
	// SD CARD file system level functions test
	// no interactive
	{

		FATFSALIGN_BEGIN BYTE work [FF_MAX_SS] FATFSALIGN_END;
		FRESULT rc;
//
//		static const MKFS_PARM defopt = { FM_ANY, 0, 0, 0, 0};	/* Default parameter */
//		defopt.fmt = FM_ANY;	/* Format option (FM_FAT, FM_FAT32, FM_EXFAT and FM_SFD) */
//		defopt.n_fat = 2;		/* Number of FATs */
//		defopt.align = 0;		/* Data area alignment (sector) */
//		defopt.n_root = 128;	/* Number of root directory entries */
//		defopt.au_size = 0;		/* Cluster size (byte) */

		PRINTF("Wait for storage device ready\n");
		while (hamradio_get_usbh_active() == 0)
			sdcardbgprocess();
		PRINTF("Storage device ready\n");
		unsigned t;
		for (t = 0; t < 7000; t += 5)
		{
			sdcardbgprocess();
			local_delay_ms(5);
		}
		static ticker_t test_recordticker;
		system_disableIRQ();
		ticker_initialize(& test_recordticker, 1, test_recodspool, NULL);	// вызывается с частотой TICKS_FREQUENCY (например, 200 Гц) с запрещенными прерываниями.
		system_enableIRQ();
		{
 			f_mount(NULL, "", 0);		/* Unregister volume work area (never fails) */
			rc = f_mkfs("0:", NULL, work, sizeof (work));
			if (rc != FR_OK)
			{
				debug_printf_P(PSTR("sdcardformat: f_mkfs failure, rc=0x%02X\n"), (int) rc);
				return;
			}
			else
			{
				debug_printf_P(PSTR("sdcardformat: f_mkfs okay\n"));
			}

		}
		for (;;)
		{
			debug_printf_P(PSTR("Storage device test - %d bytes block.\n"), sizeof rbuff);
			PRINTF("Storage device test\n");
			fatfs_filesyspeedstest();
			for (t = 0; t < 7000; t += 5)
			{
				sdcardbgprocess();
				local_delay_ms(5);
			}
		}

	}
#endif
#if 0 && WITHDEBUG && WITHUSEAUDIOREC
	// SD CARD file system level functions test
	{
		static ticker_t test_recordticker;
		system_disableIRQ();
		ticker_initialize(& test_recordticker, 1, test_recodspool, NULL);	// вызывается с частотой TICKS_FREQUENCY (например, 200 Гц) с запрещенными прерываниями.
		system_enableIRQ();
		fatfs_filesystest();
	}
#endif
#if 0 && WITHDEBUG && WITHUSEAUDIOREC
	// Автономный программатор SPI flash memory
	{
		//fatfs_test();
		////mmcCardSize();
		////mmcCardSize();
		fatfs_progspi();
	}
#endif
#if 0
	{
		// VFP tests, double
		unsigned long i;
		for (i = 0x8000000;; ++ i)
		{
			const double a = i ? i : 1;
			//const int ai = (int) (sin(a) * 1000);

			debug_printf_P(PSTR("Hello! %lu, sqrt(%lu)=%lu\n"), i, (unsigned) a, (unsigned) sqrt(a));

		}
	}
#endif
#if 0 && CPUSTYLE_R7S721
	{
		// RZ board leds test
		//i2c_initialize();

		arm_hardware_pio7_outputs(LEDBIT, LEDBIT);	/* ---- P7_1 : LED0 direct connection to IP */
		arm_hardware_pio1_inputs(SW1BIT);	/*  */
		ledsinit();

		for (;;)
		{
			leds(0x01);
			local_delay_ms(100);
			leds(0x02);
			local_delay_ms(100);
			leds(0x04);
			local_delay_ms(100);
	#if 1
			if (GPIO.PPR1 & SW1BIT)
			{
				GPIO.P7 |= LEDBIT;
				leds(1);
			}
			else
			{
				GPIO.P7 &= ~ LEDBIT;
				leds(0);
			}
			continue;
	#endif
			//R_LED_On();
			//GPIO.PNOT7 = LEDBIT;
			LED_TARGET_PORT_S(LEDBIT);	// Led OFF
			__DSB();
			local_delay_ms(1000);
			//R_LED_Off();
			//GPIO.PNOT7 = LEDBIT;
			LED_TARGET_PORT_C(LEDBIT);	// Led ON
			__DSB();
			local_delay_ms(5000);
		}
	}
#endif
#if 0 && ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED
	// note: rdx0154 should be enabled (for I2C functions include).
	{
		test_cpu_pwron(1);
		eink_lcd_backlight(1);
		// M9546 (PCF8576C) support functions
		LCD1x9_Initialize();

		if (0)
		{
			// получение номеров сегментов LCD
			int segment = 0;
			LCD1x9_seg(segment, 1);
			for (;;)
			{

				uint_fast8_t kbch, repeat;

				if ((repeat = kbd_scan(& kbch)) != 0)
				{
					switch (kbch)
					{
					case KBD_CODE_0:
						LCD1x9_seg(segment, 0);
						if (++ segment >= MAXSEGMENT)
							segment = 0;
						LCD1x9_seg(segment, 1);
						debug_printf_P(PSTR("seg = %d\n"), segment);
						break;

					case KBD_CODE_1:
						LCD1x9_seg(segment, 0);
						if (segment == 0)
							segment = MAXSEGMENT - 1;
						else
							-- segment;
						LCD1x9_seg(segment, 1);
						debug_printf_P(PSTR("seg = %d\n"), segment);
						break;
					}
				}
			}
		}
		for (;;)
		{

			lcd_outarray(pe2014, sizeof pe2014 / sizeof pe2014 [0]);
			int t;
			for (t = 0; t < 100; ++ t)
			{
				local_delay_ms(50);
				check_poweroff();
			}
			LCD1x9_clear();
			{
				// Зажигаем все сегменты
				uint_fast8_t comIndex;
				for (comIndex = 0; comIndex < 4; ++ comIndex)
				{
					uint_fast8_t bitIndex;
					for (bitIndex = 0; bitIndex < 40; ++ bitIndex)
					{
						check_poweroff();
						LCD1x9_enableSegment(comIndex, bitIndex);
						LCD1x9_Update();
						local_delay_ms(50);
					}
				}
			}
			{
				// Гасим все сегменты
				uint_fast8_t comIndex;
				for (comIndex = 0; comIndex < 4; ++ comIndex)
				{
					uint_fast8_t bitIndex;
					for (bitIndex = 0; bitIndex < 40; ++ bitIndex)
					{
						check_poweroff();
						LCD1x9_disableSegment(comIndex, bitIndex);
						LCD1x9_Update();
						local_delay_ms(50);
					}
				}
			}
		}

		for (;;)
			;
	}
#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */
#if 0 && ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED
	{
		test_cpu_pwron(1);
		// EM027BS013 tests
		eink_initialize();
		for (;;)
			;
	}
#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */
#if 0 && ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED
	{
		// проверка кнопок включения-выключени я питания
		test_cpu_pwron(1);
		for (;;)
		{
			local_delay_ms_spool(1000);
		}
	}
#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */
#if 1 && ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED
	{
		test_cpu_pwron(1);
		//EPD_power_init(EPD_200);

		EPD_display_init();
		for(;;) {
			debug_printf_P(PSTR("eink: loop start\n"));
			/* User selects which EPD size to run demonstration by changing the
			 * USE_EPD_Type in image_data.h
			 * The Image data arrays for each EPD size are defined at image_data.c */
	#if (USE_EPD_Type==USE_EPD144)
			EPD_display_from_pointer(EPD_144,image_array_144_2,image_array_144_1);
	#elif (USE_EPD_Type==USE_EPD200)
			EPD_display_from_pointer(EPD_200,image_array_200_2,image_array_200_1);
	#elif (USE_EPD_Type==USE_EPD270)
			EPD_display_from_pointer(EPD_270,image_array_270_2,image_array_270_1);
	#endif

			/* The interval of two images alternatively change is 10 seconds */
			//local_delay_ms(10000);
			local_delay_ms_spool(1000);

	#if (USE_EPD_Type==USE_EPD144)
			EPD_display_from_pointer(EPD_144,image_array_144_1,image_array_144_2);
	#elif (USE_EPD_Type==USE_EPD200)
			EPD_display_from_pointer(EPD_200,image_array_200_1,image_array_200_2);
	#elif (USE_EPD_Type==USE_EPD270)
			EPD_display_from_pointer(EPD_270,image_array_270_1,image_array_270_2);
	#endif

			/* The interval of two images alternatively change is 10 seconds */
			//local_delay_ms(10000);
			local_delay_ms_spool(2000);
			debug_printf_P(PSTR("eink: loop end\n"));
		}
	}
#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */
#if 0
	{
		//hardware_tim21_initialize();
		for (;;)
		{
			debug_printf_P(PSTR("TIM21 CNT=%08lX\n"), TIM21->CNT);
		}
	}
#endif
#if 0
	{
		// test: initialize TIM2:TIM5
		// TIM5 включён на выход TIM2
		RCC->APB1ENR |= RCC_APB1ENR_TIM2EN | RCC_APB1ENR_TIM5EN;   // подаем тактирование на TIM2 & TIM5
		__DSB();
		//TIM3->DIER = TIM_DIER_UIE;        	 // разрешить событие от таймера
		TIM5->PSC = 1;
		TIM2->PSC = 1;

		TIM5->CR1 = TIM_CR1_CEN; /* включить таймер */
		TIM2->CR1 = TIM_CR1_CEN; /* включить таймер */
		for (;;)
		{
			debug_printf_P(PSTR("TIM2:TIM5 CNT=%08lX:%08lX\n"), TIM2->CNT, TIM5->CNT);
		}
	}
#endif
#if 0 && LCDMODE_COLORED && ! DSTYLE_G_DUMMY
	{
		display2_bgreset();
		//GrideTest();
		BarTest();
	}
#endif
#if 0 && WITHLTDCHW && LCDMODE_COLORED && ! DSTYLE_G_DUMMY
	{
		// test: вывод палитры на экран
		display2_bgreset();
		PACKEDCOLORMAIN_T * const fr = colmain_fb_draw();
		int sepx = 3, sepy = 3;
		int wx = DIM_X / 16;
		int wy = DIM_Y / 16;
		int x = 0, y = 0;

		for (int i = 0; i <= 255; i++)
		{

			display_solidbar(x, y, x + wx - sepx, y + wy - sepy, i);

			if (wx > 24)
			{
				char buf [4];
				local_snprintf_P(buf, sizeof buf / sizeof buf [0], PSTR("%d"), i);
				colpip_string3_tbg(fr, DIM_X, DIM_Y, x, y, buf, COLORMAIN_WHITE);
			}

			x = x + wx;
			if ((i + 1) % 16 == 0)
			{
				x = 0;
				y = y + wy;
			}
		}

		arm_hardware_flush((uintptr_t) fr, (uint_fast32_t) DIM_X * DIM_Y * sizeof (PACKEDCOLORMAIN_T));
		arm_hardware_ltdc_main_set((uintptr_t) fr);
		for (;;)
			;
	}
#endif
#if 0 && defined (TSC1_TYPE)
#include "touch\touch.h"

	{
		uint_fast16_t gridx = 16;
		uint_fast16_t gridy = 16;
		uint_fast16_t markerx = 0;
		uint_fast16_t markery = 0;

		display2_bgreset();
		colmain_setcolors(COLORMAIN_WHITE, COLORMAIN_BLACK);

			// touch screen test
			for (;;)
			{
				PACKEDCOLORMAIN_T * const fr = colmain_fb_draw();

				uint_fast16_t x, y;
				if (board_tsc_getxy(& x, & y))
				{
					debug_printf_P(PSTR("board_tsc_getxy: x=%5d, y=%5d\n"), x, y);
					colmain_fillrect(fr, DIM_X, DIM_Y, markerx, markery, gridx, gridy, COLORMAIN_BLACK);
					markerx = x / gridx * gridx;
					markery = y / gridy * gridy;
					colmain_fillrect(fr, DIM_X, DIM_Y, markerx, markery, gridx, gridy, COLORMAIN_WHITE);
					display_at(22, 26,"Pressed");
				} else {
					display_at(22, 26,"       ");
					colmain_fillrect(fr, DIM_X, DIM_Y, markerx, markery, gridx, gridy, COLORMAIN_BLACK);
				}
				local_delay_ms(10);

				arm_hardware_flush((uintptr_t) fr, (uint_fast32_t) DIM_X * DIM_Y * sizeof (PACKEDCOLORMAIN_T));
				arm_hardware_ltdc_main_set((uintptr_t) fr);
			}

		}

#endif
#if 0 && (CTLSTYLE_V1E || CTLSTYLE_V1F)
	{
		//int n = TIM6_DAC_IRQn;
		unsigned long i = 0;
		colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
		for (;;)
		{
			++ i;
			uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;
			do
			{
				char buff [22];

				// IF gain
				local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
					PSTR("CNT=%08lX"), i
					 );

				display_gotoxy(0, 0 + lowhalf);
				colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
				display_at(buff, lowhalf);
			} while (lowhalf --);
			debug_printf_P(PSTR("CNT=%08lX\n"), i);
		}
	}
	{
		// PB8 signal
		enum { WORKMASK = 1ul << 0 };
		arm_hardware_pioa_outputs(WORKMASK, WORKMASK);

		for (;;)
		{
			GPIOA->ODR ^= WORKMASK;	// Debug LEDs
			//hardware_spi_io_delay();
		}
	}
#endif
#if 0 && WITHNMEA
	// NMEA test
	{
		for (;;)
		{
			char buff [32];
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], PSTR("%02d:%02d:%02d,ky=%d"), 
				th.hours, th.minutes, th.secounds, 
				HARDWARE_NMEA_GET_KEYDOWN());

			uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;
			do
			{
				display_gotoxy(0, 0 + lowhalf);

				display_at(buff, lowhalf);
			} while (lowhalf --);
		}
	}
#endif
#if 0 && WITHDEBUG
	// NVRAM test
	{
		debug_printf_P(PSTR("NVRAM test started...\n"));
		nvram_initialize();
		unsigned char i = 0;
		for (;; ++ i)
		{
			save_i8(10, 0x55);
			save_i8(20, 0xaa);
			save_i8(30, i);
			const uint_fast8_t v1 = restore_i8(10);
			const uint_fast8_t v2 = restore_i8(20);
			const uint_fast8_t v3 = restore_i8(30);
			debug_printf_P(PSTR("v1=%02x, v2=%02x, v3=%02x (expected=%02x)\n"), v1, v2, v3, i);
			local_delay_ms(50);
		}
		for (;;)
			;
	}
#endif

#if 0 && defined (RTC1_TYPE) && WITHDEBUG

	/* RTC test */
	{
		////board_rtc_initialize(); // already done
		//board_rtc_settime(22, 48, 30);
		//board_rtc_setdate(2015, 5, 3);
		
		for (;;)
		{
			uint_fast16_t year;
			uint_fast8_t month, day;
			uint_fast8_t hour, minute, secounds;

			//board_rtc_getdate(& year, & month, & day);
			//board_rtc_gettime(& hour, & minute, & secounds);

			//debug_printf_P(PSTR("%04d-%02d-%02d "), year, month, day);
			//debug_printf_P(PSTR("%02d:%02d:%02d "), hour, minute, secounds);

			board_rtc_getdatetime(& year, & month, & day, & hour, & minute, & secounds);

			debug_printf_P(PSTR("%04d-%02d-%02d "), year, month, day);
			debug_printf_P(PSTR("%02d:%02d:%02d\n"), hour, minute, secounds);

			local_delay_ms(1250);
			
		}
	}
#endif
#if 0 && WITHDEBUG
	/* ADC test */
	{

		for (;;)
		{
			uint_fast8_t i;
			for (i = 0; i < 8; ++ i)
			{
				//const uint_fast8_t i = AVOXIX; //KI2;
				debug_printf_P(PSTR("ADC%d=%3d "), i, board_getadc_unfiltered_u8(i, 0, 255));
				//debug_printf_P(PSTR("ADC%d=%3d "), i, board_getadc_unfiltered_truevalue(i));
			}
			debug_printf_P(PSTR("\n"));
		}
	}
#endif
#if 0 && WITHDEBUG
	/* ADC test on screen*/
	{
		// see HARDWARE_ADCINPUTS 
		enum { NADC = 8, COLWIDTH = 8 };
		unsigned long cnt = 0;
		for (;; ++ cnt)
		{
			uint_fast8_t i;
			for (i = 0; i < NADC; ++ i)
			{
				char buff [32];

				local_snprintf_P(buff, sizeof buff / sizeof buff [0],
					PSTR("V%d=%4d"), i, board_getadc_unfiltered_truevalue(i)); 
				display_at(COLWIDTH * (i % 2), i / 2, buff);
			}
			if (0)
			{
				char buff [32];
				local_snprintf_P(buff, sizeof buff / sizeof buff [0],
					PSTR("CNT=%08lX"), cnt); 
				display_at(8 * (i % 2), i / 2, buff);
			}
		}
	}
#endif
#if 0
	// отображение картинок
	eink_lcd_backlight(1);

	/* буфер размером x=64, y=112 точек */
	enum { bufY = DIM_Y - 8, dx = DIM_X, dy = /*24 */ bufY, DBX_0 = 0, DBY_1 = 1};
	static FATFSALIGN_BEGIN PACKEDCOLORMAIN_T scr [GXSIZE(dx, dy)] FATFSALIGN_END;


	/* отображение надписей самым маленьким шрифтом (8 точек) */
	display_at_P(CHARS2GRID(0), ROWS2GRID(0), PSTR("PT-Electronics 2014"));

#if 0
	/* отображение надписей маленьким шрифтом (16 точек) */
	display_at_P(CHARS2GRID(0), ROWS2GRID(2), PSTR("Start "));

	display_at_P(CHARS2GRID(0), ROWS2GRID(3), PSTR("Stop "));
#endif

	colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
	unsigned loop;
	for (loop = 0; ;loop = loop < (DIM_X - bufY) ? loop + 1 : 0)
	{
	
		check_poweroff();
		memset(scr, 0xFF, sizeof scr);
		// рисование линии
		unsigned i;
		for (i = 0; i < bufY; ++ i)
			display_pixelbuffer(scr [0], dx, dy, i + loop, i);		// погасить точку

		display_showbuffer(scr [0], dx, dy, DBX_0, DBY_1);
		local_delay_ms(25);
		
	}
#endif
#if 0 && WITHDEBUG
	// вечный цикл
	for (;;)
	{
		i2c_start(0xaa);// Si570: адрес 0x55, запись = 0
		i2c_write(135);
		i2c_write(0x80);	// RST_REG = 1 - выключает генерацию на выходе Si570
		i2c_waitsend();
		i2c_stop();
			
		_delay_ms(20);
	}
#endif
#if 0 && WITHTX && WITHVOX && WITHDEBUG
	// Отображение значений с выхода DSP модуля - уровень VOX
	{
		updateboard(1, 1);	/* полная перенастройка (как после смены режима) - режим приема */
		updateboard2();			/* настройки валкодера и цветовой схемы дисплея. */
		for (;;)
		{
			//unsigned dsp_getmikev(void);
			//unsigned vox1 = dsp_getmikev();
			unsigned vox2 = board_getvox();
			unsigned avox = board_getavox();
			uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;
			do
			{
				char buff [22];

				//////////////////////////
				// VOX level
				local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
					PSTR("vox2=%3d"), vox2
					 );
				display_gotoxy(0, 0 + lowhalf);
				display_at(buff, lowhalf);

				//////////////////////////
				// VOX2 level
				/*
				local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
					PSTR("vox1=%5d"), vox1
					 );
				display_gotoxy(0, 1 + lowhalf);
				display_at(buff, lowhalf);
				*/
				//////////////////////////
				// A-VOX level
				local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
					PSTR("avox=%3d"), avox
					 );
				display_gotoxy(11, 0 + lowhalf);
				display_at(buff, lowhalf);

			} while (lowhalf --);
		}
	}
#endif
#if 0 && WITHDEBUG
	// Трансивер с DSPIF4 "Вороненок-DSP"
	// Отображение значений с дополнительных входов АЦП
	for (;;)
	{
		if (! display_refreshenabled_wpm())
			continue;
		// подтверждаем, что обновление выполнено
		display_refreshperformed_wpm();

		//const unsigned potrf = board_getadc_filtered_u8(POTIFGAIN, 0, UINT8_MAX);
		const unsigned potrft = board_getadc_unfiltered_truevalue(POTIFGAIN);
		const unsigned potrf = board_getpot_filtered_truevalue(POTIFGAIN);

		//const unsigned potaf = board_getadc_smoothed_u8(POTAFGAIN, BOARD_AFGAIN_MIN, BOARD_AFGAIN_MAX);
		const unsigned potaft = board_getadc_unfiltered_truevalue(POTAFGAIN);
		const unsigned potaf = board_getpot_filtered_truevalue(POTAFGAIN);

		//const unsigned aux1 = board_getadc_filtered_u8(POTAUX1, 0, UINT8_MAX);
		//const unsigned aux2 = board_getadc_filtered_u8(POTAUX2, 0, UINT8_MAX);
		//const unsigned aux3 = board_getadc_filtered_u8(POTAUX3, 0, UINT8_MAX);
#if WITHPOTWPM
		const unsigned wpm = board_getpot_filtered_u8(POTWPM, 0, UINT8_MAX);
#endif /* WITHPOTWPM */

		uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;
		do
		{
			char buff [22];

#if 1
			// сокращённый вариант отображения
			// AF gain
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("af= %4d"), potaf
				 );
			display_gotoxy(0, 0 * HALFCOUNT_SMALL + lowhalf);
			display_at(buff, lowhalf);
			// AF gain raw
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("aft=%4d"), potaft
				 );
			display_gotoxy(0, 1 * HALFCOUNT_SMALL + lowhalf);
			display_at(buff, lowhalf);
			continue;
#else
			// IF gain
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("rf= %4d"), potrf
				 );
			display_gotoxy(0, 0 + lowhalf);
			display_at(buff, lowhalf);
			// AF gain
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("af= %4d"), potaf
				 );
			display_gotoxy(7, 0 + lowhalf);
			display_at(buff, lowhalf);

			// AUX1
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("A1= %4d"), aux1
				 );
			display_gotoxy(14, 0 + lowhalf);
			display_at(buff, lowhalf);

			// AUX2
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("A2= %4d"), aux2
				 );
			display_gotoxy(0, 1 + lowhalf);
			display_at(buff, lowhalf);

			// AUX3
			/*
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("A3=%3d"), aux3
				 );
			display_gotoxy(7, 1 + lowhalf);
			display_at(buff, lowhalf);
			*/
#if WITHPOTWPM
			// WPM
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("cw=%3d"), wpm
				 );
			display_gotoxy(14, 1 + lowhalf);
			display_at(buff, lowhalf);
#endif /* WITHPOTWPM */

			// IF gain raw
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("rft=%4d"), potrft
				 );
			display_gotoxy(0, 2 + lowhalf);
			display_at(buff, lowhalf);
			// AF gain raw
			local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
				PSTR("aft=%4d"), potaft
				 );
			display_gotoxy(10, 2 + lowhalf);
			display_at(buff, lowhalf);
#endif

		} while (lowhalf --);


	}
#endif
#if 0 && WITHDEBUG
	// тест дисплея - вывод меняющихся цифр
	{
		unsigned long i = 0;
		colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
		for (;;)
		{
			++ i;
			uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;
			do
			{
				char buff [22];

				// IF gain
				local_snprintf_P(buff, sizeof buff / sizeof buff [0], 
					PSTR("CNT=%08lX"), i
					 );

				display_gotoxy(0, 0 + lowhalf);
				colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
				display_at(buff, lowhalf);
			} while (lowhalf --);
		}
	}
#endif
#if 0
	// тест дисплея - проход по всем возможным уровням основных цветов
	for (;;)
	{
		char b [32];
		int c;
		// COLORMAIN_T bg
		for (c = 0; c < 256; ++ c)
		{
			display_setbgcolor(TFTRGB(c, c, c));
			display2_bgreset();
			local_snprintf_P(b, sizeof b / sizeof b [0], PSTR("WHITE %-3d"), c);
			colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
			display_at(0, 0, b);
			local_delay_ms(50);
		}
		//for (; c -- > 0; )
		//{
		//	display_setbgcolor(TFTRGB(c, c, c));
		//	display2_bgreset();
		//}
		for (c = 0; c < 256; ++ c)
		{
			display_setbgcolor(TFTRGB(c, 0, 0));
			display2_bgreset();
			local_snprintf_P(b, sizeof b / sizeof b [0], PSTR("RED %-3d"), c);
			colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
			display_at(0, 0, b);
			local_delay_ms(50);
		}
		//for (; c -- > 0; )
		//{
		//	display_setbgcolor(TFTRGB(c, 0, 0));
		//	display2_bgreset();
		//}
		for (c = 0; c < 256; ++ c)
		{
			display_setbgcolor(TFTRGB(0, c, 0));
			display2_bgreset();
			local_snprintf_P(b, sizeof b / sizeof b [0], PSTR("GREEN %-3d"), c);
			colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
			display_at(0, 0, b);
			local_delay_ms(50);
		}
		//for (; c -- > 0; )
		//{
		//	display_setbgcolor(TFTRGB(0, c, 0));
		//	display2_bgreset();
		//}
		for (c = 0; c < 256; ++ c)
		{
			display_setbgcolor(TFTRGB(0, 0, c));
			display2_bgreset();
			local_snprintf_P(b, sizeof b / sizeof b [0], PSTR("BLUE %-3d"), c);
			colmain_setcolors(COLOR_WHITE, COLOR_BLACK);
			display_at(0, 0, b);
			local_delay_ms(50);
		}
		//for (; c -- > 0; )
		//{
		//	display_setbgcolor(TFTRGB(0, 0, c));
		//	display2_bgreset();
		//}
	}
#endif
#if 0 && WITHDEBUG
	{
		//synth_lo1_setfreq(99000000, getlo1div(tx));
		//for (;;)
		//{
		//}


		unsigned long if1 = 73050000ul;
		unsigned long freq;
		for (freq = 0; freq < (56000000 + 50000); freq += 1)
		//for (freq = 28000000; freq < (29700000); freq += 1000)
		{
			synth_lo1_setfreq(freq + if1, getlo1div(tx));
			///*
			if ((freq % 1000) == 0)
			{
				static int cd;
				char buff [22];
				//unsigned char v1, v2;
				display_gotoxy(0, 4);
				local_snprintf_P(buff, sizeof buff / sizeof buff [0], PSTR("%10lu"), freq );
				display_at(buff, 0);
				ITM_SendChar('a' + (cd ++) % 16);
				//SWO_PrintChar('a' + (cd ++) % 16);

			}
			//*/


		}
		for (;;)
		{
		}

	}

#endif
#if 0
	{
		static char buff [22];
		unsigned char v1, v2;
		//v1 = si570_get_status();
		display_gotoxy(0, 6);
		local_snprintf_P(buff, 22, PSTR("he %08lX:%08lX"), 0x1726354aul, -7ul);
		display_at(buff, 0);

		display_gotoxy(0, 7);
		//unsigned long l1 = (unsigned long) (rftw >> 32);
		//unsigned long l2 = (unsigned long) rftw;
		local_snprintf_P(buff, 22, PSTR("he %08lx"), -4000000l);
		display_at(buff, 0);
		for (;;)
			;
	}
#endif
#if 0
	{
		// Проверка, откуда идут помехи - от I2C или от SPI.
		for (;;)
		{

			uint_fast8_t kbch, repeat;

			if ((repeat = kbd_scan(& kbch)) != 0)
			{
				int i;
				switch (kbch)
				{
				case KBD_CODE_BAND_UP:
					// проверка индикатора
					for (i = 0; i < 20000; ++ i)
					{
						char s [21];
						local_snprintf_P(s, sizeof s / sizeof s [0], PSTR("%08lx    "), (unsigned long) i);
						display_menu_label(s);
					}
					break;
				case KBD_CODE_BAND_DOWN:
					// проверка SPI
					for (i = 0; i < 10000; ++ i)
					{
						synth_lo1_setfreq(i, getlo1div(tx));
					}
					break;
				}
			}
		}
	}
#endif
#if 0
	// Тестирование скорости передачи по SPI. На SCK должна быть частота SPISPEED
	for (;;)
	{
		const spitarget_t cs = SPI_CSEL4;
		spi_select(cs, SPIC_MODE3);
		spi_progval8_p1(cs, 0xff);
		//for (;;)
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
			spi_progval8_p2(cs, 0x55);
		spi_complete(cs);
		spi_unselect(cs);
	}
#endif
#if 0
	{
		unsigned phase = 0;
		// тестирование входов манипуляции, ptt, ключа и CAT
		for (;;)
		{
			uint_fast8_t kbch, repeat;

			if ((repeat = kbd_scan(& kbch)) != 0)
			{
				//display_dispfreq(kbch * 1000UL + v);
				//v = (v + 10) % 1000;
			}
			unsigned tune1 = hardware_get_tune();
			unsigned ptt1 = hardware_get_ptt();
			unsigned ptt2 = HARDWARE_CAT_GET_RTS();
			system_disableIRQ();
			unsigned elkey = hardware_elkey_getpaddle(0);
			unsigned ckey = HARDWARE_CAT_GET_DTR();
			system_enableIRQ();


			debug_printf_P(PSTR("tune=%u, ptt=%u, elkey=%u\n"), tune1, ptt1, elkey);
			continue;

			display_gotoxy(0, 0);		// курсор в начало первой строки


			display_at(ptt1 != 0 ? "ptt " : "    ", 0);
			display_at(ptt2 != 0 ? "cptt " : "     ", 0);
			display_at(ckey != 0 ? "ckey " : "     ", 0);

			display_gotoxy(0, 2);		// курсор в начало второй строки
			display_at((elkey & ELKEY_PADDLE_DIT) != 0 ? "dit " : "     ", 0);
			display_gotoxy(0, 4);		// курсор в начало второй строки
			display_at((elkey & ELKEY_PADDLE_DASH) != 0 ? "dash" : "      ", 0);
			display_gotoxy(0, 6);		// курсор в начало второй строки
			display_at((phase = ! phase) ? " test1" : " test2", 0);

		}
	}
#endif
#if 0
	{
		// тестирование валкодера в режиме "интеллектуального ускорения"
		// На индикаторе отображается скорость в оборотах в секунду
		for (;;)
		{
			unsigned speed;
			int nrotate = encoder_get_snapshot(& speed, 1);
			uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;
			do
			{
				display_gotoxy(0, 0 + lowhalf);
				display2_menu_value(speed * 100UL / ENCODER_NORMALIZED_RESOLUTION, 7, 2, 0, lowhalf);
				display_gotoxy(0, HALFCOUNT_SMALL + lowhalf);
				display2_menu_value(nrotate, 5 | WSIGNFLAG, 255, 0, lowhalf);
				local_delay_ms(100);
			} while (lowhalf --);
			//(void) nrotate;
			//display_debug_digit(speed * 100UL / ENCODER_NORMALIZED_RESOLUTION, 7, 2, 0);
			//enum { lowhalf = 0 };
			//display_gotoxy(0, 1 + lowhalf);		// курсор в начало второй строки
		}
	}
#endif
#if 0
	{
		// тестирование валкодера в режиме "интеллектуального ускорения"
		// На индикаторе отображается скорость в оборотах в секунду
		for (;;)
		{
			uint_fast8_t jumpsize;
			int_least16_t nrotate = getRotateHiRes(& jumpsize, 1);
			(void) nrotate;
			//display_gotoxy(0, 1);		// курсор в начало второй строки
			display_debug_digit(jumpsize, 7, 0, 0);
		}
	}
#endif
#if 0
	// Показ в одной строке трех значений с АЦП клавиатуры
	for (;;)
	{
		uint_fast8_t row;
		uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;

		do
		{
			display_gotoxy(0, 0 + lowhalf);
			display2_menu_value(board_getadc_unfiltered_u8(KI0, 0, UINT8_MAX), 5, 255, 0, lowhalf);
			display_gotoxy(5, 0 + lowhalf);
			display2_menu_value(board_getadc_unfiltered_u8(KI1, 0, UINT8_MAX), 5, 255, 0, lowhalf);
			display_gotoxy(10, 0 + lowhalf);
			display2_menu_value(board_getadc_unfiltered_u8(KI2, 0, UINT8_MAX), 5, 255, 0, lowhalf);
		} while (lowhalf --);
		//
		local_delay_ms(20);
	}
#endif

#if 0
	for (;;)
	{
		uint_fast8_t row;
		for (row = 0; row < 8; ++ row)
		{
			//
			const uint_fast8_t v0 = board_getadc_unfiltered_u8(row, 0, UINT8_MAX); 
			uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;

			do
			{
				display_gotoxy(0, row * HALFCOUNT_SMALL + lowhalf);		// курсор в начало второй строки
				display_at("ADCx=", lowhalf);
				display_gotoxy(5, row * HALFCOUNT_SMALL + lowhalf);		// курсор в начало второй строки
				display2_menu_value(v0, 5, 255, 0, lowhalf);
			} while (lowhalf --);
		}
		//
		local_delay_ms(20);
	}
#endif

#if 0
	{
		debug_printf_P(PSTR("kbd_test2:\n"));
		// kbd_test2
		// Показ условных номеров клавиш для создания новых матриц перекодировки
		// и тестирования работоспособности клавиатуры.
		enum { menuset = 0 };
		int v = 0;
		for (;;)
		{
			//debug_printf_P(PSTR("keyport = %02x\n"), (unsigned) KBD_TARGET_PIN);
			//continue;
			
			uint_fast8_t scancode;
			system_disableIRQ();
			scancode = board_get_pressed_key();
			system_enableIRQ();

			if (scancode != KEYBOARD_NOKEY)
			{
				debug_printf_P(PSTR("keycode = %02x, %d\n"), (unsigned) scancode, v);
				v = (v + 1) % 1000;
			}
			continue;

			if (scancode != KEYBOARD_NOKEY)
				display2_dispfreq_a2(scancode * 1000UL + v, 255, 0, menuset);
			else
			{
				display2_dispfreq_a2(v * 1000UL, 255, 0, menuset);
				v = (v + 1) % 1000;
			}
		}
	}
#endif

#if 0
	{
		// kbd_test1
		// показ кодов клавиш
		enum { menuset = 0 };
		int v = 0;
		debug_printf_P(PSTR("kbd_test1:\n"));
		for (;;)
		{
			uint_fast8_t kbch, repeat;

			if ((repeat = kbd_scan(& kbch)) != 0)
			{
				debug_printf_P(PSTR("kbch = %02x\n"), (unsigned) kbch);
				continue;
				display2_dispfreq_a2(kbch * 1000UL + v, 255, 0, menuset);
				v = (v + 10) % 1000;
			}
		}
	}
#endif

#if 0
	// test SPI lines (ATT functions)
	{
		int i = 0;
		for (;;)
		{
			board_set_att(i);
			board_update();		/* вывести забуферированные изменения в регистры */
			i = (i + 1) % ATTMODE_COUNT;
			local_delay_ms(500);
		}
	}
#endif

#if 0
	// test SPI lines (band selection hardware)
	{
		int i = 0;
		for (;;)
		{
			board_set_bandf(i);
			board_update();		/* вывести забуферированные изменения в регистры */
			i = (i + 1) % 16;
			local_delay_ms(500);
		}
	}
#endif

#if 0
	// test relays (preapm)
	{
		for (;;)
		{
			int pre;
			for (pre = 0; pre < PAMPMODE_COUNT; ++ pre)
			{
				board_set_tx(0);	
				board_set_bandf(1);	
				board_set_preamp(pre);
				board_update();		/* вывести забуферированные изменения в регистры */
				local_delay_ms(500);
			}
		}
	}
#endif

#if 0
	// test relays (attenuators, preapm, antenna switch)
	{
		for (;;)
		{
			int att;
			for (att = 0; att < ATTMODE_COUNT; ++ att)
			{
				int pre;
				for (pre = 0; pre < PAMPMODE_COUNT; ++ pre)
				{
					int ant;
					for (ant = 0; ant < ANTMODE_COUNT; ++ ant)
					{
						int bandf;
						for (bandf = 0; bandf < 8; ++ bandf)
						{
							board_set_att(att);
							board_set_antenna(ant);
							board_set_bandf(bandf);	
							board_set_bandf2(bandf);
							board_set_bandf3(bandf);
							board_set_preamp(pre);
							board_update();		/* вывести забуферированные изменения в регистры */
							local_delay_ms(100);
						}
					}
				}
			}
		}
	}
#endif

#if 0
	// тестирование сигналов выбора VFO
	{
		for (;;)
		{
			uint_fast8_t i;
			for (i = 0; i < HYBRID_NVFOS; ++ i)
			{
				board_ctl_set_vco(i);
				board_update();		/* вывести забуферированные изменения в регистры */
				local_delay_ms(500);
			}
		}
	}
#endif

#if 0
	enum { ADDR = 0x88 };
	// Test I/O exoanders at STM3210C-EVAL
	// Chip name: STMPE811
	// chip addresses: 0x82 & 0x88
	i2c_start(ADDR | 0x00);
	i2c_write(0x04);	// register to write: 0x17 - GPIO select gpio mode bits
	i2c_write(0x0b);	// value to write: 0x17 - GPIO I/O
	i2c_waitsend();
	i2c_stop();

	i2c_start(ADDR | 0x00);
	i2c_write(0x17);	// register to write: 0x17 - GPIO select gpio mode bits
	i2c_write(0xff);	// value to write: 0x17 - GPIO I/O
	i2c_waitsend();
	i2c_stop();

	#if 0
		// чтение всех регшистров
		for (;;)
		{
			int i;
			for (i = 0; i < 0x63; ++ i)
			{
				uint_fast8_t v1 = 0xaa;

				i2c_start(ADDR | 0x00);
				i2c_write_withrestart(i);	// register to read: 0x12 - GPIO monitor pin state register
				i2c_start(ADDR | 0x01);
				i2c_read(& v1, I2C_READ_ACK_NACK);	/* чтение первого и единственного байта ответа */
				
				static const FLASHMEM char fmt_1 [] = "%02X";
				char buff [17];
				local_snprintf_P(buff, 17, fmt_1, v1);

				display_gotoxy((i % 8) * 3, (i / 8) * 2);
				display_at(buff, 0);
			}
		}
	#endif

	for (;;)
	{

		enum { ADDR = 0x88 };
		uint_fast8_t v1 = 0xaa;

		i2c_start(ADDR | 0x00);
		i2c_write_withrestart(0x12);	// register to read: 0x12 - GPIO monitor pin state register
		i2c_start(ADDR | 0x01);
		i2c_read(& v1, I2C_READ_ACK_NACK);	/* чтение первого и единственного байта ответа */


		static const FLASHMEM char fmt_1 [] = "v=%02X";
		char buff [17];
		local_snprintf_P(buff, 17, fmt_1, v1);
		display_gotoxy(0, 0);
		display_at(buff, 0);
		local_delay_ms(100);
	}

#endif

#if 0
	// PCF8535 (tic154) address (r/w): 
	//	0x79/0x78, 0x7b/0x7a, 0x7d/0x7c, 0x7f/0x7e
	// PCF8574 (bus expander) address (r/w): 
	//	0x41/0x40, 0x43/0x42, 0x45/0x45, 0x47/0x46, 
	//	0x49/0x48, 0x4b/0x4a, 0x4d/0x4c, 0x4f/0x4e, 
	//
	// Test I2C interface
	i2c_start(0x4e);
	i2c_write(0xff);	// все биты на ввод
	i2c_waitsend();
	i2c_stop();

	for (;;)
	{
		i2c_start(0x4f);
		unsigned char v = i2c_readAck();
		//unsigned char v = i2c_readNak();
		//i2c_waitsend();
		i2c_stop();
		static const FLASHMEM char fmt_1 [] = "v=%02X";
		char buff [17];
		local_snprintf_P(buff, 17, fmt_1, v);
		display_gotoxy(0, 0);
		display_at(buff);
		local_delay_ms(100);
	}
#endif

#if 0
	// test SPI lines (output attenuator bits)
	display_dispfreq(v * 1000UL);
	for (;;)
	{
		int v = 0;
		uint_fast8_t kbch, repeat;

		if ((repeat = kbd_scan(& kbch)) != 0)
		{
			v = (v + 1) % 4;
			display_dispfreq(v * 1000UL);
			board_set_att(v);
			board_update();		/* вывести забуферированные изменения в регистры */
#if 1
			double x = v;
			double v = sin(x);	// проверка работы библиотечных функций с плавающей точкой
			uint_fast8_t lowhalf = HALFCOUNT_SMALL - 1;

			do
			{
				display_gotoxy(0, 1 + lowhalf);		// курсор в начало первой строки
				display2_menu_value(v * 1000ul, 7, 2, 1, lowhalf);
			} while (lowhalf --);
#endif
		}
	}
#endif

#if 0
	// test spi target on targetext1
	for (;;)
	{
		const spitarget_t target = targetext1;

		prog_select(target);	/* start sending data to target chip */

		prog_val(target, 0x77, 8);

		spi_to_read(target);
		unsigned char v = prog_read_byte();
		spi_to_write(target);

		prog_unselect(target);	/* done sending data to target chip */


	}
#endif

#if 0
	{
		unsigned long v = 0;
		//i2c_initialize();
		//display_initialize();
		for (;;)
		{	
			static const FLASHMEM char fmt_1 [] = "%08lX";
			char buff [17];

			local_snprintf_P(buff, 17, fmt_1, v ++);
			display_gotoxy(0, 0);
			display_at(buff, 0);
			
		}
	}
#endif

#if 0
	{
		uint_fast8_t pos = 0;
		board_cat_set_speed(9600);
		while (dbg_putchar(pos | 0xf0) == 0)
			;
		showpos(pos);
		for (;;)
		{
			uint_fast8_t kbch, repeat;

			local_delay_ms(500);
			pos = calc_next(pos, 0, 15);
			while (dbg_putchar(pos | 0xf0) == 0)
				continue;			
			;
			showpos(pos);
			continue;

			if ((repeat = kbd_scan(& kbch)) != 0)
			{
				switch (kbch)
				{
				case KBD_CODE_BAND_UP:
					pos = calc_next(pos, 0, 15);
					while (dbg_putchar(pos | 0xf0) == 0)
						;
					break;

				case KBD_CODE_BAND_DOWN:
					pos = calc_prev(pos, 0, 15);
					while (dbg_putchar(pos | 0xf0) == 0)
						;
					break;

				default:
					continue;
				}
				showpos(pos);
			}
			else
			{
				//while (dbg_putchar(pos | 0xf0) == 0)
				//	;
			}

		}
	}
#endif
#if 0 && WITHDSPEXTFIR
	{
		// Тестирование сигналов управления загрузкой параметров фильтров FPGA

		unsigned seq;

		TARGET_FPGA_FIR_INITIALIZE();

		for (seq = 0;; ++ seq)
		{
			if (seq & 0x01)
				TARGET_FPGA_FIR_CS_PORT_S(TARGET_FPGA_FIR_CS_BIT);
			else
				TARGET_FPGA_FIR_CS_PORT_C(TARGET_FPGA_FIR_CS_BIT);

			if (seq & 0x02)
				TARGET_FPGA_FIR1_WE_PORT_S(TARGET_FPGA_FIR1_WE_BIT);
			else
				TARGET_FPGA_FIR1_WE_PORT_C(TARGET_FPGA_FIR1_WE_BIT);

			if (seq & 0x04)
				TARGET_FPGA_FIR2_WE_PORT_S(TARGET_FPGA_FIR2_WE_BIT);
			else
				TARGET_FPGA_FIR2_WE_PORT_C(TARGET_FPGA_FIR2_WE_BIT);

			local_delay_ms(250);
		}
	}
#endif
}

// Вызывается перед инициализацией NVRAM, но после инициализации SPI
void midtests(void)
{
#if 0 && CPUSTYLE_R7S721
	// тестирование скорости после инициализации MMU
	{
		const uint32_t mask = (1U << 13);	// P6_13
		// R7S721 pins
		arm_hardware_pio6_outputs(mask, mask);
		for (;;)
		{
			R7S721_TARGET_PORT_S(6, mask);	/* P6_13=1 */
			local_delay_ms(10);
			R7S721_TARGET_PORT_C(6, mask);	/* P6_13=0 */
			local_delay_ms(10);
		}
	}
#endif
	//hardware_cw_diagnostics(0, 0, 1);	// 'U'
#if 0
	// тестирование управляемого по SPI регистра
	{
		for (;;)
		{
			const spitarget_t target = targetctl1;
			//
			spi_select(target, SPIC_MODE3);
			spi_progval8_p1(target, 0xff);
			spi_progval8_p2(target, 0xff);
			spi_progval8_p2(target, 0xff);
			spi_progval8_p2(target, 0xff);
			spi_complete(target);
			spi_unselect(target);
			local_delay_ms(500);
			//
			spi_select(target, SPIC_MODE3);
			spi_progval8_p1(target, 0x00);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0x00);
			spi_complete(target);
			spi_unselect(target);
			local_delay_ms(500);
		}

	}
#endif
#if 0
	// test SPI speed
	{
		const spitarget_t target = targetext1;
		//#if WITHSPIHW
		//	hardware_spi_master_setfreq(SPISPEED);
		//#endif /* WITHSPIHW */
		//arm_hardware_pioc_outputs(SPI_ADDRESS_BITS, target);
		//arm_hardware_pioa_outputs(SPI_NAEN_BIT, SPI_NAEN_BIT);

		//for (;;)
		//{
			//GPIOA->ODR ^= SPI_NAEN_BIT;	// Debug LEDs
		//}
		for (;;)
		{
			// тестирование аппаратного SPI в 16-битном режиме
			//prog_select(target);	
			//hardware_spi_connect_b16(SPIC_SPEEDFAST, SPIC_MODE3);		// если есть возможность - работаем в 16-ти битном режиме
			//hardware_spi_b16_p1(0xf0aa);
			//hardware_spi_complete_b8();
			//hardware_spi_disconnect();
			//prog_unselect(target);
			//continue;
			
			spi_select(target, SPIC_MODE3);
			spi_progval8_p1(target, 0xf0aa);
			spi_complete(target);
			spi_unselect(target);
			//local_delay_ms(1);
			continue;

			board_lcd_rs(0);
			spi_select(target, SPIC_MODE3);
			spi_progval8_p1(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_complete(target);
			spi_unselect(target);
			//local_delay_ms(50);

			board_lcd_rs(1);
			spi_select(target, SPIC_MODE3);
			spi_progval8_p1(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_progval8_p2(target, 0xFF);
			spi_progval8_p2(target, 0x00);
			spi_complete(target);
			spi_unselect(target);
			//local_delay_ms(50);
		}
	
	}
#endif

#if 0
	{
		// SPI CS address bus verify
		for (;;)
		{
			static const spitarget_t csa [] =
			{
				//SPI_CSEL0,
				//SPI_CSEL1,
				//SPI_CSEL2,
				//SPI_CSEL3,
				//SPI_CSEL4,
				//SPI_CSEL5,
				SPI_CSEL6,
				SPI_CSEL7,
			};
			uint_fast8_t i;

			for (i = 0; i < sizeof csa / sizeof csa [0]; ++ i)
			{
				const spitarget_t cs = csa [i];
				prog_select(cs);
				local_delay_ms(1000);
				prog_unselect(cs);
				local_delay_ms(1000);
			}
		}

	}
#endif
}
#if STM32F0XX_MD
void hardware_f051_dac_initialize(void)		/* инициализация DAC на STM32F4xx */
{
	RCC->APB1ENR |= RCC_APB1ENR_DACEN; //подать тактирование
	__DSB();

	DAC1->CR = DAC_CR_EN1;
}
// вывод 12-битного значения на ЦАП - канал 1
void hardware_f051_dac_ch1_setvalue(uint_fast16_t v)
{
	DAC1->DHR12R1 = v;
}
#endif /* STM32F0XX_MD */


#if CPUSTYLE_R7S721
/* Nested interrupts testbench */



#if 1 && WITHDEBUG

	typedef struct
	{
		uint8_t lock;
		int line;
		const char * file;
	} LOCK_T;

	static volatile LOCK_T locklist16;
	static volatile LOCK_T locklist32;
	static volatile LOCK_T locklist8;

	static void lock_impl(volatile LOCK_T * p, int line, const char * file, const char * variable)
	{
	#if WITHHARDINTERLOCK
		uint8_t r;
		do
			r = __LDREXB(& p->lock);
		while (__STREXB(1, & p->lock));
		if (r != 0)
		{
			debug_printf_P(PSTR("LOCK @%p %s already locked at %d in %s by %d in %s\n"), p, variable, line, file, p->line, p->file);
			for (;;)
				;
		}
		else
		{
			p->file = file;
			p->line = line;
		}
	#endif /* WITHHARDINTERLOCK */
	}

	static void unlock_impl(volatile LOCK_T * p, int line, const char * file, const char * variable)
	{
	#if WITHHARDINTERLOCK
		uint8_t r;
		do
			r = __LDREXB(& p->lock);
		while (__STREXB(0, & p->lock));
		if (r == 0)
		{
			debug_printf_P(PSTR("LOCK @%p %s already unlocked at %d in %s by %d in %s\n"), p, variable, line, file, p->line, p->file);
			for (;;)
				;
		}
		else
		{
			p->file = file;
			p->line = line;
		}
	#endif /* WITHHARDINTERLOCK */
	}

	#define LOCK(p) do { lock_impl((p), __LINE__, __FILE__, # p); } while (0)
	#define UNLOCK(p) do { unlock_impl((p), __LINE__, __FILE__, # p); } while (0)

#else /* WITHDEBUG */

	#define LOCK(p) do {  } while (0)
	#define UNLOCK(p) do {  } while (0)

#endif /* WITHDEBUG */

static void hw_swi(void)
{
	__asm volatile (" SWI  0" : /* no outputs */ : /* no inputs */  );
}

#if WITHDEBUG && 1
// ARM_SYSTEM_PRIORITY function
static void r7s721_ostm0_interrupt_test(void)
{
	LOCK(& locklist8);
	auto int marker;
	global_disableIRQ();
	debug_printf_P(PSTR("  Sy:@%p INTCICCRPR=%02x cpsr=%08lx!\n"), & marker, INTCICCRPR, __get_CPSR());
	global_enableIRQ();

	local_delay_ms(5);
	local_delay_ms(5);

	global_disableIRQ();
	debug_printf_P(PSTR("  Sy: INTCICCRPR=%02x cpsr=%08lx.\n"), INTCICCRPR, __get_CPSR());
	global_enableIRQ();
	UNLOCK(& locklist8);
}

// ARM_REALTIME_PRIORITY function
static void r7s721_ostm1_interrupt_test(void)
{
	LOCK(& locklist16);

	auto int marker;
	global_disableIRQ();
	debug_printf_P(PSTR("    Rt:@%p INTCICCRPR=%02x cpsr=%08lx!\n"), & marker, INTCICCRPR, __get_CPSR());
	global_enableIRQ();

	local_delay_ms(5);

	local_delay_ms(5);

	global_disableIRQ();
	debug_printf_P(PSTR("    rt: INTCICCRPR=%02x cpsr=%08lx.\n"), INTCICCRPR, __get_CPSR());
	global_enableIRQ();

	UNLOCK(& locklist16);
}

// ARM_REALTIME_PRIORITY function
static void spool_encinterruptR(void)
{
	LOCK(& locklist16);

	auto int marker;
	global_disableIRQ();
	debug_printf_P(PSTR("    E:@%p INTCICCRPR=%02x cpsr=%08lx!\n"), & marker, INTCICCRPR, __get_CPSR());
	global_enableIRQ();

	local_delay_ms(25);
	local_delay_ms(5);

	global_disableIRQ();
	debug_printf_P(PSTR("    e:INTCICCRPR=%02x cpsr=%08lx.\n"), INTCICCRPR, __get_CPSR());
	global_enableIRQ();

	UNLOCK(& locklist16);
}

void xSWIHandler(void)
{
	debug_printf_P(PSTR("SWIHandler trapped.\n"));
	global_enableIRQ();

	for (;;)
	{
		global_disableIRQ();
		debug_printf_P(PSTR("B: INTCICCRPR=%02x cpsr=%08lx*\n"), INTCICCRPR, __get_CPSR());
		global_enableIRQ();

		local_delay_ms(20);
		system_disableIRQ();
		local_delay_ms(20);
		system_enableIRQ();
	}
}

/* Главная функция программы */
int 
//__attribute__ ((used))
nestedirqtest(void)
{
	global_disableIRQ();
	cpu_initialize();		// в случае ARM - инициализация прерываний и контроллеров, AVR - запрет JTAG

	//HARDWARE_DEBUG_INITIALIZE();
	//HARDWARE_DEBUG_SET_SPEED(DEBUGSPEED);
	// выдача повторяющегося символа для тестирования скорости передачи, если ошибочная инициализация
	//for (;;)
	//	dbg_putchar(0xff);
	// тестирование приёма и передачи символов
	debug_printf_P(PSTR("INTCICCPMR=%02X\n"), INTCICCPMR);
	debug_printf_P(PSTR("ECHO test. Press ESC for done.\n"));
	for (;1;)
	{
		char c;
		if (dbg_getchar(& c))
		{
			if (c == 0x1b)
				break;
			dbg_putchar(c);
		}
	}
	board_init_io();		/* инициализация чипселектов и SPI, I2C, загрузка FPGA */
	hardware_timer_initialize(3);
	arm_hardware_set_handler_system(OSTMI0TINT_IRQn, r7s721_ostm0_interrupt_test);
	hardware_elkey_timer_initialize();
	hardware_elkey_set_speed(4);
	arm_hardware_set_handler_realtime(OSTMI1TINT_IRQn, r7s721_ostm1_interrupt_test);

#if defined (ENCODER_BITS)
	#if CTLSTYLE_RAVENDSP_V9
		do { \
			arm_hardware_pio2_alternative(ENCODER_BITS, R7S721_PIOALT_4); \
			arm_hardware_irqn_interrupt(1, 3, ARM_SYSTEM_PRIORITY, spool_encinterruptR); /* IRQ1, both edges */ \
			arm_hardware_irqn_interrupt(2, 3, ARM_SYSTEM_PRIORITY, spool_encinterruptR); /* IRQ2, both edges */ \
		} while (0);
	#endif
#endif /* defined (ENCODER_BITS) */
	debug_printf_P(PSTR("INTCICCRPR=%02x cpsr=%08lx* \n"), INTCICCRPR, __get_CPSR());
	//hw_swi();
	global_enableIRQ();

	for (;;)
	{
		unsigned iccrpr0 = INTCICCRPR;
		system_disableIRQ();
		unsigned iccrpr1 = INTCICCRPR;
		local_delay_ms(20);
		system_enableIRQ();

		global_disableIRQ();
		debug_printf_P(PSTR("iccrpr0=%02x, iccrpr1=%02x, INTCICCRPR=%02x cpsr=%08lx*\n"), iccrpr0, iccrpr1, INTCICCRPR, __get_CPSR());
		global_enableIRQ();

		local_delay_ms(20);

	}
}
#endif /* CPUSTYLE_R7S721 */
#endif /* WITHDEBUG */

static unsigned RAMFUNC_NONILINE testramfunc(void)
{
	return 9;
}

static unsigned RAMFUNC_NONILINE testramfunc2(void)
{
	return 10;
}

// FPU тут еще нельзя использовать
void lowtests(void)
{
#if 0 && CPUSTYLE_STM32MP1
	{
		//RCC->MP_APB5ENSETR = RCC_MC_APB5ENSETR_TZPCEN;
		//PRINTF("Hello. STM32MP157\n");
		//arm_hardware_pioa_altfn20(1uL << 13, 0);	// DBGTRO
		// LED blinking test
		//const uint_fast32_t mask = (1uL << 14);	// PA14 - GREEN LED LD5 on DK1/DK2 MB1272.pdf
		//const uint_fast32_t maskd = (1uL << 14);	// PD14 - LED on small board
		const uint_fast32_t maska = (1uL << 13);	// PA13 - bootloader status LED
		//arm_hardware_piod_outputs(maskd, 1 * maskd);
		arm_hardware_pioa_outputs(maska, 1 * maska);
		for (;;)
		{
			//dbg_putchar('5');
			//(GPIOD)->BSRR = BSRR_S(maskd);
			(GPIOA)->BSRR = BSRR_S(maska);
			__DSB();
			local_delay_ms(50);
			//dbg_putchar('#');
			//(GPIOD)->BSRR = BSRR_C(maskd);
			(GPIOA)->BSRR = BSRR_C(maska);
			__DSB();
			local_delay_ms(50);

		}
	}
#endif /* CPUSTYLE_STM32MP1 */
#if 0 && WITHDEBUG
	{
		// c++ execution test
		extern void cpptest(void);
		cpptest();
	}
#endif /* WITHDEBUG */
#if 0 && CPUSTYLE_R7S721
	{
		nestedirqtest();
	}
#endif /* CPUSTYLE_R7S721 */
#if 0
	{
		// Multi-regions initialize test
		volatile static unsigned v1;
		volatile static unsigned v2 = 2;
		volatile static unsigned RAMDTCM v3;
		volatile static unsigned RAMDTCM v4 = 4;
		volatile static unsigned RAMBIGDTCM v5;
		volatile static unsigned RAMBIGDTCM v6 = 6;
		volatile static unsigned RAMFRAMEBUFF v7;
		volatile static unsigned RAMBIG v8 = 7;

		debug_printf_P(PSTR("Unititilalized SRAM=%08lX @%p\n"), v1, & v1);
		debug_printf_P(PSTR("Ititilalized SRAM=%08lX @%p\n"), v2, & v2);
		debug_printf_P(PSTR("Unititilalized RAMDTCM=%08lX @%p\n"), v3, & v3);
		debug_printf_P(PSTR("Ititilalized RAMDTCM=%08lX @%p\n"), v4, & v4);
		debug_printf_P(PSTR("Unititilalized RAMBIGDTCM=%08lX @%p\n"), v5, & v5);
		debug_printf_P(PSTR("Ititilalized RAMBIGDTCM=%08lX @%p\n"), v6, & v6);
		debug_printf_P(PSTR("Unititilalized RAMFRAMEBUFF=%08lX @%p\n"), v7, & v7);
		debug_printf_P(PSTR("Ititilalized RAMFRAMEBUFF=%08lX @%p\n"), v8, & v8);
		debug_printf_P(PSTR("RAMFUNC_NONILINE #1=%08lX @%p\n"), testramfunc(), testramfunc);
		debug_printf_P(PSTR("RAMFUNC_NONILINE #2=%08lX @%p\n"), testramfunc2(), testramfunc2);
	}
#endif
#if 0
	{
		// PD13 signal pulses
		enum { WORKMASK	 = 1ul << 13 };
		arm_hardware_piod_outputs(WORKMASK, WORKMASK);

		for (;;)
		{
			arm_hardware_piod_outputs(WORKMASK, 1 * WORKMASK);
			hardware_spi_io_delay();
			local_delay_ms(300);
			arm_hardware_piod_outputs(WORKMASK, 0 * WORKMASK);
			hardware_spi_io_delay();
			local_delay_ms(300);
		}
	}
#endif
#if 0
	{
		HARDWARE_DEBUG_INITIALIZE();
		HARDWARE_DEBUG_SET_SPEED(DEBUGSPEED);
		//for (;;)
		dbg_puts_impl_P(PSTR("Version " __DATE__ " " __TIME__ " 2 debug session starts.\n"));
		#if 0
			// выдача повторяющегося символа для тестирования скорости передачи, если ошибочная инициализация
			for (;;)
				dbg_putchar(0xf0);
		#endif
		// тестирование приёма и передачи символов
		for (;1;)
		{
			char c;
			if (dbg_getchar(& c))
			{
				dbg_putchar(c);
				if (c == 0x1b)
					break;
			}
		}
		for (;;)
			;
	}
#endif
#if 0
	{
		// "бегающие огоньки" на светодиодах - 74HC595
		//arm_hardware_pio1_inputs(0xFF00);
		// тестирование SPI
		spi_initialize();

		uint_fast8_t i = 0;
		for (;;)
		{
			const uint_fast8_t timev = 1; //(~ GPIO.PPR1 >> 8) & 0xFF;
			const spitarget_t target = targetext1;
			uint_fast8_t v;
			//
			//TP();
			spi_select2(target, SPIC_MODE3, SPIC_SPEEDFAST);	// В FPGA регистр тактируется не в прямую
			spi_progval8_p1(target, 0xFF);		/* read status register */
			spi_complete(target);

			spi_to_read(target);
			v = spi_read_byte(target, 0xff);
			spi_to_write(target);

			spi_unselect(target);	/* done sending data to target chip */

			//local_delay_ms(10 * timev);
			++ i;
		}
	}
#endif /*  */
#if 0
	{
		// FPU test
		HARDWARE_DEBUG_INITIALIZE();
		HARDWARE_DEBUG_SET_SPEED(DEBUGSPEED);
		//for (;;)
		dbg_puts_impl_P(PSTR("Version " __DATE__ " " __TIME__ " 3 debug session starts.\n"));
		// выдача повторяющегося символа для тестирования скорости передачи, если ошибочная инициализация
		//for (;;)
		//	dbg_putchar(0xff);


		extern unsigned long __isr_vector__;
		debug_printf_P(PSTR("__isr_vector__=%p\n"), & __isr_vector__);
		volatile int a = 10, b = 0;
		volatile int c = a / b;
		TP();
		unsigned long i;
		for (i = 0x8000000;; ++ i)
		{
			TP();
			const double a = i ? i : 1;
			//const int ai = (int) (sin(a) * 1000);
			TP();
			debug_printf_P(PSTR("Hello! %lu, sqrt(%lu)=%lu\n"), i, (unsigned) a, (unsigned) sqrt(a));
			TP();
		}
	}
#endif /* CPUSTYLE_R7S721 */
#if 0 && CPUSTYLE_R7S721
	// тестирование скорости до инициализации MMU
	{
		const uint32_t mask = (1U << 13);	// P6_13
		// R7S721 pins
		arm_hardware_pio6_outputs(mask, mask);
		for (;;)
		{
			R7S721_TARGET_PORT_S(6, mask);	/* P6_13=1 */
			local_delay_ms(10);
			R7S721_TARGET_PORT_C(6, mask);	/* P6_13=0 */
			local_delay_ms(10);
		}
	}
#endif
#if 0
	{
		// Формирование импульсов на выводе процессора
		for (;;)
		{
			//const uint32_t WORKMASK = 1UL << 31;	// PA31
			const uint32_t WORKMASK =
				(1uL << 13) |		// BP13
				(1uL << 14) |		// BP14
				(1uL << 15) |		// BP15
				0;

			arm_hardware_piob_outputs(WORKMASK, WORKMASK * 1);
			hardware_spi_io_delay();
			arm_hardware_piob_outputs(WORKMASK, WORKMASK * 0);
			hardware_spi_io_delay();
		}
	}
#endif
#if 0
	hardware_f051_dac_initialize();
	for (;;)
	{
		unsigned i;
		for (i = 0; i < 4096; ++ i)
		{
			hardware_f051_dac_ch1_setvalue(i);
			arm_hardware_pioa_outputs(0x01, 0x01 * (i % 2));
		}
	}
#endif
#if ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED
	hardware_tim21_initialize();
	local_delay_ms(100);	// пока на выходе выпрямителя появится напряжение */
#endif /* ARM_STM32L051_TQFP32_CPUSTYLE_V1_H_INCLUDED */
}
